"""
This type stub file was generated by pyright.
"""

import builtins as __builtin__
from typing import List, Generator, Iterator

"""
The lldb module contains the public APIs for Python binding.

Some of the important classes are described here:

* :py:class:`SBTarget`: Represents the target program running under the debugger.
* :py:class:`SBProcess`: Represents the process associated with the target program.
* :py:class:`SBThread`: Represents a thread of execution. :py:class:`SBProcess` contains SBThreads.
* :py:class:`SBFrame`: Represents one of the stack frames associated with a thread. :py:class:`SBThread`
  contains SBFrame(s).
* :py:class:`SBSymbolContext`: A container that stores various debugger related info.
* :py:class:`SBValue`: Represents the value of a variable, a register, or an expression.
* :py:class:`SBModule`: Represents an executable image and its associated object and symbol
  files.  :py:class:`SBTarget` contains SBModule.
* :py:class:`SBBreakpoint`: Represents a logical breakpoint and its associated settings.
  :py:class:`SBTarget` contains SBBreakpoints.
* :py:class:`SBSymbol`: Represents the symbol possibly associated with a stack frame.
* :py:class:`SBCompileUnit`: Represents a compilation unit, or compiled source file.
* :py:class:`SBFunction`: Represents a generic function, which can be inlined or not.
* :py:class:`SBBlock`: Represents a lexical block. :py:class:`SBFunction` contains SBBlocks.
* :py:class:`SBLineEntry`: Specifies an association with a contiguous range of instructions
  and a source file location. :py:class:`SBCompileUnit` contains SBLineEntry.

The different enums in the `lldb` module are described in :doc:`python_api_enums`.


"""

def lldb_iter(obj, getsize, getelem): # -> Generator[Any, Any, None]:
    """A generator adaptor to support iteration for lldb container objects."""
    ...

INT32_MAX = ...
UINT32_MAX = ...
UINT64_MAX = ...
LLDB_GENERIC_ERROR = ...
LLDB_INVALID_BREAK_ID = ...
LLDB_DEFAULT_BREAK_SIZE = ...
LLDB_INVALID_WATCH_ID = ...
LLDB_WATCH_TYPE_READ = ...
LLDB_WATCH_TYPE_WRITE = ...
LLDB_REGNUM_GENERIC_PC = ...
LLDB_REGNUM_GENERIC_SP = ...
LLDB_REGNUM_GENERIC_FP = ...
LLDB_REGNUM_GENERIC_RA = ...
LLDB_REGNUM_GENERIC_FLAGS = ...
LLDB_REGNUM_GENERIC_ARG1 = ...
LLDB_REGNUM_GENERIC_ARG2 = ...
LLDB_REGNUM_GENERIC_ARG3 = ...
LLDB_REGNUM_GENERIC_ARG4 = ...
LLDB_REGNUM_GENERIC_ARG5 = ...
LLDB_REGNUM_GENERIC_ARG6 = ...
LLDB_REGNUM_GENERIC_ARG7 = ...
LLDB_REGNUM_GENERIC_ARG8 = ...
LLDB_INVALID_STOP_ID = ...
LLDB_INVALID_ADDRESS = ...
LLDB_INVALID_INDEX32 = ...
LLDB_INVALID_IVAR_OFFSET = ...
LLDB_INVALID_IMAGE_TOKEN = ...
LLDB_INVALID_MODULE_VERSION = ...
LLDB_INVALID_REGNUM = ...
LLDB_INVALID_UID = ...
LLDB_INVALID_PROCESS_ID = ...
LLDB_INVALID_THREAD_ID = ...
LLDB_INVALID_FRAME_ID = ...
LLDB_INVALID_SIGNAL_NUMBER = ...
LLDB_INVALID_OFFSET = ...
LLDB_INVALID_LINE_NUMBER = ...
LLDB_INVALID_COLUMN_NUMBER = ...
LLDB_INVALID_QUEUE_ID = ...
LLDB_INVALID_CPU_ID = ...
LLDB_ARCH_DEFAULT = ...
LLDB_ARCH_DEFAULT_32BIT = ...
LLDB_ARCH_DEFAULT_64BIT = ...
LLDB_INVALID_CPUTYPE = ...
LLDB_MAX_NUM_OPTION_SETS = ...
LLDB_OPT_SET_ALL = ...
LLDB_OPT_SET_1 = ...
LLDB_OPT_SET_2 = ...
LLDB_OPT_SET_3 = ...
LLDB_OPT_SET_4 = ...
LLDB_OPT_SET_5 = ...
LLDB_OPT_SET_6 = ...
LLDB_OPT_SET_7 = ...
LLDB_OPT_SET_8 = ...
LLDB_OPT_SET_9 = ...
LLDB_OPT_SET_10 = ...
LLDB_OPT_SET_11 = ...
LLDB_OPT_SET_12 = ...
eStateInvalid = ...
eStateUnloaded = ...
eStateConnected = ...
eStateAttaching = ...
eStateLaunching = ...
eStateStopped = ...
eStateRunning = ...
eStateStepping = ...
eStateCrashed = ...
eStateDetached = ...
eStateExited = ...
eStateSuspended = ...
kLastStateType = ...
eLaunchFlagNone = ...
eLaunchFlagExec = ...
eLaunchFlagDebug = ...
eLaunchFlagStopAtEntry = ...
eLaunchFlagDisableASLR = ...
eLaunchFlagDisableSTDIO = ...
eLaunchFlagLaunchInTTY = ...
eLaunchFlagLaunchInShell = ...
eLaunchFlagLaunchInSeparateProcessGroup = ...
eLaunchFlagDontSetExitStatus = ...
eLaunchFlagDetachOnError = ...
eLaunchFlagShellExpandArguments = ...
eLaunchFlagCloseTTYOnExit = ...
eLaunchFlagInheritTCCFromParent = ...
eOnlyThisThread = ...
eAllThreads = ...
eOnlyDuringStepping = ...
eByteOrderInvalid = ...
eByteOrderBig = ...
eByteOrderPDP = ...
eByteOrderLittle = ...
eEncodingInvalid = ...
eEncodingUint = ...
eEncodingSint = ...
eEncodingIEEE754 = ...
eEncodingVector = ...
eFormatDefault = ...
eFormatInvalid = ...
eFormatBoolean = ...
eFormatBinary = ...
eFormatBytes = ...
eFormatBytesWithASCII = ...
eFormatChar = ...
eFormatCharPrintable = ...
eFormatComplex = ...
eFormatComplexFloat = ...
eFormatCString = ...
eFormatDecimal = ...
eFormatEnum = ...
eFormatHex = ...
eFormatHexUppercase = ...
eFormatFloat = ...
eFormatOctal = ...
eFormatOSType = ...
eFormatUnicode16 = ...
eFormatUnicode32 = ...
eFormatUnsigned = ...
eFormatPointer = ...
eFormatVectorOfChar = ...
eFormatVectorOfSInt8 = ...
eFormatVectorOfUInt8 = ...
eFormatVectorOfSInt16 = ...
eFormatVectorOfUInt16 = ...
eFormatVectorOfSInt32 = ...
eFormatVectorOfUInt32 = ...
eFormatVectorOfSInt64 = ...
eFormatVectorOfUInt64 = ...
eFormatVectorOfFloat16 = ...
eFormatVectorOfFloat32 = ...
eFormatVectorOfFloat64 = ...
eFormatVectorOfUInt128 = ...
eFormatComplexInteger = ...
eFormatCharArray = ...
eFormatAddressInfo = ...
eFormatHexFloat = ...
eFormatInstruction = ...
eFormatVoid = ...
eFormatUnicode8 = ...
kNumFormats = ...
eDescriptionLevelBrief = ...
eDescriptionLevelFull = ...
eDescriptionLevelVerbose = ...
eDescriptionLevelInitial = ...
kNumDescriptionLevels = ...
eScriptLanguageNone = ...
eScriptLanguagePython = ...
eScriptLanguageLua = ...
eScriptLanguageUnknown = ...
eScriptLanguageDefault = ...
eRegisterKindEHFrame = ...
eRegisterKindDWARF = ...
eRegisterKindGeneric = ...
eRegisterKindProcessPlugin = ...
eRegisterKindLLDB = ...
kNumRegisterKinds = ...
eStopReasonInvalid = ...
eStopReasonNone = ...
eStopReasonTrace = ...
eStopReasonBreakpoint = ...
eStopReasonWatchpoint = ...
eStopReasonSignal = ...
eStopReasonException = ...
eStopReasonExec = ...
eStopReasonPlanComplete = ...
eStopReasonThreadExiting = ...
eStopReasonInstrumentation = ...
eStopReasonProcessorTrace = ...
eStopReasonFork = ...
eStopReasonVFork = ...
eStopReasonVForkDone = ...
eReturnStatusInvalid = ...
eReturnStatusSuccessFinishNoResult = ...
eReturnStatusSuccessFinishResult = ...
eReturnStatusSuccessContinuingNoResult = ...
eReturnStatusSuccessContinuingResult = ...
eReturnStatusStarted = ...
eReturnStatusFailed = ...
eReturnStatusQuit = ...
eExpressionCompleted = ...
eExpressionSetupError = ...
eExpressionParseError = ...
eExpressionDiscarded = ...
eExpressionInterrupted = ...
eExpressionHitBreakpoint = ...
eExpressionTimedOut = ...
eExpressionResultUnavailable = ...
eExpressionStoppedForDebug = ...
eExpressionThreadVanished = ...
eSearchDepthInvalid = ...
eSearchDepthTarget = ...
eSearchDepthModule = ...
eSearchDepthCompUnit = ...
eSearchDepthFunction = ...
eSearchDepthBlock = ...
eSearchDepthAddress = ...
kLastSearchDepthKind = ...
eConnectionStatusSuccess = ...
eConnectionStatusEndOfFile = ...
eConnectionStatusError = ...
eConnectionStatusTimedOut = ...
eConnectionStatusNoConnection = ...
eConnectionStatusLostConnection = ...
eConnectionStatusInterrupted = ...
eErrorTypeInvalid = ...
eErrorTypeGeneric = ...
eErrorTypeMachKernel = ...
eErrorTypePOSIX = ...
eErrorTypeExpression = ...
eErrorTypeWin32 = ...
eValueTypeInvalid = ...
eValueTypeVariableGlobal = ...
eValueTypeVariableStatic = ...
eValueTypeVariableArgument = ...
eValueTypeVariableLocal = ...
eValueTypeRegister = ...
eValueTypeRegisterSet = ...
eValueTypeConstResult = ...
eValueTypeVariableThreadLocal = ...
eInputReaderGranularityInvalid = ...
eInputReaderGranularityByte = ...
eInputReaderGranularityWord = ...
eInputReaderGranularityLine = ...
eInputReaderGranularityAll = ...
eSymbolContextTarget = ...
eSymbolContextModule = ...
eSymbolContextCompUnit = ...
eSymbolContextFunction = ...
eSymbolContextBlock = ...
eSymbolContextLineEntry = ...
eSymbolContextSymbol = ...
eSymbolContextEverything = ...
eSymbolContextVariable = ...
ePermissionsWritable = ...
ePermissionsReadable = ...
ePermissionsExecutable = ...
eInputReaderActivate = ...
eInputReaderAsynchronousOutputWritten = ...
eInputReaderReactivate = ...
eInputReaderDeactivate = ...
eInputReaderGotToken = ...
eInputReaderInterrupt = ...
eInputReaderEndOfFile = ...
eInputReaderDone = ...
eBreakpointEventTypeInvalidType = ...
eBreakpointEventTypeAdded = ...
eBreakpointEventTypeRemoved = ...
eBreakpointEventTypeLocationsAdded = ...
eBreakpointEventTypeLocationsRemoved = ...
eBreakpointEventTypeLocationsResolved = ...
eBreakpointEventTypeEnabled = ...
eBreakpointEventTypeDisabled = ...
eBreakpointEventTypeCommandChanged = ...
eBreakpointEventTypeConditionChanged = ...
eBreakpointEventTypeIgnoreChanged = ...
eBreakpointEventTypeThreadChanged = ...
eBreakpointEventTypeAutoContinueChanged = ...
eWatchpointEventTypeInvalidType = ...
eWatchpointEventTypeAdded = ...
eWatchpointEventTypeRemoved = ...
eWatchpointEventTypeEnabled = ...
eWatchpointEventTypeDisabled = ...
eWatchpointEventTypeCommandChanged = ...
eWatchpointEventTypeConditionChanged = ...
eWatchpointEventTypeIgnoreChanged = ...
eWatchpointEventTypeThreadChanged = ...
eWatchpointEventTypeTypeChanged = ...
eLanguageTypeUnknown = ...
eLanguageTypeC89 = ...
eLanguageTypeC = ...
eLanguageTypeAda83 = ...
eLanguageTypeC_plus_plus = ...
eLanguageTypeCobol74 = ...
eLanguageTypeCobol85 = ...
eLanguageTypeFortran77 = ...
eLanguageTypeFortran90 = ...
eLanguageTypePascal83 = ...
eLanguageTypeModula2 = ...
eLanguageTypeJava = ...
eLanguageTypeC99 = ...
eLanguageTypeAda95 = ...
eLanguageTypeFortran95 = ...
eLanguageTypePLI = ...
eLanguageTypeObjC = ...
eLanguageTypeObjC_plus_plus = ...
eLanguageTypeUPC = ...
eLanguageTypeD = ...
eLanguageTypePython = ...
eLanguageTypeOpenCL = ...
eLanguageTypeGo = ...
eLanguageTypeModula3 = ...
eLanguageTypeHaskell = ...
eLanguageTypeC_plus_plus_03 = ...
eLanguageTypeC_plus_plus_11 = ...
eLanguageTypeOCaml = ...
eLanguageTypeRust = ...
eLanguageTypeC11 = ...
eLanguageTypeSwift = ...
eLanguageTypeJulia = ...
eLanguageTypeDylan = ...
eLanguageTypeC_plus_plus_14 = ...
eLanguageTypeFortran03 = ...
eLanguageTypeFortran08 = ...
eLanguageTypeRenderScript = ...
eLanguageTypeBLISS = ...
eLanguageTypeKotlin = ...
eLanguageTypeZig = ...
eLanguageTypeCrystal = ...
eLanguageTypeC_plus_plus_17 = ...
eLanguageTypeC_plus_plus_20 = ...
eLanguageTypeC17 = ...
eLanguageTypeFortran18 = ...
eLanguageTypeAda2005 = ...
eLanguageTypeAda2012 = ...
eLanguageTypeMipsAssembler = ...
eLanguageTypeExtRenderScript = ...
eNumLanguageTypes = ...
eInstrumentationRuntimeTypeAddressSanitizer = ...
eInstrumentationRuntimeTypeThreadSanitizer = ...
eInstrumentationRuntimeTypeUndefinedBehaviorSanitizer = ...
eInstrumentationRuntimeTypeMainThreadChecker = ...
eInstrumentationRuntimeTypeSwiftRuntimeReporting = ...
eNumInstrumentationRuntimeTypes = ...
eNoDynamicValues = ...
eDynamicCanRunTarget = ...
eDynamicDontRunTarget = ...
eBindAuto = ...
eBind = ...
eDontBind = ...
eStopShowColumnAnsiOrCaret = ...
eStopShowColumnAnsi = ...
eStopShowColumnCaret = ...
eStopShowColumnNone = ...
eAccessNone = ...
eAccessPublic = ...
eAccessPrivate = ...
eAccessProtected = ...
eAccessPackage = ...
eArgTypeAddress = ...
eArgTypeAddressOrExpression = ...
eArgTypeAliasName = ...
eArgTypeAliasOptions = ...
eArgTypeArchitecture = ...
eArgTypeBoolean = ...
eArgTypeBreakpointID = ...
eArgTypeBreakpointIDRange = ...
eArgTypeBreakpointName = ...
eArgTypeByteSize = ...
eArgTypeClassName = ...
eArgTypeCommandName = ...
eArgTypeCount = ...
eArgTypeDescriptionVerbosity = ...
eArgTypeDirectoryName = ...
eArgTypeDisassemblyFlavor = ...
eArgTypeEndAddress = ...
eArgTypeExpression = ...
eArgTypeExpressionPath = ...
eArgTypeExprFormat = ...
eArgTypeFileLineColumn = ...
eArgTypeFilename = ...
eArgTypeFormat = ...
eArgTypeFrameIndex = ...
eArgTypeFullName = ...
eArgTypeFunctionName = ...
eArgTypeFunctionOrSymbol = ...
eArgTypeGDBFormat = ...
eArgTypeHelpText = ...
eArgTypeIndex = ...
eArgTypeLanguage = ...
eArgTypeLineNum = ...
eArgTypeLogCategory = ...
eArgTypeLogChannel = ...
eArgTypeMethod = ...
eArgTypeName = ...
eArgTypeNewPathPrefix = ...
eArgTypeNumLines = ...
eArgTypeNumberPerLine = ...
eArgTypeOffset = ...
eArgTypeOldPathPrefix = ...
eArgTypeOneLiner = ...
eArgTypePath = ...
eArgTypePermissionsNumber = ...
eArgTypePermissionsString = ...
eArgTypePid = ...
eArgTypePlugin = ...
eArgTypeProcessName = ...
eArgTypePythonClass = ...
eArgTypePythonFunction = ...
eArgTypePythonScript = ...
eArgTypeQueueName = ...
eArgTypeRegisterName = ...
eArgTypeRegularExpression = ...
eArgTypeRunArgs = ...
eArgTypeRunMode = ...
eArgTypeScriptedCommandSynchronicity = ...
eArgTypeScriptLang = ...
eArgTypeSearchWord = ...
eArgTypeSelector = ...
eArgTypeSettingIndex = ...
eArgTypeSettingKey = ...
eArgTypeSettingPrefix = ...
eArgTypeSettingVariableName = ...
eArgTypeShlibName = ...
eArgTypeSourceFile = ...
eArgTypeSortOrder = ...
eArgTypeStartAddress = ...
eArgTypeSummaryString = ...
eArgTypeSymbol = ...
eArgTypeThreadID = ...
eArgTypeThreadIndex = ...
eArgTypeThreadName = ...
eArgTypeTypeName = ...
eArgTypeUnsignedInteger = ...
eArgTypeUnixSignal = ...
eArgTypeVarName = ...
eArgTypeValue = ...
eArgTypeWidth = ...
eArgTypeNone = ...
eArgTypePlatform = ...
eArgTypeWatchpointID = ...
eArgTypeWatchpointIDRange = ...
eArgTypeWatchType = ...
eArgRawInput = ...
eArgTypeCommand = ...
eArgTypeColumnNum = ...
eArgTypeModuleUUID = ...
eArgTypeSaveCoreStyle = ...
eArgTypeLogHandler = ...
eArgTypeSEDStylePair = ...
eArgTypeRecognizerID = ...
eArgTypeConnectURL = ...
eArgTypeTargetID = ...
eArgTypeStopHookID = ...
eArgTypeBindGenTypeParamValue = ...
eArgTypeCompletionType = ...
eArgTypeLastArg = ...
eSymbolTypeAny = ...
eSymbolTypeInvalid = ...
eSymbolTypeAbsolute = ...
eSymbolTypeCode = ...
eSymbolTypeResolver = ...
eSymbolTypeData = ...
eSymbolTypeTrampoline = ...
eSymbolTypeRuntime = ...
eSymbolTypeException = ...
eSymbolTypeSourceFile = ...
eSymbolTypeHeaderFile = ...
eSymbolTypeObjectFile = ...
eSymbolTypeCommonBlock = ...
eSymbolTypeBlock = ...
eSymbolTypeLocal = ...
eSymbolTypeParam = ...
eSymbolTypeVariable = ...
eSymbolTypeVariableType = ...
eSymbolTypeLineEntry = ...
eSymbolTypeLineHeader = ...
eSymbolTypeScopeBegin = ...
eSymbolTypeScopeEnd = ...
eSymbolTypeAdditional = ...
eSymbolTypeCompiler = ...
eSymbolTypeInstrumentation = ...
eSymbolTypeUndefined = ...
eSymbolTypeObjCClass = ...
eSymbolTypeObjCMetaClass = ...
eSymbolTypeObjCIVar = ...
eSymbolTypeReExported = ...
eSymbolTypeASTFile = ...
eSectionTypeInvalid = ...
eSectionTypeCode = ...
eSectionTypeContainer = ...
eSectionTypeData = ...
eSectionTypeDataCString = ...
eSectionTypeDataCStringPointers = ...
eSectionTypeDataSymbolAddress = ...
eSectionTypeData4 = ...
eSectionTypeData8 = ...
eSectionTypeData16 = ...
eSectionTypeDataPointers = ...
eSectionTypeDebug = ...
eSectionTypeZeroFill = ...
eSectionTypeDataObjCMessageRefs = ...
eSectionTypeDataObjCCFStrings = ...
eSectionTypeDWARFDebugAbbrev = ...
eSectionTypeDWARFDebugAddr = ...
eSectionTypeDWARFDebugAranges = ...
eSectionTypeDWARFDebugCuIndex = ...
eSectionTypeDWARFDebugFrame = ...
eSectionTypeDWARFDebugInfo = ...
eSectionTypeDWARFDebugLine = ...
eSectionTypeDWARFDebugLoc = ...
eSectionTypeDWARFDebugMacInfo = ...
eSectionTypeDWARFDebugMacro = ...
eSectionTypeDWARFDebugPubNames = ...
eSectionTypeDWARFDebugPubTypes = ...
eSectionTypeDWARFDebugRanges = ...
eSectionTypeDWARFDebugStr = ...
eSectionTypeDWARFDebugStrOffsets = ...
eSectionTypeDWARFAppleNames = ...
eSectionTypeDWARFAppleTypes = ...
eSectionTypeDWARFAppleNamespaces = ...
eSectionTypeDWARFAppleObjC = ...
eSectionTypeELFSymbolTable = ...
eSectionTypeELFDynamicSymbols = ...
eSectionTypeELFRelocationEntries = ...
eSectionTypeELFDynamicLinkInfo = ...
eSectionTypeEHFrame = ...
eSectionTypeSwiftModules = ...
eSectionTypeARMexidx = ...
eSectionTypeARMextab = ...
eSectionTypeCompactUnwind = ...
eSectionTypeGoSymtab = ...
eSectionTypeAbsoluteAddress = ...
eSectionTypeDWARFGNUDebugAltLink = ...
eSectionTypeDWARFDebugTypes = ...
eSectionTypeDWARFDebugNames = ...
eSectionTypeOther = ...
eSectionTypeDWARFDebugLineStr = ...
eSectionTypeDWARFDebugRngLists = ...
eSectionTypeDWARFDebugLocLists = ...
eSectionTypeDWARFDebugAbbrevDwo = ...
eSectionTypeDWARFDebugInfoDwo = ...
eSectionTypeDWARFDebugStrDwo = ...
eSectionTypeDWARFDebugStrOffsetsDwo = ...
eSectionTypeDWARFDebugTypesDwo = ...
eSectionTypeDWARFDebugRngListsDwo = ...
eSectionTypeDWARFDebugLocDwo = ...
eSectionTypeDWARFDebugLocListsDwo = ...
eSectionTypeDWARFDebugTuIndex = ...
eEmulateInstructionOptionNone = ...
eEmulateInstructionOptionAutoAdvancePC = ...
eEmulateInstructionOptionIgnoreConditions = ...
eFunctionNameTypeNone = ...
eFunctionNameTypeAuto = ...
eFunctionNameTypeFull = ...
eFunctionNameTypeBase = ...
eFunctionNameTypeMethod = ...
eFunctionNameTypeSelector = ...
eFunctionNameTypeAny = ...
eBasicTypeInvalid = ...
eBasicTypeVoid = ...
eBasicTypeChar = ...
eBasicTypeSignedChar = ...
eBasicTypeUnsignedChar = ...
eBasicTypeWChar = ...
eBasicTypeSignedWChar = ...
eBasicTypeUnsignedWChar = ...
eBasicTypeChar16 = ...
eBasicTypeChar32 = ...
eBasicTypeChar8 = ...
eBasicTypeShort = ...
eBasicTypeUnsignedShort = ...
eBasicTypeInt = ...
eBasicTypeUnsignedInt = ...
eBasicTypeLong = ...
eBasicTypeUnsignedLong = ...
eBasicTypeLongLong = ...
eBasicTypeUnsignedLongLong = ...
eBasicTypeInt128 = ...
eBasicTypeUnsignedInt128 = ...
eBasicTypeBool = ...
eBasicTypeHalf = ...
eBasicTypeFloat = ...
eBasicTypeDouble = ...
eBasicTypeLongDouble = ...
eBasicTypeFloatComplex = ...
eBasicTypeDoubleComplex = ...
eBasicTypeLongDoubleComplex = ...
eBasicTypeObjCID = ...
eBasicTypeObjCClass = ...
eBasicTypeObjCSel = ...
eBasicTypeNullPtr = ...
eBasicTypeOther = ...
eTraceTypeNone = ...
eTraceTypeProcessorTrace = ...
eStructuredDataTypeInvalid = ...
eStructuredDataTypeNull = ...
eStructuredDataTypeGeneric = ...
eStructuredDataTypeArray = ...
eStructuredDataTypeInteger = ...
eStructuredDataTypeFloat = ...
eStructuredDataTypeBoolean = ...
eStructuredDataTypeString = ...
eStructuredDataTypeDictionary = ...
eStructuredDataTypeSignedInteger = ...
eStructuredDataTypeUnsignedInteger = ...
eTypeClassInvalid = ...
eTypeClassArray = ...
eTypeClassBlockPointer = ...
eTypeClassBuiltin = ...
eTypeClassClass = ...
eTypeClassComplexFloat = ...
eTypeClassComplexInteger = ...
eTypeClassEnumeration = ...
eTypeClassFunction = ...
eTypeClassMemberPointer = ...
eTypeClassObjCObject = ...
eTypeClassObjCInterface = ...
eTypeClassObjCObjectPointer = ...
eTypeClassPointer = ...
eTypeClassReference = ...
eTypeClassStruct = ...
eTypeClassTypedef = ...
eTypeClassUnion = ...
eTypeClassVector = ...
eTypeClassOther = ...
eTypeClassAny = ...
eTemplateArgumentKindNull = ...
eTemplateArgumentKindType = ...
eTemplateArgumentKindDeclaration = ...
eTemplateArgumentKindIntegral = ...
eTemplateArgumentKindTemplate = ...
eTemplateArgumentKindTemplateExpansion = ...
eTemplateArgumentKindExpression = ...
eTemplateArgumentKindPack = ...
eTemplateArgumentKindNullPtr = ...
eFormatterMatchExact = ...
eFormatterMatchRegex = ...
eLastFormatterMatchType = ...
eNullGenericKindType = ...
eBoundGenericKindType = ...
eUnboundGenericKindType = ...
eTypeOptionNone = ...
eTypeOptionCascade = ...
eTypeOptionSkipPointers = ...
eTypeOptionSkipReferences = ...
eTypeOptionHideChildren = ...
eTypeOptionHideValue = ...
eTypeOptionShowOneLiner = ...
eTypeOptionHideNames = ...
eTypeOptionNonCacheable = ...
eTypeOptionHideEmptyAggregates = ...
eTypeOptionFrontEndWantsDereference = ...
eFrameCompareInvalid = ...
eFrameCompareUnknown = ...
eFrameCompareEqual = ...
eFrameCompareSameParent = ...
eFrameCompareYounger = ...
eFrameCompareOlder = ...
eFilePermissionsUserRead = ...
eFilePermissionsUserWrite = ...
eFilePermissionsUserExecute = ...
eFilePermissionsGroupRead = ...
eFilePermissionsGroupWrite = ...
eFilePermissionsGroupExecute = ...
eFilePermissionsWorldRead = ...
eFilePermissionsWorldWrite = ...
eFilePermissionsWorldExecute = ...
eFilePermissionsUserRW = ...
eFileFilePermissionsUserRX = ...
eFilePermissionsUserRWX = ...
eFilePermissionsGroupRW = ...
eFilePermissionsGroupRX = ...
eFilePermissionsGroupRWX = ...
eFilePermissionsWorldRW = ...
eFilePermissionsWorldRX = ...
eFilePermissionsWorldRWX = ...
eFilePermissionsEveryoneR = ...
eFilePermissionsEveryoneW = ...
eFilePermissionsEveryoneX = ...
eFilePermissionsEveryoneRW = ...
eFilePermissionsEveryoneRX = ...
eFilePermissionsEveryoneRWX = ...
eFilePermissionsFileDefault = ...
eFilePermissionsDirectoryDefault = ...
eQueueItemKindUnknown = ...
eQueueItemKindFunction = ...
eQueueItemKindBlock = ...
eQueueKindUnknown = ...
eQueueKindSerial = ...
eQueueKindConcurrent = ...
eExpressionEvaluationParse = ...
eExpressionEvaluationIRGen = ...
eExpressionEvaluationExecution = ...
eExpressionEvaluationComplete = ...
eInstructionControlFlowKindUnknown = ...
eInstructionControlFlowKindOther = ...
eInstructionControlFlowKindCall = ...
eInstructionControlFlowKindReturn = ...
eInstructionControlFlowKindJump = ...
eInstructionControlFlowKindCondJump = ...
eInstructionControlFlowKindFarCall = ...
eInstructionControlFlowKindFarReturn = ...
eInstructionControlFlowKindFarJump = ...
eWatchpointKindWrite = ...
eWatchpointKindRead = ...
eGdbSignalBadAccess = ...
eGdbSignalBadInstruction = ...
eGdbSignalArithmetic = ...
eGdbSignalEmulation = ...
eGdbSignalSoftware = ...
eGdbSignalBreakpoint = ...
ePathTypeLLDBShlibDir = ...
ePathTypeSupportExecutableDir = ...
ePathTypeHeaderDir = ...
ePathTypePythonDir = ...
ePathTypeLLDBSystemPlugins = ...
ePathTypeLLDBUserPlugins = ...
ePathTypeLLDBTempSystemDir = ...
ePathTypeGlobalLLDBTempSystemDir = ...
ePathTypeClangDir = ...
ePathTypeSwiftDir = ...
eMemberFunctionKindUnknown = ...
eMemberFunctionKindConstructor = ...
eMemberFunctionKindDestructor = ...
eMemberFunctionKindInstanceMethod = ...
eMemberFunctionKindStaticMethod = ...
eMatchTypeNormal = ...
eMatchTypeRegex = ...
eMatchTypeStartsWith = ...
eTypeHasChildren = ...
eTypeHasValue = ...
eTypeIsArray = ...
eTypeIsBlock = ...
eTypeIsBuiltIn = ...
eTypeIsClass = ...
eTypeIsCPlusPlus = ...
eTypeIsEnumeration = ...
eTypeIsFuncPrototype = ...
eTypeIsMember = ...
eTypeIsObjC = ...
eTypeIsPointer = ...
eTypeIsReference = ...
eTypeIsStructUnion = ...
eTypeIsTemplate = ...
eTypeIsTypedef = ...
eTypeIsVector = ...
eTypeIsScalar = ...
eTypeIsInteger = ...
eTypeIsFloat = ...
eTypeIsComplex = ...
eTypeIsSigned = ...
eTypeInstanceIsPointer = ...
eTypeIsSwift = ...
eTypeIsGenericTypeParam = ...
eTypeIsProtocol = ...
eTypeIsTuple = ...
eTypeIsMetatype = ...
eTypeHasUnboundGeneric = ...
eTypeHasDynamicSelf = ...
eTypeIsPack = ...
eCommandRequiresTarget = ...
eCommandRequiresProcess = ...
eCommandRequiresThread = ...
eCommandRequiresFrame = ...
eCommandRequiresRegContext = ...
eCommandTryTargetAPILock = ...
eCommandProcessMustBeLaunched = ...
eCommandProcessMustBePaused = ...
eCommandProcessMustBeTraced = ...
eTypeSummaryCapped = ...
eTypeSummaryUncapped = ...
eCommandInterpreterResultSuccess = ...
eCommandInterpreterResultInferiorCrash = ...
eCommandInterpreterResultCommandError = ...
eCommandInterpreterResultQuitRequested = ...
eSaveCoreUnspecified = ...
eSaveCoreFull = ...
eSaveCoreDirtyOnly = ...
eSaveCoreStackOnly = ...
eTraceEventDisabledSW = ...
eTraceEventDisabledHW = ...
eTraceEventCPUChanged = ...
eTraceEventHWClockTick = ...
eTraceEventSyncPoint = ...
eTraceItemKindError = ...
eTraceItemKindEvent = ...
eTraceItemKindInstruction = ...
eTraceCursorSeekTypeBeginning = ...
eTraceCursorSeekTypeCurrent = ...
eTraceCursorSeekTypeEnd = ...
eDWIMPrintVerbosityNone = ...
eDWIMPrintVerbosityExpression = ...
eDWIMPrintVerbosityFull = ...
eWatchPointValueKindInvalid = ...
eWatchPointValueKindVariable = ...
eWatchPointValueKindExpression = ...
eNoCompletion = ...
eSourceFileCompletion = ...
eDiskFileCompletion = ...
eDiskDirectoryCompletion = ...
eSymbolCompletion = ...
eModuleCompletion = ...
eSettingsNameCompletion = ...
ePlatformPluginCompletion = ...
eArchitectureCompletion = ...
eVariablePathCompletion = ...
eRegisterCompletion = ...
eBreakpointCompletion = ...
eProcessPluginCompletion = ...
eDisassemblyFlavorCompletion = ...
eTypeLanguageCompletion = ...
eFrameIndexCompletion = ...
eModuleUUIDCompletion = ...
eStopHookIDCompletion = ...
eThreadIndexCompletion = ...
eWatchpointIDCompletion = ...
eBreakpointNameCompletion = ...
eProcessIDCompletion = ...
eProcessNameCompletion = ...
eRemoteDiskFileCompletion = ...
eRemoteDiskDirectoryCompletion = ...
eTypeCategoryNameCompletion = ...
eCustomCompletion = ...


# noinspection PyPep8Naming
class SBAddress:
    r"""
    A section + offset based address class.

    The SBAddress class allows addresses to be relative to a section
    that can move during runtime due to images (executables, shared
    libraries, bundles, frameworks) being loaded at different
    addresses than the addresses found in the object file that
    represents them on disk. There are currently two types of addresses
    for a section:

    * file addresses
    * load addresses

    File addresses represents the virtual addresses that are in the 'on
    disk' object files. These virtual addresses are converted to be
    relative to unique sections scoped to the object file so that
    when/if the addresses slide when the images are loaded/unloaded
    in memory, we can easily track these changes without having to
    update every object (compile unit ranges, line tables, function
    address ranges, lexical block and inlined subroutine address
    ranges, global and static variables) each time an image is loaded or
    unloaded.

    Load addresses represents the virtual addresses where each section
    ends up getting loaded at runtime. Before executing a program, it
    is common for all of the load addresses to be unresolved. When a
    DynamicLoader plug-in receives notification that shared libraries
    have been loaded/unloaded, the load addresses of the main executable
    and any images (shared libraries) will be  resolved/unresolved. When
    this happens, breakpoints that are in one of these sections can be
    set/cleared.

    See docstring of SBFunction for example usage of SBAddress.
    """
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBAddress self) -> SBAddress
        __init__(SBAddress self, SBAddress rhs) -> SBAddress
        __init__(SBAddress self, SBSection section, lldb::addr_t offset) -> SBAddress
        __init__(SBAddress self, lldb::addr_t load_addr, SBTarget target) -> SBAddress

            Create an address by resolving a load address using the supplied target.
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBAddress self, SBAddress rhs) -> bool"""
        ...
    
    def IsValid(self) -> bool:
        r"""IsValid(SBAddress self) -> bool"""
        ...
    
    def Clear(self):
        r"""Clear(SBAddress self)"""
        ...
    
    def GetFileAddress(self) -> int:
        r"""GetFileAddress(SBAddress self) -> lldb::addr_t"""
        ...
    
    def GetLoadAddress(self, target: SBTarget) -> int:
        r"""GetLoadAddress(SBAddress self, SBTarget target) -> lldb::addr_t"""
        ...
    
    def SetAddress(self, section: SBSection, offset: int):
        r"""SetAddress(SBAddress self, SBSection section, lldb::addr_t offset)"""
        ...
    
    def SetLoadAddress(self, load_addr: int, target: SBTarget):
        r"""SetLoadAddress(SBAddress self, lldb::addr_t load_addr, SBTarget target)"""
        ...
    
    def OffsetAddress(self, offset: int) -> bool:
        r"""OffsetAddress(SBAddress self, lldb::addr_t offset) -> bool"""
        ...
    
    def GetDescription(self, description: SBStream) -> bool:
        r"""GetDescription(SBAddress self, SBStream description) -> bool"""
        ...

    def GetSymbolContext(self, resolve_scope: int) -> SBSymbolContext:
        r"""
        GetSymbolContext(SBAddress self, uint32_t resolve_scope) -> SBSymbolContext

            GetSymbolContext() and the following can lookup symbol information for a given address.
            An address might refer to code or data from an existing module, or it
            might refer to something on the stack or heap. The following functions
            will only return valid values if the address has been resolved to a code
            or data address using :py:class:`SBAddress.SetLoadAddress' or
            :py:class:`SBTarget.ResolveLoadAddress`.
        """
        ...
    
    def GetSection(self) -> SBSection:
        r"""GetSection(SBAddress self) -> SBSection"""
        ...
    
    def GetOffset(self) -> int:
        r"""GetOffset(SBAddress self) -> lldb::addr_t"""
        ...
    
    def GetModule(self) -> SBModule:
        r"""
        GetModule(SBAddress self) -> SBModule

            GetModule() and the following grab individual objects for a given address and
            are less efficient if you want more than one symbol related objects.
            Use :py:class:`SBAddress.GetSymbolContext` or
            :py:class:`SBTarget.ResolveSymbolContextForAddress` when you want multiple
            debug symbol related objects for an address.
            One or more bits from the SymbolContextItem enumerations can be logically
            OR'ed together to more efficiently retrieve multiple symbol objects.
        """
        ...
    
    def GetCompileUnit(self) -> SBCompileUnit:
        r"""GetCompileUnit(SBAddress self) -> SBCompileUnit"""
        ...
    
    def GetFunction(self) -> SBFunction:
        r"""GetFunction(SBAddress self) -> SBFunction"""
        ...
    
    def GetBlock(self) -> SBBlock:
        r"""GetBlock(SBAddress self) -> SBBlock"""
        ...
    
    def GetSymbol(self) -> SBSymbol:
        r"""GetSymbol(SBAddress self) -> SBSymbol"""
        ...
    
    def GetLineEntry(self) -> SBLineEntry:
        r"""GetLineEntry(SBAddress self) -> SBLineEntry"""
        ...
    
    def __repr__(self) -> str:
        r"""__repr__(SBAddress self) -> std::string"""
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    __runtime_error_str = ...
    def __get_load_addr_property__(self):
        '''Get the load address for a lldb.SBAddress using the current target. This resolves the SBAddress using the SBTarget from lldb.target so this property can ONLY be used in the interactive script interpreter (i.e. under the lldb script command). For things like Python based commands and breakpoint callbacks use GetLoadAddress instead.'''
        ...
    
    def __set_load_addr_property__(self, load_addr):
        '''Set the load address for a lldb.SBAddress using the current target. This resolves the SBAddress using the SBTarget from lldb.target so this property can ONLY be used in the interactive script interpreter (i.e. under the lldb script command). For things like Python based commands and breakpoint callbacks use GetLoadAddress instead.'''
        ...
    
    def __int__(self) -> int:
        '''Convert an address to a load address if there is a process and that process is alive, or to a file address otherwise. This resolves the SBAddress using the SBTarget from lldb.target so this property can ONLY be used in the interactive script interpreter (i.e. under the lldb script command). For things like Python based commands and breakpoint callbacks use GetLoadAddress instead.'''
        ...
    
    def __oct__(self): # -> str:
        '''Convert the address to an octal string. This resolves the SBAddress using the SBTarget from lldb.target so this property can ONLY be used in the interactive script interpreter (i.e. under the lldb script command). For things like Python based commands and breakpoint callbacks use GetLoadAddress instead.'''
        ...
    
    def __hex__(self): # -> str:
        '''Convert the address to an hex string. This resolves the SBAddress using the SBTarget from lldb.target so this property can ONLY be used in the interactive script interpreter (i.e. under the lldb script command). For things like Python based commands and breakpoint callbacks use GetLoadAddress instead.'''
        ...
    
    module: SBModule = ...
    compile_unit: SBCompileUnit = ...
    line_entry: SBLineEntry = ...
    function: SBFunction = ...
    block: SBBlock = ...
    symbol: SBSymbol = ...
    offset: int = ...
    section: SBSection = ...
    file_addr: int = ...
    load_addr: int = ...


class SBAttachInfo:
    r"""Describes how to attach when calling :py:class:`SBTarget.Attach`."""
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBAttachInfo self) -> SBAttachInfo
        __init__(SBAttachInfo self, lldb::pid_t pid) -> SBAttachInfo
        __init__(SBAttachInfo self, char const * path, bool wait_for) -> SBAttachInfo
        __init__(SBAttachInfo self, char const * path, bool wait_for, bool _async) -> SBAttachInfo
        __init__(SBAttachInfo self, SBAttachInfo rhs) -> SBAttachInfo
        """
        ...
    
    __swig_destroy__ = ...
    def GetProcessID(self):
        r"""GetProcessID(SBAttachInfo self) -> lldb::pid_t"""
        ...
    
    def SetProcessID(self, pid):
        r"""SetProcessID(SBAttachInfo self, lldb::pid_t pid)"""
        ...
    
    def SetExecutable(self, *args):
        r"""
        SetExecutable(SBAttachInfo self, char const * path)
        SetExecutable(SBAttachInfo self, SBFileSpec exe_file)
        """
        ...
    
    def GetWaitForLaunch(self):
        r"""GetWaitForLaunch(SBAttachInfo self) -> bool"""
        ...
    
    def SetWaitForLaunch(self, *args):
        r"""
        SetWaitForLaunch(SBAttachInfo self, bool b)
        SetWaitForLaunch(SBAttachInfo self, bool b, bool _async)
        """
        ...
    
    def GetIgnoreExisting(self):
        r"""GetIgnoreExisting(SBAttachInfo self) -> bool"""
        ...
    
    def SetIgnoreExisting(self, b):
        r"""SetIgnoreExisting(SBAttachInfo self, bool b)"""
        ...
    
    def GetResumeCount(self):
        r"""GetResumeCount(SBAttachInfo self) -> uint32_t"""
        ...
    
    def SetResumeCount(self, c):
        r"""SetResumeCount(SBAttachInfo self, uint32_t c)"""
        ...
    
    def GetProcessPluginName(self):
        r"""GetProcessPluginName(SBAttachInfo self) -> char const *"""
        ...
    
    def SetProcessPluginName(self, plugin_name):
        r"""SetProcessPluginName(SBAttachInfo self, char const * plugin_name)"""
        ...
    
    def GetUserID(self):
        r"""GetUserID(SBAttachInfo self) -> uint32_t"""
        ...
    
    def GetGroupID(self):
        r"""GetGroupID(SBAttachInfo self) -> uint32_t"""
        ...
    
    def UserIDIsValid(self):
        r"""UserIDIsValid(SBAttachInfo self) -> bool"""
        ...
    
    def GroupIDIsValid(self):
        r"""GroupIDIsValid(SBAttachInfo self) -> bool"""
        ...
    
    def SetUserID(self, uid):
        r"""SetUserID(SBAttachInfo self, uint32_t uid)"""
        ...
    
    def SetGroupID(self, gid):
        r"""SetGroupID(SBAttachInfo self, uint32_t gid)"""
        ...
    
    def GetEffectiveUserID(self):
        r"""GetEffectiveUserID(SBAttachInfo self) -> uint32_t"""
        ...
    
    def GetEffectiveGroupID(self):
        r"""GetEffectiveGroupID(SBAttachInfo self) -> uint32_t"""
        ...
    
    def EffectiveUserIDIsValid(self):
        r"""EffectiveUserIDIsValid(SBAttachInfo self) -> bool"""
        ...
    
    def EffectiveGroupIDIsValid(self):
        r"""EffectiveGroupIDIsValid(SBAttachInfo self) -> bool"""
        ...
    
    def SetEffectiveUserID(self, uid):
        r"""SetEffectiveUserID(SBAttachInfo self, uint32_t uid)"""
        ...
    
    def SetEffectiveGroupID(self, gid):
        r"""SetEffectiveGroupID(SBAttachInfo self, uint32_t gid)"""
        ...
    
    def GetParentProcessID(self):
        r"""GetParentProcessID(SBAttachInfo self) -> lldb::pid_t"""
        ...
    
    def SetParentProcessID(self, pid):
        r"""SetParentProcessID(SBAttachInfo self, lldb::pid_t pid)"""
        ...
    
    def ParentProcessIDIsValid(self):
        r"""ParentProcessIDIsValid(SBAttachInfo self) -> bool"""
        ...
    
    def GetListener(self):
        r"""GetListener(SBAttachInfo self) -> SBListener"""
        ...
    
    def SetListener(self, listener):
        r"""SetListener(SBAttachInfo self, SBListener listener)"""
        ...
    
    def GetShadowListener(self):
        r"""GetShadowListener(SBAttachInfo self) -> SBListener"""
        ...
    
    def SetShadowListener(self, listener):
        r"""SetShadowListener(SBAttachInfo self, SBListener listener)"""
        ...
    
    def GetScriptedProcessClassName(self):
        r"""GetScriptedProcessClassName(SBAttachInfo self) -> char const *"""
        ...
    
    def SetScriptedProcessClassName(self, class_name):
        r"""SetScriptedProcessClassName(SBAttachInfo self, char const * class_name)"""
        ...
    
    def GetScriptedProcessDictionary(self):
        r"""GetScriptedProcessDictionary(SBAttachInfo self) -> SBStructuredData"""
        ...
    
    def SetScriptedProcessDictionary(self, dict):
        r"""SetScriptedProcessDictionary(SBAttachInfo self, SBStructuredData dict)"""
        ...
    


class SBBlock:
    r"""Represents a lexical block. SBFunction contains SBBlock(s)."""
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBBlock self) -> SBBlock
        __init__(SBBlock self, SBBlock rhs) -> SBBlock
        """
        ...
    
    __swig_destroy__ = ...
    def IsInlined(self):
        r"""
        IsInlined(SBBlock self) -> bool
        Is this block contained within an inlined function?
        """
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBBlock self) -> bool"""
        ...
    
    def GetInlinedName(self):
        r"""
        GetInlinedName(SBBlock self) -> char const *

            Get the function name if this block represents an inlined function;
            otherwise, return None.
        """
        ...
    
    def GetInlinedCallSiteFile(self):
        r"""
        GetInlinedCallSiteFile(SBBlock self) -> SBFileSpec

            Get the call site file if this block represents an inlined function;
            otherwise, return an invalid file spec.
        """
        ...
    
    def GetInlinedCallSiteLine(self):
        r"""
        GetInlinedCallSiteLine(SBBlock self) -> uint32_t

            Get the call site line if this block represents an inlined function;
            otherwise, return 0.
        """
        ...
    
    def GetInlinedCallSiteColumn(self):
        r"""
        GetInlinedCallSiteColumn(SBBlock self) -> uint32_t

            Get the call site column if this block represents an inlined function;
            otherwise, return 0.
        """
        ...
    
    def GetParent(self):
        r"""
        GetParent(SBBlock self) -> SBBlock
        Get the parent block.
        """
        ...
    
    def GetSibling(self):
        r"""
        GetSibling(SBBlock self) -> SBBlock
        Get the sibling block for this block.
        """
        ...
    
    def GetFirstChild(self):
        r"""
        GetFirstChild(SBBlock self) -> SBBlock
        Get the first child block.
        """
        ...
    
    def GetNumRanges(self):
        r"""GetNumRanges(SBBlock self) -> uint32_t"""
        ...
    
    def GetRangeStartAddress(self, idx):
        r"""GetRangeStartAddress(SBBlock self, uint32_t idx) -> SBAddress"""
        ...
    
    def GetRangeEndAddress(self, idx):
        r"""GetRangeEndAddress(SBBlock self, uint32_t idx) -> SBAddress"""
        ...
    
    def GetRangeIndexForBlockAddress(self, block_addr):
        r"""GetRangeIndexForBlockAddress(SBBlock self, SBAddress block_addr) -> uint32_t"""
        ...
    
    def GetVariables(self, *args):
        r"""
        GetVariables(SBBlock self, SBFrame frame, bool arguments, bool locals, bool statics, lldb::DynamicValueType use_dynamic) -> SBValueList
        GetVariables(SBBlock self, SBTarget target, bool arguments, bool locals, bool statics) -> SBValueList
        """
        ...
    
    def GetContainingInlinedBlock(self):
        r"""
        GetContainingInlinedBlock(SBBlock self) -> SBBlock
        Get the inlined block that is or contains this block.
        """
        ...
    
    def GetDescription(self, description):
        r"""GetDescription(SBBlock self, SBStream description) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBBlock self) -> std::string"""
        ...
    
    def get_range_at_index(self, idx): # -> list[Any]:
        ...
    
    class ranges_access:
        '''A helper object that will lazily hand out an array of lldb.SBAddress that represent address ranges for a block.'''
        def __init__(self, sbblock) -> None:
            ...
        
        def __len__(self): # -> int:
            ...
        
        def __getitem__(self, key): # -> list[Any] | None:
            ...
        
    
    
    def get_ranges_access_object(self): # -> ranges_access:
        '''An accessor function that returns a ranges_access() object which allows lazy block address ranges access.'''
        ...
    
    def get_ranges_array(self): # -> list[Any]:
        '''An accessor function that returns an array object that contains all ranges in this block object.'''
        ...
    
    def get_call_site(self): # -> declaration:
        ...
    
    parent = ...
    first_child = ...
    call_site = ...
    sibling = ...
    name = ...
    inlined_block = ...
    range = ...
    ranges = ...
    num_ranges = ...


class SBBreakpoint:
    r"""
    Represents a logical breakpoint and its associated settings.

    For example (from test/functionalities/breakpoint/breakpoint_ignore_count/
    TestBreakpointIgnoreCount.py),::

        def breakpoint_ignore_count_python(self):
            '''Use Python APIs to set breakpoint ignore count.'''
            exe = os.path.join(os.getcwd(), 'a.out')

            # Create a target by the debugger.
            target = self.dbg.CreateTarget(exe)
            self.assertTrue(target, VALID_TARGET)

            # Now create a breakpoint on main.c by name 'c'.
            breakpoint = target.BreakpointCreateByName('c', 'a.out')
            self.assertTrue(breakpoint and
                            breakpoint.GetNumLocations() == 1,
                            VALID_BREAKPOINT)

            # Get the breakpoint location from breakpoint after we verified that,
            # indeed, it has one location.
            location = breakpoint.GetLocationAtIndex(0)
            self.assertTrue(location and
                            location.IsEnabled(),
                            VALID_BREAKPOINT_LOCATION)

            # Set the ignore count on the breakpoint location.
            location.SetIgnoreCount(2)
            self.assertTrue(location.GetIgnoreCount() == 2,
                            'SetIgnoreCount() works correctly')

            # Now launch the process, and do not stop at entry point.
            process = target.LaunchSimple(None, None, os.getcwd())
            self.assertTrue(process, PROCESS_IS_VALID)

            # Frame#0 should be on main.c:37, frame#1 should be on main.c:25, and
            # frame#2 should be on main.c:48.
            #lldbutil.print_stacktraces(process)
            from lldbutil import get_stopped_thread
            thread = get_stopped_thread(process, lldb.eStopReasonBreakpoint)
            self.assertTrue(thread != None, 'There should be a thread stopped due to breakpoint')
            frame0 = thread.GetFrameAtIndex(0)
            frame1 = thread.GetFrameAtIndex(1)
            frame2 = thread.GetFrameAtIndex(2)
            self.assertTrue(frame0.GetLineEntry().GetLine() == self.line1 and
                            frame1.GetLineEntry().GetLine() == self.line3 and
                            frame2.GetLineEntry().GetLine() == self.line4,
                            STOPPED_DUE_TO_BREAKPOINT_IGNORE_COUNT)

            # The hit count for the breakpoint should be 3.
            self.assertTrue(breakpoint.GetHitCount() == 3)

            process.Continue()

    SBBreakpoint supports breakpoint location iteration, for example,::

        for bl in breakpoint:
            print('breakpoint location load addr: %s' % hex(bl.GetLoadAddress()))
            print('breakpoint location condition: %s' % hex(bl.GetCondition()))

    and rich comparison methods which allow the API program to use,::

        if aBreakpoint == bBreakpoint:
            ...

    to compare two breakpoints for equality.
    """
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBBreakpoint self) -> SBBreakpoint
        __init__(SBBreakpoint self, SBBreakpoint rhs) -> SBBreakpoint
        """
        ...
    
    __swig_destroy__ = ...
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBBreakpoint self, SBBreakpoint rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBBreakpoint self, SBBreakpoint rhs) -> bool"""
        ...
    
    def GetID(self):
        r"""GetID(SBBreakpoint self) -> lldb::break_id_t"""
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self) -> bool:
        r"""IsValid(SBBreakpoint self) -> bool"""
        ...
    
    def ClearAllBreakpointSites(self):
        r"""ClearAllBreakpointSites(SBBreakpoint self)"""
        ...
    
    def GetTarget(self) -> SBTarget:
        r"""GetTarget(SBBreakpoint self) -> SBTarget"""
        ...
    
    def FindLocationByAddress(self, vm_addr: int) -> SBBreakpointLocation:
        r"""FindLocationByAddress(SBBreakpoint self, lldb::addr_t vm_addr) -> SBBreakpointLocation"""
        ...
    
    def FindLocationIDByAddress(self, vm_addr: int):
        r"""FindLocationIDByAddress(SBBreakpoint self, lldb::addr_t vm_addr) -> lldb::break_id_t"""
        ...
    
    def FindLocationByID(self, bp_loc_id) -> SBBreakpointLocation:
        r"""FindLocationByID(SBBreakpoint self, lldb::break_id_t bp_loc_id) -> SBBreakpointLocation"""
        ...
    
    def GetLocationAtIndex(self, index: int) -> SBBreakpointLocation:
        r"""GetLocationAtIndex(SBBreakpoint self, uint32_t index) -> SBBreakpointLocation"""
        ...
    
    def SetEnabled(self, enable: bool):
        r"""SetEnabled(SBBreakpoint self, bool enable)"""
        ...
    
    def IsEnabled(self) -> bool:
        r"""IsEnabled(SBBreakpoint self) -> bool"""
        ...
    
    def SetOneShot(self, one_shot: bool):
        r"""SetOneShot(SBBreakpoint self, bool one_shot)"""
        ...
    
    def IsOneShot(self) -> bool:
        r"""IsOneShot(SBBreakpoint self) -> bool"""
        ...
    
    def IsInternal(self) -> bool:
        r"""IsInternal(SBBreakpoint self) -> bool"""
        ...
    
    def GetHitCount(self) -> int:
        r"""GetHitCount(SBBreakpoint self) -> uint32_t"""
        ...
    
    def SetIgnoreCount(self, count: int):
        r"""SetIgnoreCount(SBBreakpoint self, uint32_t count)"""
        ...
    
    def GetIgnoreCount(self) -> int:
        r"""GetIgnoreCount(SBBreakpoint self) -> uint32_t"""
        ...
    
    def SetCondition(self, condition: str):
        r"""
        SetCondition(SBBreakpoint self, char const * condition)

            The breakpoint stops only if the condition expression evaluates to true.
        """
        ...
    
    def GetCondition(self) -> str:
        r"""
        GetCondition(SBBreakpoint self) -> char const *

            Get the condition expression for the breakpoint.
        """
        ...
    
    def SetAutoContinue(self, auto_continue: bool):
        r"""SetAutoContinue(SBBreakpoint self, bool auto_continue)"""
        ...
    
    def GetAutoContinue(self) -> bool:
        r"""GetAutoContinue(SBBreakpoint self) -> bool"""
        ...
    
    def SetThreadID(self, sb_thread_id):
        r"""SetThreadID(SBBreakpoint self, lldb::tid_t sb_thread_id)"""
        ...
    
    def GetThreadID(self):
        r"""GetThreadID(SBBreakpoint self) -> lldb::tid_t"""
        ...
    
    def SetThreadIndex(self, index: int):
        r"""SetThreadIndex(SBBreakpoint self, uint32_t index)"""
        ...
    
    def GetThreadIndex(self) -> int:
        r"""GetThreadIndex(SBBreakpoint self) -> uint32_t"""
        ...
    
    def SetThreadName(self, thread_name: str):
        r"""SetThreadName(SBBreakpoint self, char const * thread_name)"""
        ...
    
    def GetThreadName(self) -> str:
        r"""GetThreadName(SBBreakpoint self) -> char const *"""
        ...
    
    def SetQueueName(self, queue_name: str):
        r"""SetQueueName(SBBreakpoint self, char const * queue_name)"""
        ...
    
    def GetQueueName(self) -> str:
        r"""GetQueueName(SBBreakpoint self) -> char const *"""
        ...

    def SetScriptCallbackFunction(self, *args):
        r"""
        SetScriptCallbackFunction(SBBreakpoint self, char const * callback_function_name)
        SetScriptCallbackFunction(SBBreakpoint self, char const * callback_function_name, SBStructuredData extra_args) -> SBError

            Set the name of the script function to be called when the breakpoint is hit.
            To use this variant, the function should take (frame, bp_loc, extra_args, internal_dict) and
            when the breakpoint is hit the extra_args will be passed to the callback function.
        """
        ...
    
    def SetCommandLineCommands(self, commands: SBStringList):
        r"""SetCommandLineCommands(SBBreakpoint self, SBStringList commands)"""
        ...
    
    def GetCommandLineCommands(self, commands: SBStringList) -> bool:
        r"""GetCommandLineCommands(SBBreakpoint self, SBStringList commands) -> bool"""
        ...
    
    def SetScriptCallbackBody(self, script_body_text: str) -> SBError:
        r"""
        SetScriptCallbackBody(SBBreakpoint self, char const * script_body_text) -> SBError

            Provide the body for the script function to be called when the breakpoint is hit.
            The body will be wrapped in a function, which be passed two arguments:
            'frame' - which holds the bottom-most SBFrame of the thread that hit the breakpoint
            'bpno'  - which is the SBBreakpointLocation to which the callback was attached.

            The error parameter is currently ignored, but will at some point hold the Python
            compilation diagnostics.
            Returns true if the body compiles successfully, false if not.
        """
        ...
    
    def AddName(self, new_name: str) -> bool:
        r"""AddName(SBBreakpoint self, char const * new_name) -> bool"""
        ...
    
    def AddNameWithErrorHandling(self, new_name: str) -> SBError:
        r"""AddNameWithErrorHandling(SBBreakpoint self, char const * new_name) -> SBError"""
        ...
    
    def RemoveName(self, name_to_remove: str):
        r"""RemoveName(SBBreakpoint self, char const * name_to_remove)"""
        ...
    
    def MatchesName(self, name: str) -> bool:
        r"""MatchesName(SBBreakpoint self, char const * name) -> bool"""
        ...
    
    def GetNames(self, names: SBStringList):
        r"""GetNames(SBBreakpoint self, SBStringList names)"""
        ...
    
    def GetNumResolvedLocations(self) -> int:
        r"""GetNumResolvedLocations(SBBreakpoint self) -> size_t"""
        ...
    
    def GetNumLocations(self) -> int:
        r"""GetNumLocations(SBBreakpoint self) -> size_t"""
        ...
    
    def GetDescription(self, *args) -> bool:
        r"""
        GetDescription(SBBreakpoint self, SBStream description) -> bool
        GetDescription(SBBreakpoint self, SBStream description, bool include_locations) -> bool
        """
        ...
    
    @staticmethod
    def EventIsBreakpointEvent(event: SBEvent) -> bool:
        r"""EventIsBreakpointEvent(SBEvent event) -> bool"""
        ...
    
    @staticmethod
    def GetBreakpointEventTypeFromEvent(event: SBEvent):
        r"""GetBreakpointEventTypeFromEvent(SBEvent event) -> lldb::BreakpointEventType"""
        ...
    
    @staticmethod
    def GetBreakpointFromEvent(event: SBEvent) -> SBBreakpoint:
        r"""GetBreakpointFromEvent(SBEvent event) -> SBBreakpoint"""
        ...
    
    @staticmethod
    def GetBreakpointLocationAtIndexFromEvent(event: SBEvent, loc_idx: int) -> SBBreakpointLocation:
        r"""GetBreakpointLocationAtIndexFromEvent(SBEvent event, uint32_t loc_idx) -> SBBreakpointLocation"""
        ...
    
    @staticmethod
    def GetNumBreakpointLocationsFromEvent(event_sp: SBEvent) -> int:
        r"""GetNumBreakpointLocationsFromEvent(SBEvent event_sp) -> uint32_t"""
        ...
    
    def IsHardware(self) -> bool:
        r"""IsHardware(SBBreakpoint self) -> bool"""
        ...
    
    def AddLocation(self, address: SBAddress) -> SBError:
        r"""AddLocation(SBBreakpoint self, SBAddress address) -> SBError"""
        ...
    
    def SerializeToStructuredData(self) -> SBStructuredData:
        r"""SerializeToStructuredData(SBBreakpoint self) -> SBStructuredData"""
        ...
    
    def __repr__(self) -> str:
        r"""__repr__(SBBreakpoint self) -> std::string"""
        ...
    
    class locations_access:
        '''A helper object that will lazily hand out locations for a breakpoint when supplied an index.'''
        def __init__(self, sbbreakpoint) -> None:
            ...
        
        def __len__(self): # -> int:
            ...
        
        def __getitem__(self, key): # -> None:
            ...
        
    
    
    def get_locations_access_object(self): # -> locations_access:
        '''An accessor function that returns a locations_access() object which allows lazy location access from a lldb.SBBreakpoint object.'''
        ...
    
    def get_breakpoint_location_list(self): # -> list[Any]:
        '''An accessor function that returns a list() that contains all locations in a lldb.SBBreakpoint object.'''
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        '''Iterate over all breakpoint locations in a lldb.SBBreakpoint
        object.'''
        ...
    
    def __len__(self):
        '''Return the number of breakpoint locations in a lldb.SBBreakpoint
        object.'''
        ...
    
    locations = ...
    location = ...
    id = ...
    enabled: bool = ...
    one_shot: bool = ...
    num_locations: int = ...
    def __eq__(self, rhs) -> bool:
        ...
    
    def __ne__(self, rhs) -> bool:
        ...
    


class SBBreakpointList:
    r"""Represents a list of :py:class:`SBBreakpoint`."""
    thisown = ...
    __repr__ = ...
    def __init__(self, target) -> None:
        r"""__init__(SBBreakpointList self, SBTarget target) -> SBBreakpointList"""
        ...
    
    __swig_destroy__ = ...
    def GetSize(self):
        r"""GetSize(SBBreakpointList self) -> size_t"""
        ...
    
    def GetBreakpointAtIndex(self, idx):
        r"""GetBreakpointAtIndex(SBBreakpointList self, size_t idx) -> SBBreakpoint"""
        ...
    
    def FindBreakpointByID(self, arg2):
        r"""FindBreakpointByID(SBBreakpointList self, lldb::break_id_t arg2) -> SBBreakpoint"""
        ...
    
    def Append(self, sb_bkpt):
        r"""Append(SBBreakpointList self, SBBreakpoint sb_bkpt)"""
        ...
    
    def AppendIfUnique(self, sb_bkpt):
        r"""AppendIfUnique(SBBreakpointList self, SBBreakpoint sb_bkpt) -> bool"""
        ...
    
    def AppendByID(self, id):
        r"""AppendByID(SBBreakpointList self, lldb::break_id_t id)"""
        ...
    
    def Clear(self):
        r"""Clear(SBBreakpointList self)"""
        ...
    


class SBBreakpointLocation:
    r"""
    Represents one unique instance (by address) of a logical breakpoint.

    A breakpoint location is defined by the breakpoint that produces it,
    and the address that resulted in this particular instantiation.
    Each breakpoint location has its settable options.

    :py:class:`SBBreakpoint` contains SBBreakpointLocation(s). See docstring of SBBreakpoint
    for retrieval of an SBBreakpointLocation from an SBBreakpoint.
    """
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBBreakpointLocation self) -> SBBreakpointLocation
        __init__(SBBreakpointLocation self, SBBreakpointLocation rhs) -> SBBreakpointLocation
        """
        ...
    
    __swig_destroy__ = ...
    def GetID(self):
        r"""GetID(SBBreakpointLocation self) -> lldb::break_id_t"""
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBBreakpointLocation self) -> bool"""
        ...
    
    def GetAddress(self):
        r"""GetAddress(SBBreakpointLocation self) -> SBAddress"""
        ...
    
    def GetLoadAddress(self):
        r"""GetLoadAddress(SBBreakpointLocation self) -> lldb::addr_t"""
        ...
    
    def SetEnabled(self, enabled):
        r"""SetEnabled(SBBreakpointLocation self, bool enabled)"""
        ...
    
    def IsEnabled(self):
        r"""IsEnabled(SBBreakpointLocation self) -> bool"""
        ...
    
    def GetHitCount(self):
        r"""GetHitCount(SBBreakpointLocation self) -> uint32_t"""
        ...
    
    def GetIgnoreCount(self):
        r"""GetIgnoreCount(SBBreakpointLocation self) -> uint32_t"""
        ...
    
    def SetIgnoreCount(self, n):
        r"""SetIgnoreCount(SBBreakpointLocation self, uint32_t n)"""
        ...
    
    def SetCondition(self, condition):
        r"""
        SetCondition(SBBreakpointLocation self, char const * condition)

            The breakpoint location stops only if the condition expression evaluates
            to true.
        """
        ...
    
    def GetCondition(self):
        r"""
        GetCondition(SBBreakpointLocation self) -> char const *

            Get the condition expression for the breakpoint location.
        """
        ...
    
    def SetAutoContinue(self, auto_continue):
        r"""SetAutoContinue(SBBreakpointLocation self, bool auto_continue)"""
        ...
    
    def GetAutoContinue(self):
        r"""GetAutoContinue(SBBreakpointLocation self) -> bool"""
        ...
    
    def SetScriptCallbackFunction(self, *args):
        r"""
        SetScriptCallbackFunction(SBBreakpointLocation self, char const * callback_function_name)
        SetScriptCallbackFunction(SBBreakpointLocation self, char const * callback_function_name, SBStructuredData extra_args) -> SBError

            Set the name of the script function to be called when the breakpoint is hit.
            To use this variant, the function should take (frame, bp_loc, extra_args, internal_dict) and
            when the breakpoint is hit the extra_args will be passed to the callback function.
        """
        ...
    
    def SetScriptCallbackBody(self, script_body_text):
        r"""
        SetScriptCallbackBody(SBBreakpointLocation self, char const * script_body_text) -> SBError

            Provide the body for the script function to be called when the breakpoint location is hit.
            The body will be wrapped in a function, which be passed two arguments:
            'frame' - which holds the bottom-most SBFrame of the thread that hit the breakpoint
            'bpno'  - which is the SBBreakpointLocation to which the callback was attached.

            The error parameter is currently ignored, but will at some point hold the Python
            compilation diagnostics.
            Returns true if the body compiles successfully, false if not.
        """
        ...
    
    def SetCommandLineCommands(self, commands):
        r"""SetCommandLineCommands(SBBreakpointLocation self, SBStringList commands)"""
        ...
    
    def GetCommandLineCommands(self, commands):
        r"""GetCommandLineCommands(SBBreakpointLocation self, SBStringList commands) -> bool"""
        ...
    
    def SetThreadID(self, sb_thread_id):
        r"""SetThreadID(SBBreakpointLocation self, lldb::tid_t sb_thread_id)"""
        ...
    
    def GetThreadID(self):
        r"""GetThreadID(SBBreakpointLocation self) -> lldb::tid_t"""
        ...
    
    def SetThreadIndex(self, index):
        r"""SetThreadIndex(SBBreakpointLocation self, uint32_t index)"""
        ...
    
    def GetThreadIndex(self):
        r"""GetThreadIndex(SBBreakpointLocation self) -> uint32_t"""
        ...
    
    def SetThreadName(self, thread_name):
        r"""SetThreadName(SBBreakpointLocation self, char const * thread_name)"""
        ...
    
    def GetThreadName(self):
        r"""GetThreadName(SBBreakpointLocation self) -> char const *"""
        ...
    
    def SetQueueName(self, queue_name):
        r"""SetQueueName(SBBreakpointLocation self, char const * queue_name)"""
        ...
    
    def GetQueueName(self):
        r"""GetQueueName(SBBreakpointLocation self) -> char const *"""
        ...
    
    def IsResolved(self):
        r"""IsResolved(SBBreakpointLocation self) -> bool"""
        ...
    
    def GetDescription(self, description, level):
        r"""GetDescription(SBBreakpointLocation self, SBStream description, lldb::DescriptionLevel level) -> bool"""
        ...
    
    def GetBreakpoint(self):
        r"""GetBreakpoint(SBBreakpointLocation self) -> SBBreakpoint"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBBreakpointLocation self) -> std::string"""
        ...
    


class SBBreakpointName:
    r"""
    Represents a breakpoint name registered in a given :py:class:`SBTarget`.

    Breakpoint names provide a way to act on groups of breakpoints.  When you add a
    name to a group of breakpoints, you can then use the name in all the command
    line lldb commands for that name.  You can also configure the SBBreakpointName
    options and those options will be propagated to any :py:class:`SBBreakpoint` s currently
    using that name.  Adding a name to a breakpoint will also apply any of the
    set options to that breakpoint.

    You can also set permissions on a breakpoint name to disable listing, deleting
    and disabling breakpoints.  That will disallow the given operation for breakpoints
    except when the breakpoint is mentioned by ID.  So for instance deleting all the
    breakpoints won't delete breakpoints so marked.
    """
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBBreakpointName self) -> SBBreakpointName
        __init__(SBBreakpointName self, SBTarget target, char const * name) -> SBBreakpointName
        __init__(SBBreakpointName self, SBBreakpoint bkpt, char const * name) -> SBBreakpointName
        __init__(SBBreakpointName self, SBBreakpointName rhs) -> SBBreakpointName
        """
        ...
    
    __swig_destroy__ = ...
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBBreakpointName self, SBBreakpointName rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBBreakpointName self, SBBreakpointName rhs) -> bool"""
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBBreakpointName self) -> bool"""
        ...
    
    def GetName(self):
        r"""GetName(SBBreakpointName self) -> char const *"""
        ...
    
    def SetEnabled(self, enable):
        r"""SetEnabled(SBBreakpointName self, bool enable)"""
        ...
    
    def IsEnabled(self):
        r"""IsEnabled(SBBreakpointName self) -> bool"""
        ...
    
    def SetOneShot(self, one_shot):
        r"""SetOneShot(SBBreakpointName self, bool one_shot)"""
        ...
    
    def IsOneShot(self):
        r"""IsOneShot(SBBreakpointName self) -> bool"""
        ...
    
    def SetIgnoreCount(self, count):
        r"""SetIgnoreCount(SBBreakpointName self, uint32_t count)"""
        ...
    
    def GetIgnoreCount(self):
        r"""GetIgnoreCount(SBBreakpointName self) -> uint32_t"""
        ...
    
    def SetCondition(self, condition):
        r"""SetCondition(SBBreakpointName self, char const * condition)"""
        ...
    
    def GetCondition(self):
        r"""GetCondition(SBBreakpointName self) -> char const *"""
        ...
    
    def SetAutoContinue(self, auto_continue):
        r"""SetAutoContinue(SBBreakpointName self, bool auto_continue)"""
        ...
    
    def GetAutoContinue(self):
        r"""GetAutoContinue(SBBreakpointName self) -> bool"""
        ...
    
    def SetThreadID(self, sb_thread_id):
        r"""SetThreadID(SBBreakpointName self, lldb::tid_t sb_thread_id)"""
        ...
    
    def GetThreadID(self):
        r"""GetThreadID(SBBreakpointName self) -> lldb::tid_t"""
        ...
    
    def SetThreadIndex(self, index):
        r"""SetThreadIndex(SBBreakpointName self, uint32_t index)"""
        ...
    
    def GetThreadIndex(self):
        r"""GetThreadIndex(SBBreakpointName self) -> uint32_t"""
        ...
    
    def SetThreadName(self, thread_name):
        r"""SetThreadName(SBBreakpointName self, char const * thread_name)"""
        ...
    
    def GetThreadName(self):
        r"""GetThreadName(SBBreakpointName self) -> char const *"""
        ...
    
    def SetQueueName(self, queue_name):
        r"""SetQueueName(SBBreakpointName self, char const * queue_name)"""
        ...
    
    def GetQueueName(self):
        r"""GetQueueName(SBBreakpointName self) -> char const *"""
        ...
    
    def SetScriptCallbackFunction(self, *args):
        r"""
        SetScriptCallbackFunction(SBBreakpointName self, char const * callback_function_name)
        SetScriptCallbackFunction(SBBreakpointName self, char const * callback_function_name, SBStructuredData extra_args) -> SBError
        """
        ...
    
    def SetCommandLineCommands(self, commands):
        r"""SetCommandLineCommands(SBBreakpointName self, SBStringList commands)"""
        ...
    
    def GetCommandLineCommands(self, commands):
        r"""GetCommandLineCommands(SBBreakpointName self, SBStringList commands) -> bool"""
        ...
    
    def SetScriptCallbackBody(self, script_body_text):
        r"""SetScriptCallbackBody(SBBreakpointName self, char const * script_body_text) -> SBError"""
        ...
    
    def GetHelpString(self):
        r"""GetHelpString(SBBreakpointName self) -> char const *"""
        ...
    
    def SetHelpString(self, help_string):
        r"""SetHelpString(SBBreakpointName self, char const * help_string)"""
        ...
    
    def GetAllowList(self):
        r"""GetAllowList(SBBreakpointName self) -> bool"""
        ...
    
    def SetAllowList(self, value):
        r"""SetAllowList(SBBreakpointName self, bool value)"""
        ...
    
    def GetAllowDelete(self):
        r"""GetAllowDelete(SBBreakpointName self) -> bool"""
        ...
    
    def SetAllowDelete(self, value):
        r"""SetAllowDelete(SBBreakpointName self, bool value)"""
        ...
    
    def GetAllowDisable(self):
        r"""GetAllowDisable(SBBreakpointName self) -> bool"""
        ...
    
    def SetAllowDisable(self, value):
        r"""SetAllowDisable(SBBreakpointName self, bool value)"""
        ...
    
    def GetDescription(self, description):
        r"""GetDescription(SBBreakpointName self, SBStream description) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBBreakpointName self) -> std::string"""
        ...
    


class SBBroadcaster:
    r"""
    Represents an entity which can broadcast events.

    A default broadcaster is
    associated with an SBCommandInterpreter, SBProcess, and SBTarget.  For
    example, use ::

        broadcaster = process.GetBroadcaster()

    to retrieve the process's broadcaster.

    See also SBEvent for example usage of interacting with a broadcaster.
    """
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBBroadcaster self) -> SBBroadcaster
        __init__(SBBroadcaster self, char const * name) -> SBBroadcaster
        __init__(SBBroadcaster self, SBBroadcaster rhs) -> SBBroadcaster
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBBroadcaster self) -> bool"""
        ...
    
    def Clear(self):
        r"""Clear(SBBroadcaster self)"""
        ...
    
    def BroadcastEventByType(self, event_type, unique=...):
        r"""BroadcastEventByType(SBBroadcaster self, uint32_t event_type, bool unique=False)"""
        ...
    
    def BroadcastEvent(self, event, unique=...):
        r"""BroadcastEvent(SBBroadcaster self, SBEvent event, bool unique=False)"""
        ...
    
    def AddInitialEventsToListener(self, listener, requested_events):
        r"""AddInitialEventsToListener(SBBroadcaster self, SBListener listener, uint32_t requested_events)"""
        ...
    
    def AddListener(self, listener, event_mask):
        r"""AddListener(SBBroadcaster self, SBListener listener, uint32_t event_mask) -> uint32_t"""
        ...
    
    def GetName(self):
        r"""GetName(SBBroadcaster self) -> char const *"""
        ...
    
    def EventTypeHasListeners(self, event_type):
        r"""EventTypeHasListeners(SBBroadcaster self, uint32_t event_type) -> bool"""
        ...
    
    def RemoveListener(self, *args):
        r"""RemoveListener(SBBroadcaster self, SBListener listener, uint32_t event_mask=4294967295U) -> bool"""
        ...
    
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBBroadcaster self, SBBroadcaster rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBBroadcaster self, SBBroadcaster rhs) -> bool"""
        ...
    
    def __lt__(self, rhs) -> bool:
        r"""__lt__(SBBroadcaster self, SBBroadcaster rhs) -> bool"""
        ...
    
    def __eq__(self, rhs) -> bool:
        ...
    
    def __ne__(self, rhs) -> bool:
        ...
    


class SBCommandInterpreter:
    r"""
    SBCommandInterpreter handles/interprets commands for lldb.

    You get the command interpreter from the :py:class:`SBDebugger` instance.

    For example (from test/ python_api/interpreter/TestCommandInterpreterAPI.py),::

        def command_interpreter_api(self):
            '''Test the SBCommandInterpreter APIs.'''
            exe = os.path.join(os.getcwd(), 'a.out')

            # Create a target by the debugger.
            target = self.dbg.CreateTarget(exe)
            self.assertTrue(target, VALID_TARGET)

            # Retrieve the associated command interpreter from our debugger.
            ci = self.dbg.GetCommandInterpreter()
            self.assertTrue(ci, VALID_COMMAND_INTERPRETER)

            # Exercise some APIs....

            self.assertTrue(ci.HasCommands())
            self.assertTrue(ci.HasAliases())
            self.assertTrue(ci.HasAliasOptions())
            self.assertTrue(ci.CommandExists('breakpoint'))
            self.assertTrue(ci.CommandExists('target'))
            self.assertTrue(ci.CommandExists('platform'))
            self.assertTrue(ci.AliasExists('file'))
            self.assertTrue(ci.AliasExists('run'))
            self.assertTrue(ci.AliasExists('bt'))

            res = lldb.SBCommandReturnObject()
            ci.HandleCommand('breakpoint set -f main.c -l %d' % self.line, res)
            self.assertTrue(res.Succeeded())
            ci.HandleCommand('process launch', res)
            self.assertTrue(res.Succeeded())

            process = ci.GetProcess()
            self.assertTrue(process)

            ...

    The HandleCommand() instance method takes two args: the command string and
    an SBCommandReturnObject instance which encapsulates the result of command
    execution.
    """
    thisown = ...
    __repr__ = ...
    eBroadcastBitThreadShouldExit = ...
    eBroadcastBitResetPrompt = ...
    eBroadcastBitQuitCommandReceived = ...
    eBroadcastBitAsynchronousOutputData = ...
    eBroadcastBitAsynchronousErrorData = ...
    def __init__(self, rhs) -> None:
        r"""__init__(SBCommandInterpreter self, SBCommandInterpreter rhs) -> SBCommandInterpreter"""
        ...
    
    __swig_destroy__ = ...
    @staticmethod
    def GetArgumentTypeAsCString(arg_type):
        r"""GetArgumentTypeAsCString(lldb::CommandArgumentType const arg_type) -> char const *"""
        ...
    
    @staticmethod
    def GetArgumentDescriptionAsCString(arg_type):
        r"""GetArgumentDescriptionAsCString(lldb::CommandArgumentType const arg_type) -> char const *"""
        ...
    
    @staticmethod
    def EventIsCommandInterpreterEvent(event):
        r"""EventIsCommandInterpreterEvent(SBEvent event) -> bool"""
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBCommandInterpreter self) -> bool"""
        ...
    
    def CommandExists(self, cmd):
        r"""CommandExists(SBCommandInterpreter self, char const * cmd) -> bool"""
        ...
    
    def UserCommandExists(self, cmd):
        r"""UserCommandExists(SBCommandInterpreter self, char const * cmd) -> bool"""
        ...
    
    def AliasExists(self, cmd):
        r"""AliasExists(SBCommandInterpreter self, char const * cmd) -> bool"""
        ...
    
    def GetBroadcaster(self):
        r"""GetBroadcaster(SBCommandInterpreter self) -> SBBroadcaster"""
        ...
    
    @staticmethod
    def GetBroadcasterClass():
        r"""GetBroadcasterClass() -> char const *"""
        ...
    
    def HasCommands(self):
        r"""HasCommands(SBCommandInterpreter self) -> bool"""
        ...
    
    def HasAliases(self):
        r"""HasAliases(SBCommandInterpreter self) -> bool"""
        ...
    
    def HasAliasOptions(self):
        r"""HasAliasOptions(SBCommandInterpreter self) -> bool"""
        ...
    
    def IsInteractive(self):
        r"""IsInteractive(SBCommandInterpreter self) -> bool"""
        ...
    
    def GetProcess(self):
        r"""GetProcess(SBCommandInterpreter self) -> SBProcess"""
        ...
    
    def GetDebugger(self):
        r"""GetDebugger(SBCommandInterpreter self) -> SBDebugger"""
        ...
    
    def SourceInitFileInHomeDirectory(self, *args):
        r"""
        SourceInitFileInHomeDirectory(SBCommandInterpreter self, SBCommandReturnObject result)
        SourceInitFileInHomeDirectory(SBCommandInterpreter self, SBCommandReturnObject result, bool is_repl)
        """
        ...
    
    def SourceInitFileInCurrentWorkingDirectory(self, result):
        r"""SourceInitFileInCurrentWorkingDirectory(SBCommandInterpreter self, SBCommandReturnObject result)"""
        ...
    
    def HandleCommand(self, *args):
        r"""
        HandleCommand(SBCommandInterpreter self, char const * command_line, SBCommandReturnObject result, bool add_to_history=False) -> lldb::ReturnStatus
        HandleCommand(SBCommandInterpreter self, char const * command_line, SBExecutionContext exe_ctx, SBCommandReturnObject result, bool add_to_history=False) -> lldb::ReturnStatus
        """
        ...
    
    def HandleCommandsFromFile(self, file, override_context, options, result):
        r"""HandleCommandsFromFile(SBCommandInterpreter self, SBFileSpec file, SBExecutionContext override_context, SBCommandInterpreterRunOptions options, SBCommandReturnObject result)"""
        ...
    
    def HandleCompletion(self, current_line, cursor_pos, match_start_point, max_return_elements, matches):
        r"""HandleCompletion(SBCommandInterpreter self, char const * current_line, uint32_t cursor_pos, int match_start_point, int max_return_elements, SBStringList matches) -> int"""
        ...
    
    def HandleCompletionWithDescriptions(self, current_line, cursor_pos, match_start_point, max_return_elements, matches, descriptions):
        r"""HandleCompletionWithDescriptions(SBCommandInterpreter self, char const * current_line, uint32_t cursor_pos, int match_start_point, int max_return_elements, SBStringList matches, SBStringList descriptions) -> int"""
        ...
    
    def WasInterrupted(self):
        r"""WasInterrupted(SBCommandInterpreter self) -> bool"""
        ...
    
    def InterruptCommand(self):
        r"""InterruptCommand(SBCommandInterpreter self) -> bool"""
        ...
    
    def IsActive(self):
        r"""IsActive(SBCommandInterpreter self) -> bool"""
        ...
    
    def GetIOHandlerControlSequence(self, ch):
        r"""GetIOHandlerControlSequence(SBCommandInterpreter self, char ch) -> char const *"""
        ...
    
    def GetPromptOnQuit(self):
        r"""GetPromptOnQuit(SBCommandInterpreter self) -> bool"""
        ...
    
    def SetPromptOnQuit(self, b):
        r"""SetPromptOnQuit(SBCommandInterpreter self, bool b)"""
        ...
    
    def AllowExitCodeOnQuit(self, allow):
        r"""AllowExitCodeOnQuit(SBCommandInterpreter self, bool allow)"""
        ...
    
    def HasCustomQuitExitCode(self):
        r"""HasCustomQuitExitCode(SBCommandInterpreter self) -> bool"""
        ...
    
    def GetQuitStatus(self):
        r"""GetQuitStatus(SBCommandInterpreter self) -> int"""
        ...
    
    def ResolveCommand(self, command_line, result):
        r"""ResolveCommand(SBCommandInterpreter self, char const * command_line, SBCommandReturnObject result)"""
        ...
    


class SBCommandInterpreterRunOptions:
    r"""
    SBCommandInterpreterRunOptions controls how the RunCommandInterpreter runs the code it is fed.

    A default SBCommandInterpreterRunOptions object has:

    * StopOnContinue: false
    * StopOnError:    false
    * StopOnCrash:    false
    * EchoCommands:   true
    * PrintResults:   true
    * PrintErrors:    true
    * AddToHistory:   true


    """
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBCommandInterpreterRunOptions self) -> SBCommandInterpreterRunOptions
        __init__(SBCommandInterpreterRunOptions self, SBCommandInterpreterRunOptions rhs) -> SBCommandInterpreterRunOptions
        """
        ...
    
    __swig_destroy__ = ...
    def GetStopOnContinue(self):
        r"""GetStopOnContinue(SBCommandInterpreterRunOptions self) -> bool"""
        ...
    
    def SetStopOnContinue(self, arg2):
        r"""SetStopOnContinue(SBCommandInterpreterRunOptions self, bool arg2)"""
        ...
    
    def GetStopOnError(self):
        r"""GetStopOnError(SBCommandInterpreterRunOptions self) -> bool"""
        ...
    
    def SetStopOnError(self, arg2):
        r"""SetStopOnError(SBCommandInterpreterRunOptions self, bool arg2)"""
        ...
    
    def GetStopOnCrash(self):
        r"""GetStopOnCrash(SBCommandInterpreterRunOptions self) -> bool"""
        ...
    
    def SetStopOnCrash(self, arg2):
        r"""SetStopOnCrash(SBCommandInterpreterRunOptions self, bool arg2)"""
        ...
    
    def GetEchoCommands(self):
        r"""GetEchoCommands(SBCommandInterpreterRunOptions self) -> bool"""
        ...
    
    def SetEchoCommands(self, arg2):
        r"""SetEchoCommands(SBCommandInterpreterRunOptions self, bool arg2)"""
        ...
    
    def GetEchoCommentCommands(self):
        r"""GetEchoCommentCommands(SBCommandInterpreterRunOptions self) -> bool"""
        ...
    
    def SetEchoCommentCommands(self, echo):
        r"""SetEchoCommentCommands(SBCommandInterpreterRunOptions self, bool echo)"""
        ...
    
    def GetPrintResults(self):
        r"""GetPrintResults(SBCommandInterpreterRunOptions self) -> bool"""
        ...
    
    def SetPrintResults(self, arg2):
        r"""SetPrintResults(SBCommandInterpreterRunOptions self, bool arg2)"""
        ...
    
    def GetPrintErrors(self):
        r"""GetPrintErrors(SBCommandInterpreterRunOptions self) -> bool"""
        ...
    
    def SetPrintErrors(self, arg2):
        r"""SetPrintErrors(SBCommandInterpreterRunOptions self, bool arg2)"""
        ...
    
    def GetAddToHistory(self):
        r"""GetAddToHistory(SBCommandInterpreterRunOptions self) -> bool"""
        ...
    
    def SetAddToHistory(self, arg2):
        r"""SetAddToHistory(SBCommandInterpreterRunOptions self, bool arg2)"""
        ...
    
    def GetAutoHandleEvents(self):
        r"""GetAutoHandleEvents(SBCommandInterpreterRunOptions self) -> bool"""
        ...
    
    def SetAutoHandleEvents(self, arg2):
        r"""SetAutoHandleEvents(SBCommandInterpreterRunOptions self, bool arg2)"""
        ...
    
    def GetSpawnThread(self):
        r"""GetSpawnThread(SBCommandInterpreterRunOptions self) -> bool"""
        ...
    
    def SetSpawnThread(self, arg2):
        r"""SetSpawnThread(SBCommandInterpreterRunOptions self, bool arg2)"""
        ...
    


class SBCommandReturnObject:
    r"""
    Represents a container which holds the result from command execution.
    It works with :py:class:`SBCommandInterpreter.HandleCommand()` to encapsulate the result
    of command execution.

    See :py:class:`SBCommandInterpreter` for example usage of SBCommandReturnObject.
    """
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBCommandReturnObject self) -> SBCommandReturnObject
        __init__(SBCommandReturnObject self, SBCommandReturnObject rhs) -> SBCommandReturnObject
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBCommandReturnObject self) -> bool"""
        ...
    
    def PutOutput(self, *args):
        r"""
        PutOutput(SBCommandReturnObject self, SBFile file) -> size_t
        PutOutput(SBCommandReturnObject self, lldb::FileSP BORROWED) -> size_t
        """
        ...
    
    def GetOutputSize(self):
        r"""GetOutputSize(SBCommandReturnObject self) -> size_t"""
        ...
    
    def GetErrorSize(self):
        r"""GetErrorSize(SBCommandReturnObject self) -> size_t"""
        ...
    
    def PutError(self, *args):
        r"""
        PutError(SBCommandReturnObject self, SBFile file) -> size_t
        PutError(SBCommandReturnObject self, lldb::FileSP BORROWED) -> size_t
        """
        ...
    
    def Clear(self):
        r"""Clear(SBCommandReturnObject self)"""
        ...
    
    def GetStatus(self):
        r"""GetStatus(SBCommandReturnObject self) -> lldb::ReturnStatus"""
        ...
    
    def SetStatus(self, status):
        r"""SetStatus(SBCommandReturnObject self, lldb::ReturnStatus status)"""
        ...
    
    def Succeeded(self):
        r"""Succeeded(SBCommandReturnObject self) -> bool"""
        ...
    
    def HasResult(self):
        r"""HasResult(SBCommandReturnObject self) -> bool"""
        ...
    
    def AppendMessage(self, message):
        r"""AppendMessage(SBCommandReturnObject self, char const * message)"""
        ...
    
    def AppendWarning(self, message):
        r"""AppendWarning(SBCommandReturnObject self, char const * message)"""
        ...
    
    def GetDescription(self, description):
        r"""GetDescription(SBCommandReturnObject self, SBStream description) -> bool"""
        ...
    
    def PutCString(self, string):
        r"""PutCString(SBCommandReturnObject self, char const * string)"""
        ...
    
    def GetOutput(self, *args):
        r"""
        GetOutput(SBCommandReturnObject self) -> char const
        GetOutput(SBCommandReturnObject self, bool only_if_no_immediate) -> char const *
        """
        ...
    
    def GetError(self, *args):
        r"""
        GetError(SBCommandReturnObject self) -> char const
        GetError(SBCommandReturnObject self, bool only_if_no_immediate) -> char const *
        """
        ...
    
    def SetError(self, *args):
        r"""
        SetError(SBCommandReturnObject self, SBError error, char const * fallback_error_cstr=None)
        SetError(SBCommandReturnObject self, char const * error_cstr)
        """
        ...
    
    def __repr__(self):
        r"""__repr__(SBCommandReturnObject self) -> std::string"""
        ...
    
    def SetImmediateOutputFile(self, *args):
        r"""
        SetImmediateOutputFile(SBCommandReturnObject self, SBFile file)
        SetImmediateOutputFile(SBCommandReturnObject self, lldb::FileSP BORROWED)
        SetImmediateOutputFile(SBCommandReturnObject self, lldb::FileSP BORROWED, bool transfer_ownership)
        """
        ...
    
    def SetImmediateErrorFile(self, *args):
        r"""
        SetImmediateErrorFile(SBCommandReturnObject self, SBFile file)
        SetImmediateErrorFile(SBCommandReturnObject self, lldb::FileSP BORROWED)
        SetImmediateErrorFile(SBCommandReturnObject self, lldb::FileSP BORROWED, bool transfer_ownership)
        """
        ...
    
    def Print(self, str):
        r"""Print(SBCommandReturnObject self, char const * str)"""
        ...
    
    def write(self, str):
        r"""write(SBCommandReturnObject self, char const * str)"""
        ...
    
    def flush(self):
        r"""flush(SBCommandReturnObject self)"""
        ...
    


class SBCommunication:
    r"""Allows sending/receiving data."""
    thisown = ...
    __repr__ = ...
    eBroadcastBitDisconnected = ...
    eBroadcastBitReadThreadGotBytes = ...
    eBroadcastBitReadThreadDidExit = ...
    eBroadcastBitReadThreadShouldExit = ...
    eBroadcastBitPacketAvailable = ...
    eAllEventBits = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBCommunication self) -> SBCommunication
        __init__(SBCommunication self, char const * broadcaster_name) -> SBCommunication
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBCommunication self) -> bool"""
        ...
    
    def GetBroadcaster(self):
        r"""GetBroadcaster(SBCommunication self) -> SBBroadcaster"""
        ...
    
    @staticmethod
    def GetBroadcasterClass():
        r"""GetBroadcasterClass() -> char const *"""
        ...
    
    def AdoptFileDesriptor(self, fd, owns_fd):
        r"""AdoptFileDesriptor(SBCommunication self, int fd, bool owns_fd) -> lldb::ConnectionStatus"""
        ...
    
    def Connect(self, url):
        r"""Connect(SBCommunication self, char const * url) -> lldb::ConnectionStatus"""
        ...
    
    def Disconnect(self):
        r"""Disconnect(SBCommunication self) -> lldb::ConnectionStatus"""
        ...
    
    def IsConnected(self):
        r"""IsConnected(SBCommunication self) -> bool"""
        ...
    
    def GetCloseOnEOF(self):
        r"""GetCloseOnEOF(SBCommunication self) -> bool"""
        ...
    
    def SetCloseOnEOF(self, b):
        r"""SetCloseOnEOF(SBCommunication self, bool b)"""
        ...
    
    def Read(self, dst, dst_len, timeout_usec, status):
        r"""Read(SBCommunication self, void * dst, size_t dst_len, uint32_t timeout_usec, lldb::ConnectionStatus & status) -> size_t"""
        ...
    
    def Write(self, src, src_len, status):
        r"""Write(SBCommunication self, void const * src, size_t src_len, lldb::ConnectionStatus & status) -> size_t"""
        ...
    
    def ReadThreadStart(self):
        r"""ReadThreadStart(SBCommunication self) -> bool"""
        ...
    
    def ReadThreadStop(self):
        r"""ReadThreadStop(SBCommunication self) -> bool"""
        ...
    
    def ReadThreadIsRunning(self):
        r"""ReadThreadIsRunning(SBCommunication self) -> bool"""
        ...
    
    def SetReadThreadBytesReceivedCallback(self, callback, callback_baton):
        r"""SetReadThreadBytesReceivedCallback(SBCommunication self, lldb::SBCommunication::ReadThreadBytesReceived callback, void * callback_baton) -> bool"""
        ...
    


class SBCompileUnit:
    r"""
    Represents a compilation unit, or compiled source file.

    SBCompileUnit supports line entry iteration. For example,::

        # Now get the SBSymbolContext from this frame.  We want everything. :-)
        context = frame0.GetSymbolContext(lldb.eSymbolContextEverything)
        ...

        compileUnit = context.GetCompileUnit()

        for lineEntry in compileUnit:
            print('line entry: %s:%d' % (str(lineEntry.GetFileSpec()),
                                        lineEntry.GetLine()))
            print('start addr: %s' % str(lineEntry.GetStartAddress()))
            print('end   addr: %s' % str(lineEntry.GetEndAddress()))

    produces: ::

      line entry: /Volumes/data/lldb/svn/trunk/test/python_api/symbol-context/main.c:20
      start addr: a.out[0x100000d98]
      end   addr: a.out[0x100000da3]
      line entry: /Volumes/data/lldb/svn/trunk/test/python_api/symbol-context/main.c:21
      start addr: a.out[0x100000da3]
      end   addr: a.out[0x100000da9]
      line entry: /Volumes/data/lldb/svn/trunk/test/python_api/symbol-context/main.c:22
      start addr: a.out[0x100000da9]
      end   addr: a.out[0x100000db6]
      line entry: /Volumes/data/lldb/svn/trunk/test/python_api/symbol-context/main.c:23
      start addr: a.out[0x100000db6]
      end   addr: a.out[0x100000dbc]
      ...

    See also :py:class:`SBSymbolContext` and :py:class:`SBLineEntry`
    """
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBCompileUnit self) -> SBCompileUnit
        __init__(SBCompileUnit self, SBCompileUnit rhs) -> SBCompileUnit
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBCompileUnit self) -> bool"""
        ...
    
    def GetFileSpec(self):
        r"""GetFileSpec(SBCompileUnit self) -> SBFileSpec"""
        ...
    
    def GetNumLineEntries(self):
        r"""GetNumLineEntries(SBCompileUnit self) -> uint32_t"""
        ...
    
    def GetLineEntryAtIndex(self, idx):
        r"""GetLineEntryAtIndex(SBCompileUnit self, uint32_t idx) -> SBLineEntry"""
        ...
    
    def FindLineEntryIndex(self, *args):
        r"""
        FindLineEntryIndex(SBCompileUnit self, SBLineEntry line_entry, bool exact=False) -> uint32_t
        FindLineEntryIndex(SBCompileUnit self, uint32_t start_idx, uint32_t line, SBFileSpec inline_file_spec) -> uint32_t
        FindLineEntryIndex(SBCompileUnit self, uint32_t start_idx, uint32_t line, SBFileSpec inline_file_spec, bool exact) -> uint32_t

             Get the index for a provided line entry in this compile unit.

             @param[in] line_entry
                The SBLineEntry object for which we are looking for the index.

             @param[in] exact
                An optional boolean defaulting to false that ensures that the provided
                line entry has a perfect match in the compile unit.

             @return
                The index of the user-provided line entry. UINT32_MAX if the line entry
                was not found in the compile unit.
        """
        ...
    
    def GetSupportFileAtIndex(self, idx):
        r"""GetSupportFileAtIndex(SBCompileUnit self, uint32_t idx) -> SBFileSpec"""
        ...
    
    def GetNumSupportFiles(self):
        r"""GetNumSupportFiles(SBCompileUnit self) -> uint32_t"""
        ...
    
    def FindSupportFileIndex(self, start_idx, sb_file, full):
        r"""FindSupportFileIndex(SBCompileUnit self, uint32_t start_idx, SBFileSpec sb_file, bool full) -> uint32_t"""
        ...
    
    def GetTypes(self, *args):
        r"""
        GetTypes(SBCompileUnit self, uint32_t type_mask=eTypeClassAny) -> SBTypeList

             Get all types matching type_mask from debug info in this
             compile unit.

             @param[in] type_mask
                A bitfield that consists of one or more bits logically OR'ed
                together from the lldb::TypeClass enumeration. This allows
                you to request only structure types, or only class, struct
                and union types. Passing in lldb::eTypeClassAny will return
                all types found in the debug information for this compile
                unit.

             @return
                A list of types in this compile unit that match type_mask
        """
        ...
    
    def GetLanguage(self):
        r"""GetLanguage(SBCompileUnit self) -> lldb::LanguageType"""
        ...
    
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBCompileUnit self, SBCompileUnit rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBCompileUnit self, SBCompileUnit rhs) -> bool"""
        ...
    
    def GetDescription(self, description):
        r"""GetDescription(SBCompileUnit self, SBStream description) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBCompileUnit self) -> std::string"""
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        '''Iterate over all line entries in a lldb.SBCompileUnit object.'''
        ...
    
    def __len__(self):
        '''Return the number of line entries in a lldb.SBCompileUnit
        object.'''
        ...
    
    file = ...
    num_line_entries = ...
    def __eq__(self, rhs) -> bool:
        ...
    
    def __ne__(self, rhs) -> bool:
        ...
    


class SBData:
    r"""Represents a data buffer."""
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBData self) -> SBData
        __init__(SBData self, SBData rhs) -> SBData
        """
        ...
    
    __swig_destroy__ = ...
    def GetAddressByteSize(self):
        r"""GetAddressByteSize(SBData self) -> uint8_t"""
        ...
    
    def SetAddressByteSize(self, addr_byte_size):
        r"""SetAddressByteSize(SBData self, uint8_t addr_byte_size)"""
        ...
    
    def Clear(self):
        r"""Clear(SBData self)"""
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBData self) -> bool"""
        ...
    
    def GetByteSize(self):
        r"""GetByteSize(SBData self) -> size_t"""
        ...
    
    def GetByteOrder(self):
        r"""GetByteOrder(SBData self) -> lldb::ByteOrder"""
        ...
    
    def SetByteOrder(self, endian):
        r"""SetByteOrder(SBData self, lldb::ByteOrder endian)"""
        ...
    
    def GetFloat(self, error, offset):
        r"""GetFloat(SBData self, SBError error, lldb::offset_t offset) -> float"""
        ...
    
    def GetDouble(self, error, offset):
        r"""GetDouble(SBData self, SBError error, lldb::offset_t offset) -> double"""
        ...
    
    def GetLongDouble(self, error, offset):
        r"""GetLongDouble(SBData self, SBError error, lldb::offset_t offset) -> long double"""
        ...
    
    def GetAddress(self, error, offset):
        r"""GetAddress(SBData self, SBError error, lldb::offset_t offset) -> lldb::addr_t"""
        ...
    
    def GetUnsignedInt8(self, error, offset):
        r"""GetUnsignedInt8(SBData self, SBError error, lldb::offset_t offset) -> uint8_t"""
        ...
    
    def GetUnsignedInt16(self, error, offset):
        r"""GetUnsignedInt16(SBData self, SBError error, lldb::offset_t offset) -> uint16_t"""
        ...
    
    def GetUnsignedInt32(self, error, offset):
        r"""GetUnsignedInt32(SBData self, SBError error, lldb::offset_t offset) -> uint32_t"""
        ...
    
    def GetUnsignedInt64(self, error, offset):
        r"""GetUnsignedInt64(SBData self, SBError error, lldb::offset_t offset) -> uint64_t"""
        ...
    
    def GetSignedInt8(self, error, offset):
        r"""GetSignedInt8(SBData self, SBError error, lldb::offset_t offset) -> int8_t"""
        ...
    
    def GetSignedInt16(self, error, offset):
        r"""GetSignedInt16(SBData self, SBError error, lldb::offset_t offset) -> int16_t"""
        ...
    
    def GetSignedInt32(self, error, offset):
        r"""GetSignedInt32(SBData self, SBError error, lldb::offset_t offset) -> int32_t"""
        ...
    
    def GetSignedInt64(self, error, offset):
        r"""GetSignedInt64(SBData self, SBError error, lldb::offset_t offset) -> int64_t"""
        ...
    
    def GetString(self, error, offset):
        r"""GetString(SBData self, SBError error, lldb::offset_t offset) -> char const *"""
        ...
    
    def ReadRawData(self, error, offset, buf):
        r"""ReadRawData(SBData self, SBError error, lldb::offset_t offset, void * buf) -> size_t"""
        ...
    
    def GetDescription(self, *args):
        r"""GetDescription(SBData self, SBStream description, lldb::addr_t base_addr=18446744073709551615ULL) -> bool"""
        ...
    
    def SetData(self, error, buf, endian, addr_size):
        r"""SetData(SBData self, SBError error, void const * buf, lldb::ByteOrder endian, uint8_t addr_size)"""
        ...
    
    def SetDataWithOwnership(self, error, buf, endian, addr_size):
        r"""SetDataWithOwnership(SBData self, SBError error, void const * buf, lldb::ByteOrder endian, uint8_t addr_size)"""
        ...
    
    def Append(self, rhs):
        r"""Append(SBData self, SBData rhs) -> bool"""
        ...
    
    @staticmethod
    def CreateDataFromCString(endian, addr_byte_size, data):
        r"""CreateDataFromCString(lldb::ByteOrder endian, uint32_t addr_byte_size, char const * data) -> SBData"""
        ...
    
    @staticmethod
    def CreateDataFromUInt64Array(endian, addr_byte_size, array):
        r"""CreateDataFromUInt64Array(lldb::ByteOrder endian, uint32_t addr_byte_size, uint64_t * array) -> SBData"""
        ...
    
    @staticmethod
    def CreateDataFromUInt32Array(endian, addr_byte_size, array):
        r"""CreateDataFromUInt32Array(lldb::ByteOrder endian, uint32_t addr_byte_size, uint32_t * array) -> SBData"""
        ...
    
    @staticmethod
    def CreateDataFromSInt64Array(endian, addr_byte_size, array):
        r"""CreateDataFromSInt64Array(lldb::ByteOrder endian, uint32_t addr_byte_size, int64_t * array) -> SBData"""
        ...
    
    @staticmethod
    def CreateDataFromSInt32Array(endian, addr_byte_size, array):
        r"""CreateDataFromSInt32Array(lldb::ByteOrder endian, uint32_t addr_byte_size, int32_t * array) -> SBData"""
        ...
    
    @staticmethod
    def CreateDataFromDoubleArray(endian, addr_byte_size, array):
        r"""CreateDataFromDoubleArray(lldb::ByteOrder endian, uint32_t addr_byte_size, double * array) -> SBData"""
        ...
    
    def SetDataFromCString(self, data):
        r"""SetDataFromCString(SBData self, char const * data) -> bool"""
        ...
    
    def SetDataFromUInt64Array(self, array):
        r"""SetDataFromUInt64Array(SBData self, uint64_t * array) -> bool"""
        ...
    
    def SetDataFromUInt32Array(self, array):
        r"""SetDataFromUInt32Array(SBData self, uint32_t * array) -> bool"""
        ...
    
    def SetDataFromSInt64Array(self, array):
        r"""SetDataFromSInt64Array(SBData self, int64_t * array) -> bool"""
        ...
    
    def SetDataFromSInt32Array(self, array):
        r"""SetDataFromSInt32Array(SBData self, int32_t * array) -> bool"""
        ...
    
    def SetDataFromDoubleArray(self, array):
        r"""SetDataFromDoubleArray(SBData self, double * array) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBData self) -> std::string"""
        ...
    
    class read_data_helper:
        def __init__(self, sbdata, readerfunc, item_size) -> None:
            ...
        
        def __getitem__(self, key): # -> list[Any]:
            ...
        
        def __len__(self): # -> int:
            ...
        
        def all(self): # -> list[Any]:
            ...
        
    
    
    @classmethod
    def CreateDataFromInt(cls, value, size=..., target=..., ptr_size=..., endian=...): # -> None:
        ...
    
    uint8 = ...
    uint16 = ...
    uint32 = ...
    uint64 = ...
    sint8 = ...
    sint16 = ...
    sint32 = ...
    sint64 = ...
    float = ...
    double = ...
    uint8s = ...
    uint16s = ...
    uint32s = ...
    uint64s = ...
    sint8s = ...
    sint16s = ...
    sint32s = ...
    sint64s = ...
    floats = ...
    doubles = ...
    byte_order = ...
    size = ...


# noinspection PyPep8Naming
class SBDebugger:
    r"""
    SBDebugger is the primordial object that creates SBTargets and provides
    access to them.  It also manages the overall debugging experiences.

    For example (from example/disasm.py),::

        import lldb
        import os
        import sys

        def disassemble_instructions (insts):
            for i in insts:
                print i

        ...

        # Create a new debugger instance
        debugger = lldb.SBDebugger.Create()

        # When we step or continue, don't return from the function until the process
        # stops. We do this by setting the async mode to false.
        debugger.SetAsync (False)

        # Create a target from a file and arch
        print('Creating a target for '%s'' % exe)

        target = debugger.CreateTargetWithFileAndArch (exe, lldb.LLDB_ARCH_DEFAULT)

        if target:
            # If the target is valid set a breakpoint at main
            main_bp = target.BreakpointCreateByName (fname, target.GetExecutable().GetFilename());

            print main_bp

            # Launch the process. Since we specified synchronous mode, we won't return
            # from this function until we hit the breakpoint at main
            process = target.LaunchSimple (None, None, os.getcwd())

            # Make sure the launch went ok
            if process:
                # Print some simple process info
                state = process.GetState ()
                print process
                if state == lldb.eStateStopped:
                    # Get the first thread
                    thread = process.GetThreadAtIndex (0)
                    if thread:
                        # Print some simple thread info
                        print thread
                        # Get the first frame
                        frame = thread.GetFrameAtIndex (0)
                        if frame:
                            # Print some simple frame info
                            print frame
                            function = frame.GetFunction()
                            # See if we have debug info (a function)
                            if function:
                                # We do have a function, print some info for the function
                                print function
                                # Now get all instructions for this function and print them
                                insts = function.GetInstructions(target)
                                disassemble_instructions (insts)
                            else:
                                # See if we have a symbol in the symbol table for where we stopped
                                symbol = frame.GetSymbol();
                                if symbol:
                                    # We do have a symbol, print some info for the symbol
                                    print symbol
                                    # Now get all instructions for this symbol and print them
                                    insts = symbol.GetInstructions(target)
                                    disassemble_instructions (insts)

                            registerList = frame.GetRegisters()
                            print('Frame registers (size of register set = %d):' % registerList.GetSize())
                            for value in registerList:
                                #print value
                                print('%s (number of children = %d):' % (value.GetName(), value.GetNumChildren()))
                                for child in value:
                                    print('Name: ', child.GetName(), ' Value: ', child.GetValue())

                    print('Hit the breakpoint at main, enter to continue and wait for program to exit or 'Ctrl-D'/'quit' to terminate the program')
                    next = sys.stdin.readline()
                    if not next or next.rstrip('\n') == 'quit':
                        print('Terminating the inferior process...')
                        process.Kill()
                    else:
                        # Now continue to the program exit
                        process.Continue()
                        # When we return from the above function we will hopefully be at the
                        # program exit. Print out some process info
                        print process
                elif state == lldb.eStateExited:
                    print('Didn't hit the breakpoint at main, program has exited...')
                else:
                    print('Unexpected process state: %s, killing process...' % debugger.StateAsCString (state))
                    process.Kill()

    Sometimes you need to create an empty target that will get filled in later.  The most common use for this
    is to attach to a process by name or pid where you don't know the executable up front.  The most convenient way
    to do this is: ::

        target = debugger.CreateTarget('')
        error = lldb.SBError()
        process = target.AttachToProcessWithName(debugger.GetListener(), 'PROCESS_NAME', False, error)

    or the equivalent arguments for :py:class:`SBTarget.AttachToProcessWithID` .
    """
    thisown = ...
    eBroadcastBitProgress = ...
    eBroadcastBitWarning = ...
    eBroadcastBitError = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBDebugger self) -> SBDebugger
        __init__(SBDebugger self, SBDebugger rhs) -> SBDebugger
        """
        ...
    
    __swig_destroy__ = ...
    @staticmethod
    def GetBroadcasterClass() -> str:
        r"""GetBroadcasterClass() -> char const *"""
        ...
    
    def GetBroadcaster(self) -> SBBroadcaster:
        r"""GetBroadcaster(SBDebugger self) -> SBBroadcaster"""
        ...
    
    @staticmethod
    def GetProgressFromEvent(event: SBEvent) -> str:
        r"""GetProgressFromEvent(SBEvent event) -> char const *"""
        ...
    
    @staticmethod
    def GetProgressDataFromEvent(event: SBEvent) -> SBStructuredData:
        r"""GetProgressDataFromEvent(SBEvent event) -> SBStructuredData"""
        ...
    
    @staticmethod
    def GetDiagnosticFromEvent(event: SBEvent) -> SBStructuredData:
        r"""GetDiagnosticFromEvent(SBEvent event) -> SBStructuredData"""
        ...
    
    @staticmethod
    def Initialize():
        r"""Initialize()"""
        ...
    
    @staticmethod
    def InitializeWithErrorHandling() -> SBError:
        r"""InitializeWithErrorHandling() -> SBError"""
        ...
    
    @staticmethod
    def PrintStackTraceOnError():
        r"""PrintStackTraceOnError()"""
        ...
    
    @staticmethod
    def Terminate():
        r"""Terminate()"""
        ...
    
    @staticmethod
    def Create(*args) -> SBDebugger:
        r"""
        Create() -> SBDebugger
        Create(bool source_init_files) -> SBDebugger
        Create(bool source_init_files, lldb::LogOutputCallback log_callback) -> SBDebugger
        """
        ...
    
    @staticmethod
    def Destroy(debugger: SBDebugger):
        r"""Destroy(SBDebugger debugger)"""
        ...
    
    @staticmethod
    def MemoryPressureDetected():
        r"""MemoryPressureDetected()"""
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self) -> bool:
        r"""IsValid(SBDebugger self) -> bool"""
        ...
    
    def Clear(self):
        r"""Clear(SBDebugger self)"""
        ...
    
    def GetSetting(self, setting: str=...) -> SBStructuredData:
        r"""GetSetting(SBDebugger self, char const * setting=None) -> SBStructuredData"""
        ...
    
    def SetAsync(self, b: bool):
        r"""SetAsync(SBDebugger self, bool b)"""
        ...
    
    def GetAsync(self) -> bool:
        r"""GetAsync(SBDebugger self) -> bool"""
        ...
    
    def SkipLLDBInitFiles(self, b: bool):
        r"""SkipLLDBInitFiles(SBDebugger self, bool b)"""
        ...
    
    def SkipAppInitFiles(self, b: bool):
        r"""SkipAppInitFiles(SBDebugger self, bool b)"""
        ...
    
    def SetInputString(self, data: str) -> SBError:
        r"""SetInputString(SBDebugger self, char const * data) -> SBError"""
        ...
    
    def SetInputFile(self, *args) -> SBError:
        r"""
        SetInputFile(SBDebugger self, SBFile file) -> SBError
        SetInputFile(SBDebugger self, lldb::FileSP file) -> SBError
        """
        ...
    
    def SetOutputFile(self, *args) -> SBError:
        r"""
        SetOutputFile(SBDebugger self, SBFile file) -> SBError
        SetOutputFile(SBDebugger self, lldb::FileSP file) -> SBError
        """
        ...
    
    def SetErrorFile(self, *args) -> SBError:
        r"""
        SetErrorFile(SBDebugger self, SBFile file) -> SBError
        SetErrorFile(SBDebugger self, lldb::FileSP file) -> SBError
        """
        ...
    
    def GetInputFile(self) -> SBFile:
        r"""GetInputFile(SBDebugger self) -> SBFile"""
        ...
    
    def GetOutputFile(self) -> SBFile:
        r"""GetOutputFile(SBDebugger self) -> SBFile"""
        ...
    
    def GetErrorFile(self) -> SBFile:
        r"""GetErrorFile(SBDebugger self) -> SBFile"""
        ...
    
    def SaveInputTerminalState(self):
        r"""SaveInputTerminalState(SBDebugger self)"""
        ...
    
    def RestoreInputTerminalState(self):
        r"""RestoreInputTerminalState(SBDebugger self)"""
        ...
    
    def GetCommandInterpreter(self) -> SBCommandInterpreter:
        r"""GetCommandInterpreter(SBDebugger self) -> SBCommandInterpreter"""
        ...
    
    def HandleCommand(self, command: str):
        r"""HandleCommand(SBDebugger self, char const * command)"""
        ...
    
    def RequestInterrupt(self):
        r"""RequestInterrupt(SBDebugger self)"""
        ...
    
    def CancelInterruptRequest(self):
        r"""CancelInterruptRequest(SBDebugger self)"""
        ...
    
    def InterruptRequested(self) -> bool:
        r"""InterruptRequested(SBDebugger self) -> bool"""
        ...
    
    def GetListener(self) -> SBListener:
        r"""GetListener(SBDebugger self) -> SBListener"""
        ...
    
    def HandleProcessEvent(self, *args):
        r"""
        HandleProcessEvent(SBDebugger self, SBProcess process, SBEvent event, SBFile out, SBFile err)
        HandleProcessEvent(SBDebugger self, SBProcess process, SBEvent event, lldb::FileSP arg4, lldb::FileSP arg5)
        """
        ...
    
    def CreateTargetWithFileAndTargetTriple(self, filename: str, target_triple: str) -> SBTarget:
        r"""CreateTargetWithFileAndTargetTriple(SBDebugger self, char const * filename, char const * target_triple) -> SBTarget"""
        ...
    
    def CreateTargetWithFileAndArch(self, filename: str, archname: str) -> SBTarget:
        r"""CreateTargetWithFileAndArch(SBDebugger self, char const * filename, char const * archname) -> SBTarget"""
        ...
    
    def CreateTarget(self, *args) -> SBTarget:
        r"""
        CreateTarget(SBDebugger self, char const * filename, char const * target_triple, char const * platform_name, bool add_dependent_modules, SBError error) -> SBTarget
        CreateTarget(SBDebugger self, char const * filename) -> SBTarget
        """
        ...
    
    def GetDummyTarget(self) -> SBTarget:
        r"""
        GetDummyTarget(SBDebugger self) -> SBTarget
        The dummy target holds breakpoints and breakpoint names that will prime newly created targets.
        """
        ...
    
    def DeleteTarget(self, target: SBTarget) -> bool:
        r"""
        DeleteTarget(SBDebugger self, SBTarget target) -> bool
        Return true if target is deleted from the target list of the debugger.
        """
        ...
    
    def GetTargetAtIndex(self, idx: int) -> SBTarget:
        r"""GetTargetAtIndex(SBDebugger self, uint32_t idx) -> SBTarget"""
        ...
    
    def GetIndexOfTarget(self, target: SBTarget) -> int:
        r"""GetIndexOfTarget(SBDebugger self, SBTarget target) -> uint32_t"""
        ...
    
    def FindTargetWithProcessID(self, pid) -> SBTarget:
        r"""FindTargetWithProcessID(SBDebugger self, lldb::pid_t pid) -> SBTarget"""
        ...
    
    def FindTargetWithFileAndArch(self, filename: str, arch: str) -> SBTarget:
        r"""FindTargetWithFileAndArch(SBDebugger self, char const * filename, char const * arch) -> SBTarget"""
        ...
    
    def GetNumTargets(self) -> int:
        r"""GetNumTargets(SBDebugger self) -> uint32_t"""
        ...
    
    def GetSelectedTarget(self) -> SBTarget:
        r"""GetSelectedTarget(SBDebugger self) -> SBTarget"""
        ...
    
    def SetSelectedTarget(self, target: SBTarget):
        r"""SetSelectedTarget(SBDebugger self, SBTarget target)"""
        ...
    
    def GetSelectedPlatform(self) -> SBPlatform:
        r"""GetSelectedPlatform(SBDebugger self) -> SBPlatform"""
        ...
    
    def SetSelectedPlatform(self, platform: SBPlatform):
        r"""SetSelectedPlatform(SBDebugger self, SBPlatform platform)"""
        ...
    
    def GetNumPlatforms(self) -> int:
        r"""
        GetNumPlatforms(SBDebugger self) -> uint32_t
        Get the number of currently active platforms.
        """
        ...
    
    def GetPlatformAtIndex(self, idx: int):
        r"""
        GetPlatformAtIndex(SBDebugger self, uint32_t idx) -> SBPlatform
        Get one of the currently active platforms.
        """
        ...
    
    def GetNumAvailablePlatforms(self) -> int:
        r"""
        GetNumAvailablePlatforms(SBDebugger self) -> uint32_t
        Get the number of available platforms.
        """
        ...
    
    def GetAvailablePlatformInfoAtIndex(self, idx: int) -> SBStructuredData:
        r"""
        GetAvailablePlatformInfoAtIndex(SBDebugger self, uint32_t idx) -> SBStructuredData

            Get the name and description of one of the available platforms.

            @param idx Zero-based index of the platform for which info should be
                       retrieved, must be less than the value returned by
                       GetNumAvailablePlatforms().
        """
        ...
    
    def GetSourceManager(self) -> SBSourceManager:
        r"""GetSourceManager(SBDebugger self) -> SBSourceManager"""
        ...
    
    def SetCurrentPlatform(self, platform_name: str) -> SBError:
        r"""SetCurrentPlatform(SBDebugger self, char const * platform_name) -> SBError"""
        ...
    
    def SetCurrentPlatformSDKRoot(self, sysroot: str) -> bool:
        r"""SetCurrentPlatformSDKRoot(SBDebugger self, char const * sysroot) -> bool"""
        ...
    
    def SetUseExternalEditor(self, input: bool) -> bool:
        r"""SetUseExternalEditor(SBDebugger self, bool input) -> bool"""
        ...
    
    def GetUseExternalEditor(self) -> bool:
        r"""GetUseExternalEditor(SBDebugger self) -> bool"""
        ...
    
    def SetUseColor(self, use_color: bool) -> bool:
        r"""SetUseColor(SBDebugger self, bool use_color) -> bool"""
        ...
    
    def GetUseColor(self) -> bool:
        r"""GetUseColor(SBDebugger self) -> bool"""
        ...
    
    def SetUseSourceCache(self, use_source_cache: bool) -> bool:
        r"""SetUseSourceCache(SBDebugger self, bool use_source_cache) -> bool"""
        ...
    
    def GetUseSourceCache(self) -> bool:
        r"""GetUseSourceCache(SBDebugger self) -> bool"""
        ...
    
    @staticmethod
    def GetDefaultArchitecture(arch_name: str, arch_name_len: int) -> bool:
        r"""GetDefaultArchitecture(char * arch_name, size_t arch_name_len) -> bool"""
        ...
    
    @staticmethod
    def SetDefaultArchitecture(arch_name: str):
        r"""SetDefaultArchitecture(char const * arch_name) -> bool"""
        ...
    
    def GetScriptingLanguage(self, script_language_name: str):
        r"""GetScriptingLanguage(SBDebugger self, char const * script_language_name) -> lldb::ScriptLanguage"""
        ...
    
    def GetScriptInterpreterInfo(self, arg2) -> SBStructuredData:
        r"""GetScriptInterpreterInfo(SBDebugger self, lldb::ScriptLanguage arg2) -> SBStructuredData"""
        ...
    
    @staticmethod
    def GetVersionString() -> str:
        r"""GetVersionString() -> char const *"""
        ...
    
    @staticmethod
    def StateAsCString(state) -> str:
        r"""StateAsCString(lldb::StateType state) -> char const *"""
        ...
    
    @staticmethod
    def GetBuildConfiguration() -> SBStructuredData:
        r"""GetBuildConfiguration() -> SBStructuredData"""
        ...
    
    @staticmethod
    def StateIsRunningState(state) -> bool:
        r"""StateIsRunningState(lldb::StateType state) -> bool"""
        ...
    
    @staticmethod
    def StateIsStoppedState(state) -> bool:
        r"""StateIsStoppedState(lldb::StateType state) -> bool"""
        ...
    
    def EnableLog(self, channel: str, categories: List[str]) -> bool:
        r"""EnableLog(SBDebugger self, char const * channel, char const ** categories) -> bool"""
        ...
    
    def SetLoggingCallback(self, log_callback):
        r"""SetLoggingCallback(SBDebugger self, lldb::LogOutputCallback log_callback)"""
        ...
    
    def SetDestroyCallback(self, destroy_callback):
        r"""SetDestroyCallback(SBDebugger self, lldb::SBDebuggerDestroyCallback destroy_callback)"""
        ...
    
    def DispatchInput(self, data: str):
        r"""DispatchInput(SBDebugger self, void const * data)"""
        ...
    
    def DispatchInputInterrupt(self):
        r"""DispatchInputInterrupt(SBDebugger self)"""
        ...
    
    def DispatchInputEndOfFile(self):
        r"""DispatchInputEndOfFile(SBDebugger self)"""
        ...
    
    def GetInstanceName(self) -> str:
        r"""GetInstanceName(SBDebugger self) -> char const *"""
        ...
    
    @staticmethod
    def FindDebuggerWithID(id: int) -> SBDebugger:
        r"""FindDebuggerWithID(int id) -> SBDebugger"""
        ...
    
    @staticmethod
    def SetInternalVariable(var_name: str, value: str, debugger_instance_name: str) -> SBError:
        r"""SetInternalVariable(char const * var_name, char const * value, char const * debugger_instance_name) -> SBError"""
        ...
    
    @staticmethod
    def GetInternalVariableValue(var_name: str, debugger_instance_name: str) -> SBStringList:
        r"""GetInternalVariableValue(char const * var_name, char const * debugger_instance_name) -> SBStringList"""
        ...
    
    def GetDescription(self, description: SBStream) -> bool:
        r"""GetDescription(SBDebugger self, SBStream description) -> bool"""
        ...
    
    def GetTerminalWidth(self) -> int:
        r"""GetTerminalWidth(SBDebugger self) -> uint32_t"""
        ...
    
    def SetTerminalWidth(self, term_width: int):
        r"""SetTerminalWidth(SBDebugger self, uint32_t term_width)"""
        ...
    
    def GetID(self):
        r"""GetID(SBDebugger self) -> lldb::user_id_t"""
        ...
    
    def GetPrompt(self) -> str:
        r"""GetPrompt(SBDebugger self) -> char const *"""
        ...
    
    def SetPrompt(self, prompt: str):
        r"""SetPrompt(SBDebugger self, char const * prompt)"""
        ...
    
    def GetReproducerPath(self) -> str:
        r"""GetReproducerPath(SBDebugger self) -> char const *"""
        ...
    
    def GetScriptLanguage(self):
        r"""GetScriptLanguage(SBDebugger self) -> lldb::ScriptLanguage"""
        ...
    
    def SetScriptLanguage(self, script_lang):
        r"""SetScriptLanguage(SBDebugger self, lldb::ScriptLanguage script_lang)"""
        ...
    
    def GetREPLLanguage(self):
        r"""GetREPLLanguage(SBDebugger self) -> lldb::LanguageType"""
        ...
    
    def SetREPLLanguage(self, repl_lang):
        r"""SetREPLLanguage(SBDebugger self, lldb::LanguageType repl_lang)"""
        ...
    
    def GetCloseInputOnEOF(self) -> bool:
        r"""GetCloseInputOnEOF(SBDebugger self) -> bool"""
        ...
    
    def SetCloseInputOnEOF(self, b: bool):
        r"""SetCloseInputOnEOF(SBDebugger self, bool b)"""
        ...
    
    def GetCategory(self, *args) -> SBTypeCategory:
        r"""
        GetCategory(SBDebugger self, char const * category_name) -> SBTypeCategory
        GetCategory(SBDebugger self, lldb::LanguageType lang_type) -> SBTypeCategory
        """
        ...
    
    def CreateCategory(self, category_name: str) -> SBTypeCategory:
        r"""CreateCategory(SBDebugger self, char const * category_name) -> SBTypeCategory"""
        ...
    
    def DeleteCategory(self, category_name: str) -> bool:
        r"""DeleteCategory(SBDebugger self, char const * category_name) -> bool"""
        ...
    
    def GetNumCategories(self) -> int:
        r"""GetNumCategories(SBDebugger self) -> uint32_t"""
        ...
    
    def GetCategoryAtIndex(self, arg2: int) -> SBTypeCategory:
        r"""GetCategoryAtIndex(SBDebugger self, uint32_t arg2) -> SBTypeCategory"""
        ...
    
    def GetDefaultCategory(self) -> SBTypeCategory:
        r"""GetDefaultCategory(SBDebugger self) -> SBTypeCategory"""
        ...
    
    def GetFormatForType(self, arg2: SBTypeNameSpecifier) -> SBTypeFormat:
        r"""GetFormatForType(SBDebugger self, SBTypeNameSpecifier arg2) -> SBTypeFormat"""
        ...
    
    def GetSummaryForType(self, arg2: SBTypeNameSpecifier) -> SBTypeSummary:
        r"""GetSummaryForType(SBDebugger self, SBTypeNameSpecifier arg2) -> SBTypeSummary"""
        ...
    
    def GetFilterForType(self, arg2: SBTypeNameSpecifier) -> SBTypeFilter:
        r"""GetFilterForType(SBDebugger self, SBTypeNameSpecifier arg2) -> SBTypeFilter"""
        ...
    
    def GetSyntheticForType(self, arg2: SBTypeNameSpecifier) -> SBTypeSynthetic:
        r"""GetSyntheticForType(SBDebugger self, SBTypeNameSpecifier arg2) -> SBTypeSynthetic"""
        ...
    
    def RunCommandInterpreter(self, auto_handle_events: bool, spawn_thread: bool, options: SBCommandInterpreterRunOptions, num_errors, quit_requested, stopped_for_crash):
        r"""
        RunCommandInterpreter(SBDebugger self, bool auto_handle_events, bool spawn_thread, SBCommandInterpreterRunOptions options, int & num_errors, bool & quit_requested, bool & stopped_for_crash)
        Launch a command interpreter session. Commands are read from standard input or
        from the input handle specified for the debugger object. Output/errors are
        similarly redirected to standard output/error or the configured handles.

        @param[in] auto_handle_events If true, automatically handle resulting events.
        @param[in] spawn_thread If true, start a new thread for IO handling.
        @param[in] options Parameter collection of type SBCommandInterpreterRunOptions.
        @param[in] num_errors Initial error counter.
        @param[in] quit_requested Initial quit request flag.
        @param[in] stopped_for_crash Initial crash flag.

        @return
        A tuple with the number of errors encountered by the interpreter, a boolean
        indicating whether quitting the interpreter was requested and another boolean
        set to True in case of a crash.

        Example: ::

            # Start an interactive lldb session from a script (with a valid debugger object
            # created beforehand):
            n_errors, quit_requested, has_crashed = debugger.RunCommandInterpreter(True,
                False, lldb.SBCommandInterpreterRunOptions(), 0, False, False)
        """
        ...
    
    def RunREPL(self, language, repl_options: str) -> SBError:
        r"""RunREPL(SBDebugger self, lldb::LanguageType language, char const * repl_options) -> SBError"""
        ...
    
    def LoadTraceFromFile(self, error: SBError, trace_description_file: SBFileSpec) -> SBTrace:
        r"""LoadTraceFromFile(SBDebugger self, SBError error, SBFileSpec trace_description_file) -> SBTrace"""
        ...
    
    def __repr__(self) -> str:
        r"""__repr__(SBDebugger self) -> std::string"""
        ...
    
    def SetOutputFileHandle(self, file, transfer_ownership): # -> None:
        "DEPRECATED, use SetOutputFile"
        ...
    
    def SetInputFileHandle(self, file, transfer_ownership): # -> None:
        "DEPRECATED, use SetInputFile"
        ...
    
    def SetErrorFileHandle(self, file, transfer_ownership): # -> None:
        "DEPRECATED, use SetErrorFile"
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        '''Iterate over all targets in a lldb.SBDebugger object.'''
        ...
    
    def __len__(self):
        '''Return the number of targets in a lldb.SBDebugger object.'''
        ...
    
    def GetInputFileHandle(self):
        r"""GetInputFileHandle(SBDebugger self) -> lldb::FileSP"""
        ...
    
    def GetOutputFileHandle(self):
        r"""GetOutputFileHandle(SBDebugger self) -> lldb::FileSP"""
        ...
    
    def GetErrorFileHandle(self):
        r"""GetErrorFileHandle(SBDebugger self) -> lldb::FileSP"""
        ...
    


class SBDeclaration:
    r"""Specifies an association with a line and column for a variable."""
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBDeclaration self) -> SBDeclaration
        __init__(SBDeclaration self, SBDeclaration rhs) -> SBDeclaration
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBDeclaration self) -> bool"""
        ...
    
    def GetFileSpec(self):
        r"""GetFileSpec(SBDeclaration self) -> SBFileSpec"""
        ...
    
    def GetLine(self):
        r"""GetLine(SBDeclaration self) -> uint32_t"""
        ...
    
    def GetColumn(self):
        r"""GetColumn(SBDeclaration self) -> uint32_t"""
        ...
    
    def SetFileSpec(self, filespec):
        r"""SetFileSpec(SBDeclaration self, SBFileSpec filespec)"""
        ...
    
    def SetLine(self, line):
        r"""SetLine(SBDeclaration self, uint32_t line)"""
        ...
    
    def SetColumn(self, column):
        r"""SetColumn(SBDeclaration self, uint32_t column)"""
        ...
    
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBDeclaration self, SBDeclaration rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBDeclaration self, SBDeclaration rhs) -> bool"""
        ...
    
    def GetDescription(self, description):
        r"""GetDescription(SBDeclaration self, SBStream description) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBDeclaration self) -> std::string"""
        ...
    
    file = ...
    line = ...
    column = ...
    def __eq__(self, rhs) -> bool:
        ...
    
    def __ne__(self, rhs) -> bool:
        ...
    


class SBError:
    r"""
    Represents a container for holding any error code.

    For example (from test/python_api/hello_world/TestHelloWorld.py), ::

        def hello_world_attach_with_id_api(self):
            '''Create target, spawn a process, and attach to it by id.'''

            target = self.dbg.CreateTarget(self.exe)

            # Spawn a new process and don't display the stdout if not in TraceOn() mode.
            import subprocess
            popen = subprocess.Popen([self.exe, 'abc', 'xyz'],
                                     stdout = open(os.devnull, 'w') if not self.TraceOn() else None)

            listener = lldb.SBListener('my.attach.listener')
            error = lldb.SBError()
            process = target.AttachToProcessWithID(listener, popen.pid, error)

            self.assertTrue(error.Success() and process, PROCESS_IS_VALID)

            # Let's check the stack traces of the attached process.
            import lldbutil
            stacktraces = lldbutil.print_stacktraces(process, string_buffer=True)
            self.expect(stacktraces, exe=False,
                substrs = ['main.c:%d' % self.line2,
                           '(int)argc=3'])

            listener = lldb.SBListener('my.attach.listener')
            error = lldb.SBError()
            process = target.AttachToProcessWithID(listener, popen.pid, error)

            self.assertTrue(error.Success() and process, PROCESS_IS_VALID)

    checks that after the attach, there is no error condition by asserting
    that error.Success() is True and we get back a valid process object.

    And (from test/python_api/event/TestEvent.py), ::

            # Now launch the process, and do not stop at entry point.
            error = lldb.SBError()
            process = target.Launch(listener, None, None, None, None, None, None, 0, False, error)
            self.assertTrue(error.Success() and process, PROCESS_IS_VALID)

    checks that after calling the target.Launch() method there's no error
    condition and we get back a void process object.
    """
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBError self) -> SBError
        __init__(SBError self, SBError rhs) -> SBError
        __init__(SBError self, char const * message) -> SBError
        """
        ...
    
    __swig_destroy__ = ...
    def GetCString(self) -> str:
        r"""GetCString(SBError self) -> char const *"""
        ...
    
    def Clear(self):
        r"""Clear(SBError self)"""
        ...
    
    def Fail(self) -> bool:
        r"""Fail(SBError self) -> bool"""
        ...
    
    def Success(self) -> bool:
        r"""Success(SBError self) -> bool"""
        ...
    
    def GetError(self) -> int:
        r"""GetError(SBError self) -> uint32_t"""
        ...
    
    def GetType(self):
        r"""GetType(SBError self) -> lldb::ErrorType"""
        ...
    
    def SetError(self, err: int, type):
        r"""SetError(SBError self, uint32_t err, lldb::ErrorType type)"""
        ...
    
    def SetErrorToErrno(self):
        r"""SetErrorToErrno(SBError self)"""
        ...
    
    def SetErrorToGenericError(self):
        r"""SetErrorToGenericError(SBError self)"""
        ...
    
    def SetErrorString(self, err_str: str):
        r"""SetErrorString(SBError self, char const * err_str)"""
        ...
    
    def SetErrorStringWithFormat(self, format: str, str1: str=..., str2: str=..., str3: str=...) -> int:
        r"""SetErrorStringWithFormat(SBError self, char const * format, char * str1=None, char * str2=None, char * str3=None) -> int"""
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self) -> bool:
        r"""IsValid(SBError self) -> bool"""
        ...
    
    def GetDescription(self, description: SBStream) -> bool:
        r"""GetDescription(SBError self, SBStream description) -> bool"""
        ...
    
    def __repr__(self) -> str:
        r"""__repr__(SBError self) -> std::string"""
        ...
    
    value: int = ...
    fail: bool = ...
    success: bool = ...
    description: str = ...
    type = ...


class SBEnvironment:
    r"""
    Represents the environment of a certain process.

    Example: ::

      for entry in lldb.debugger.GetSelectedTarget().GetEnvironment().GetEntries():
        print(entry)


    """
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBEnvironment self) -> SBEnvironment
        __init__(SBEnvironment self, SBEnvironment rhs) -> SBEnvironment
        """
        ...
    
    __swig_destroy__ = ...
    def Get(self, name):
        r"""Get(SBEnvironment self, char const * name) -> char const *"""
        ...
    
    def GetNumValues(self):
        r"""GetNumValues(SBEnvironment self) -> size_t"""
        ...
    
    def GetNameAtIndex(self, index):
        r"""GetNameAtIndex(SBEnvironment self, size_t index) -> char const *"""
        ...
    
    def GetValueAtIndex(self, index):
        r"""GetValueAtIndex(SBEnvironment self, size_t index) -> char const *"""
        ...
    
    def GetEntries(self):
        r"""GetEntries(SBEnvironment self) -> SBStringList"""
        ...
    
    def PutEntry(self, name_and_value):
        r"""PutEntry(SBEnvironment self, char const * name_and_value)"""
        ...
    
    def SetEntries(self, entries, append):
        r"""SetEntries(SBEnvironment self, SBStringList entries, bool append)"""
        ...
    
    def Set(self, name, value, overwrite):
        r"""Set(SBEnvironment self, char const * name, char const * value, bool overwrite) -> bool"""
        ...
    
    def Unset(self, name):
        r"""Unset(SBEnvironment self, char const * name) -> bool"""
        ...
    
    def Clear(self):
        r"""Clear(SBEnvironment self)"""
        ...
    


class SBEvent:
    r"""
    API clients can register to receive events.

    For example, check out the following output: ::

        Try wait for event...
        Event description: 0x103d0bb70 Event: broadcaster = 0x1009c8410, type = 0x00000001, data = { process = 0x1009c8400 (pid = 21528), state = running}
        Event data flavor: Process::ProcessEventData
        Process state: running

        Try wait for event...
        Event description: 0x103a700a0 Event: broadcaster = 0x1009c8410, type = 0x00000001, data = { process = 0x1009c8400 (pid = 21528), state = stopped}
        Event data flavor: Process::ProcessEventData
        Process state: stopped

        Try wait for event...
        Event description: 0x103d0d4a0 Event: broadcaster = 0x1009c8410, type = 0x00000001, data = { process = 0x1009c8400 (pid = 21528), state = exited}
        Event data flavor: Process::ProcessEventData
        Process state: exited

        Try wait for event...
        timeout occurred waiting for event...

    from test/python_api/event/TestEventspy: ::

        def do_listen_for_and_print_event(self):
            '''Create a listener and use SBEvent API to print the events received.'''
            exe = os.path.join(os.getcwd(), 'a.out')

            # Create a target by the debugger.
            target = self.dbg.CreateTarget(exe)
            self.assertTrue(target, VALID_TARGET)

            # Now create a breakpoint on main.c by name 'c'.
            breakpoint = target.BreakpointCreateByName('c', 'a.out')

            # Now launch the process, and do not stop at the entry point.
            process = target.LaunchSimple(None, None, os.getcwd())
            self.assertTrue(process.GetState() == lldb.eStateStopped,
                            PROCESS_STOPPED)

            # Get a handle on the process's broadcaster.
            broadcaster = process.GetBroadcaster()

            # Create an empty event object.
            event = lldb.SBEvent()

            # Create a listener object and register with the broadcaster.
            listener = lldb.SBListener('my listener')
            rc = broadcaster.AddListener(listener, lldb.SBProcess.eBroadcastBitStateChanged)
            self.assertTrue(rc, 'AddListener successfully retruns')

            traceOn = self.TraceOn()
            if traceOn:
                lldbutil.print_stacktraces(process)

            # Create MyListeningThread class to wait for any kind of event.
            import threading
            class MyListeningThread(threading.Thread):
                def run(self):
                    count = 0
                    # Let's only try at most 4 times to retrieve any kind of event.
                    # After that, the thread exits.
                    while not count > 3:
                        if traceOn:
                            print('Try wait for event...')
                        if listener.WaitForEventForBroadcasterWithType(5,
                                                                       broadcaster,
                                                                       lldb.SBProcess.eBroadcastBitStateChanged,
                                                                       event):
                            if traceOn:
                                desc = lldbutil.get_description(event))
                                print('Event description:', desc)
                                print('Event data flavor:', event.GetDataFlavor())
                                print('Process state:', lldbutil.state_type_to_str(process.GetState()))
                                print()
                        else:
                            if traceOn:
                                print 'timeout occurred waiting for event...'
                        count = count + 1
                    return

            # Let's start the listening thread to retrieve the events.
            my_thread = MyListeningThread()
            my_thread.start()

            # Use Python API to continue the process.  The listening thread should be
            # able to receive the state changed events.
            process.Continue()

            # Use Python API to kill the process.  The listening thread should be
            # able to receive the state changed event, too.
            process.Kill()

            # Wait until the 'MyListeningThread' terminates.
            my_thread.join()
    """
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""__init__(self, int type, str data) -> SBEvent (make an event that contains a C string)__init__(self, int type, str data) -> SBEvent (make an event that contains a C string)__init__(self, int type, str data) -> SBEvent (make an event that contains a C string)"""
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBEvent self) -> bool"""
        ...
    
    def GetDataFlavor(self):
        r"""GetDataFlavor(SBEvent self) -> char const *"""
        ...
    
    def GetType(self):
        r"""GetType(SBEvent self) -> uint32_t"""
        ...
    
    def GetBroadcaster(self):
        r"""GetBroadcaster(SBEvent self) -> SBBroadcaster"""
        ...
    
    def GetBroadcasterClass(self):
        r"""GetBroadcasterClass(SBEvent self) -> char const *"""
        ...
    
    def BroadcasterMatchesRef(self, broadcaster):
        r"""BroadcasterMatchesRef(SBEvent self, SBBroadcaster broadcaster) -> bool"""
        ...
    
    def Clear(self):
        r"""Clear(SBEvent self)"""
        ...
    
    @staticmethod
    def GetCStringFromEvent(event):
        r"""GetCStringFromEvent(SBEvent event) -> char const *"""
        ...
    
    def GetDescription(self, *args):
        r"""
        GetDescription(SBEvent self, SBStream description) -> bool
        GetDescription(SBEvent self, SBStream description) -> bool
        """
        ...
    


class SBExecutionContext:
    r"""Describes the program context in which a command should be executed."""
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBExecutionContext self) -> SBExecutionContext
        __init__(SBExecutionContext self, SBExecutionContext rhs) -> SBExecutionContext
        __init__(SBExecutionContext self, SBTarget target) -> SBExecutionContext
        __init__(SBExecutionContext self, SBProcess process) -> SBExecutionContext
        __init__(SBExecutionContext self, SBThread thread) -> SBExecutionContext
        __init__(SBExecutionContext self, SBFrame frame) -> SBExecutionContext
        """
        ...
    
    __swig_destroy__ = ...
    def GetTarget(self):
        r"""GetTarget(SBExecutionContext self) -> SBTarget"""
        ...
    
    def GetProcess(self):
        r"""GetProcess(SBExecutionContext self) -> SBProcess"""
        ...
    
    def GetThread(self):
        r"""GetThread(SBExecutionContext self) -> SBThread"""
        ...
    
    def GetFrame(self):
        r"""GetFrame(SBExecutionContext self) -> SBFrame"""
        ...
    
    target = ...
    process = ...
    thread = ...
    frame = ...


class SBExpressionOptions:
    r"""A container for options to use when evaluating expressions."""
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBExpressionOptions self) -> SBExpressionOptions
        __init__(SBExpressionOptions self, SBExpressionOptions rhs) -> SBExpressionOptions
        """
        ...
    
    __swig_destroy__ = ...
    def GetCoerceResultToId(self):
        r"""GetCoerceResultToId(SBExpressionOptions self) -> bool"""
        ...
    
    def SetCoerceResultToId(self, coerce=...):
        r"""
        SetCoerceResultToId(SBExpressionOptions self, bool coerce=True)
        Sets whether to coerce the expression result to ObjC id type after evaluation.
        """
        ...
    
    def GetUnwindOnError(self):
        r"""GetUnwindOnError(SBExpressionOptions self) -> bool"""
        ...
    
    def SetUnwindOnError(self, unwind=...):
        r"""
        SetUnwindOnError(SBExpressionOptions self, bool unwind=True)
        Sets whether to unwind the expression stack on error.
        """
        ...
    
    def GetIgnoreBreakpoints(self):
        r"""GetIgnoreBreakpoints(SBExpressionOptions self) -> bool"""
        ...
    
    def SetIgnoreBreakpoints(self, ignore=...):
        r"""
        SetIgnoreBreakpoints(SBExpressionOptions self, bool ignore=True)
        Sets whether to ignore breakpoint hits while running expressions.
        """
        ...
    
    def GetFetchDynamicValue(self):
        r"""GetFetchDynamicValue(SBExpressionOptions self) -> lldb::DynamicValueType"""
        ...
    
    def SetFetchDynamicValue(self, *args):
        r"""
        SetFetchDynamicValue(SBExpressionOptions self, lldb::DynamicValueType dynamic=eDynamicCanRunTarget)
        Sets whether to cast the expression result to its dynamic type.
        """
        ...
    
    def GetTimeoutInMicroSeconds(self):
        r"""GetTimeoutInMicroSeconds(SBExpressionOptions self) -> uint32_t"""
        ...
    
    def SetTimeoutInMicroSeconds(self, timeout=...):
        r"""
        SetTimeoutInMicroSeconds(SBExpressionOptions self, uint32_t timeout=0)
        Sets the timeout in microseconds to run the expression for. If try all threads is set to true and the expression doesn't complete within the specified timeout, all threads will be resumed for the same timeout to see if the expression will finish.
        """
        ...
    
    def GetOneThreadTimeoutInMicroSeconds(self):
        r"""GetOneThreadTimeoutInMicroSeconds(SBExpressionOptions self) -> uint32_t"""
        ...
    
    def SetOneThreadTimeoutInMicroSeconds(self, timeout=...):
        r"""
        SetOneThreadTimeoutInMicroSeconds(SBExpressionOptions self, uint32_t timeout=0)
        Sets the timeout in microseconds to run the expression on one thread before either timing out or trying all threads.
        """
        ...
    
    def GetTryAllThreads(self):
        r"""GetTryAllThreads(SBExpressionOptions self) -> bool"""
        ...
    
    def SetTryAllThreads(self, run_others=...):
        r"""
        SetTryAllThreads(SBExpressionOptions self, bool run_others=True)
        Sets whether to run all threads if the expression does not complete on one thread.
        """
        ...
    
    def GetStopOthers(self):
        r"""GetStopOthers(SBExpressionOptions self) -> bool"""
        ...
    
    def SetStopOthers(self, stop_others=...):
        r"""
        SetStopOthers(SBExpressionOptions self, bool stop_others=True)
        Sets whether to stop other threads at all while running expressions.  If false, TryAllThreads does nothing.
        """
        ...
    
    def GetTrapExceptions(self):
        r"""GetTrapExceptions(SBExpressionOptions self) -> bool"""
        ...
    
    def SetTrapExceptions(self, trap_exceptions=...):
        r"""
        SetTrapExceptions(SBExpressionOptions self, bool trap_exceptions=True)
        Sets whether to abort expression evaluation if an exception is thrown while executing.  Don't set this to false unless you know the function you are calling traps all exceptions itself.
        """
        ...
    
    def SetLanguage(self, language):
        r"""
        SetLanguage(SBExpressionOptions self, lldb::LanguageType language)
        Sets the language that LLDB should assume the expression is written in
        """
        ...
    
    def GetPlaygroundTransformEnabled(self):
        r"""GetPlaygroundTransformEnabled(SBExpressionOptions self) -> bool"""
        ...
    
    def SetPlaygroundTransformEnabled(self, enable_playground_transform=...):
        r"""SetPlaygroundTransformEnabled(SBExpressionOptions self, bool enable_playground_transform=True)"""
        ...
    
    def GetPlaygroundTransformHighPerformance(self):
        r"""GetPlaygroundTransformHighPerformance(SBExpressionOptions self) -> bool"""
        ...
    
    def SetPlaygroundTransformHighPerformance(self, playground_transforms_hp=...):
        r"""SetPlaygroundTransformHighPerformance(SBExpressionOptions self, bool playground_transforms_hp=True)"""
        ...
    
    def GetREPLMode(self):
        r"""GetREPLMode(SBExpressionOptions self) -> bool"""
        ...
    
    def SetREPLMode(self, enable_repl_mode=...):
        r"""SetREPLMode(SBExpressionOptions self, bool enable_repl_mode=True)"""
        ...
    
    def GetGenerateDebugInfo(self):
        r"""GetGenerateDebugInfo(SBExpressionOptions self) -> bool"""
        ...
    
    def SetGenerateDebugInfo(self, b=...):
        r"""
        SetGenerateDebugInfo(SBExpressionOptions self, bool b=True)
        Sets whether to generate debug information for the expression and also controls if a SBModule is generated.
        """
        ...
    
    def GetSuppressPersistentResult(self):
        r"""GetSuppressPersistentResult(SBExpressionOptions self) -> bool"""
        ...
    
    def SetSuppressPersistentResult(self, b=...):
        r"""
        SetSuppressPersistentResult(SBExpressionOptions self, bool b=False)
        Sets whether to produce a persistent result that can be used in future expressions.
        """
        ...
    
    def GetPrefix(self):
        r"""
        GetPrefix(SBExpressionOptions self) -> char const *
        Gets the prefix to use for this expression.
        """
        ...
    
    def SetPrefix(self, prefix):
        r"""
        SetPrefix(SBExpressionOptions self, char const * prefix)
        Sets the prefix to use for this expression. This prefix gets inserted after the 'target.expr-prefix' prefix contents, but before the wrapped expression function body.
        """
        ...
    
    def SetAutoApplyFixIts(self, b=...):
        r"""
        SetAutoApplyFixIts(SBExpressionOptions self, bool b=True)
        Sets whether to auto-apply fix-it hints to the expression being evaluated.
        """
        ...
    
    def GetAutoApplyFixIts(self):
        r"""
        GetAutoApplyFixIts(SBExpressionOptions self) -> bool
        Gets whether to auto-apply fix-it hints to an expression.
        """
        ...
    
    def SetRetriesWithFixIts(self, retries):
        r"""
        SetRetriesWithFixIts(SBExpressionOptions self, uint64_t retries)
        Sets how often LLDB should retry applying fix-its to an expression.
        """
        ...
    
    def GetRetriesWithFixIts(self):
        r"""
        GetRetriesWithFixIts(SBExpressionOptions self) -> uint64_t
        Gets how often LLDB will retry applying fix-its to an expression.
        """
        ...
    
    def GetTopLevel(self):
        r"""GetTopLevel(SBExpressionOptions self) -> bool"""
        ...
    
    def SetTopLevel(self, b=...):
        r"""SetTopLevel(SBExpressionOptions self, bool b=True)"""
        ...
    
    def GetAllowJIT(self):
        r"""
        GetAllowJIT(SBExpressionOptions self) -> bool
        Gets whether to JIT an expression if it cannot be interpreted.
        """
        ...
    
    def SetAllowJIT(self, allow):
        r"""
        SetAllowJIT(SBExpressionOptions self, bool allow)
        Sets whether to JIT an expression if it cannot be interpreted.
        """
        ...
    


class SBFile:
    r"""Represents a file."""
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBFile self) -> SBFile
        __init__(SBFile self, lldb::FileSP file_sp) -> SBFile
        __init__(SBFile self, int fd, char const * mode, bool transfer_ownership) -> SBFile
        initialize a SBFile from a python file object
        """
        ...
    
    __swig_destroy__ = ...
    def Read(self, buf):
        r"""Read(buffer) -> SBError, bytes_read"""
        ...
    
    def Write(self, buf):
        r"""Write(buffer) -> SBError, written_read"""
        ...
    
    def Flush(self):
        r"""Flush(SBFile self) -> SBError"""
        ...
    
    def IsValid(self):
        r"""IsValid(SBFile self) -> bool"""
        ...
    
    def Close(self):
        r"""Close(SBFile self) -> SBError"""
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def GetFile(self):
        r"""
        GetFile(SBFile self) -> lldb::FileSP

            Convert this SBFile into a python io.IOBase file object.

            If the SBFile is itself a wrapper around a python file object,
            this will return that original object.

            The file returned from here should be considered borrowed,
            in the sense that you may read and write to it, and flush it,
            etc, but you should not close it.   If you want to close the
            SBFile, call SBFile.Close().

            If there is no underlying python file to unwrap, GetFile will
            use the file descriptor, if available to create a new python
            file object using ``open(fd, mode=..., closefd=False)``

        """
        ...
    
    @staticmethod
    def MakeBorrowed(BORROWED):
        r"""MakeBorrowed(lldb::FileSP BORROWED) -> SBFile"""
        ...
    
    @staticmethod
    def MakeForcingIOMethods(FORCE_IO_METHODS):
        r"""MakeForcingIOMethods(lldb::FileSP FORCE_IO_METHODS) -> SBFile"""
        ...
    
    @staticmethod
    def MakeBorrowedForcingIOMethods(BORROWED_FORCE_IO_METHODS):
        r"""MakeBorrowedForcingIOMethods(lldb::FileSP BORROWED_FORCE_IO_METHODS) -> SBFile"""
        ...
    
    @classmethod
    def Create(cls, file, borrow=..., force_io_methods=...): # -> Self:
        """
        Create a SBFile from a python file object, with options.

        If borrow is set then the underlying file will
        not be closed when the SBFile is closed or destroyed.

        If force_scripting_io is set then the python read/write
        methods will be called even if a file descriptor is available.
        """
        ...
    


class SBFileSpec:
    r"""
    Represents a file specification that divides the path into a directory and
    basename.  The string values of the paths are put into uniqued string pools
    for fast comparisons and efficient memory usage.

    For example, the following code ::

            lineEntry = context.GetLineEntry()
            self.expect(lineEntry.GetFileSpec().GetDirectory(), 'The line entry should have the correct directory',
                        exe=False,
                substrs = [self.mydir])
            self.expect(lineEntry.GetFileSpec().GetFilename(), 'The line entry should have the correct filename',
                        exe=False,
                substrs = ['main.c'])
            self.assertTrue(lineEntry.GetLine() == self.line,
                            'The line entry's line number should match ')

    gets the line entry from the symbol context when a thread is stopped.
    It gets the file spec corresponding to the line entry and checks that
    the filename and the directory matches what we expect.
    """
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBFileSpec self) -> SBFileSpec
        __init__(SBFileSpec self, SBFileSpec rhs) -> SBFileSpec
        __init__(SBFileSpec self, char const * path) -> SBFileSpec
        __init__(SBFileSpec self, char const * path, bool resolve) -> SBFileSpec
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBFileSpec self, SBFileSpec rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBFileSpec self, SBFileSpec rhs) -> bool"""
        ...
    
    def IsValid(self):
        r"""IsValid(SBFileSpec self) -> bool"""
        ...
    
    def Exists(self):
        r"""Exists(SBFileSpec self) -> bool"""
        ...
    
    def ResolveExecutableLocation(self):
        r"""ResolveExecutableLocation(SBFileSpec self) -> bool"""
        ...
    
    def GetFilename(self):
        r"""GetFilename(SBFileSpec self) -> char const *"""
        ...
    
    def GetDirectory(self):
        r"""GetDirectory(SBFileSpec self) -> char const *"""
        ...
    
    def SetFilename(self, filename):
        r"""SetFilename(SBFileSpec self, char const * filename)"""
        ...
    
    def SetDirectory(self, directory):
        r"""SetDirectory(SBFileSpec self, char const * directory)"""
        ...
    
    def GetPath(self, dst_path, dst_len):
        r"""GetPath(SBFileSpec self, char * dst_path, size_t dst_len) -> uint32_t"""
        ...
    
    @staticmethod
    def ResolvePath(src_path, dst_path, dst_len):
        r"""ResolvePath(char const * src_path, char * dst_path, size_t dst_len) -> int"""
        ...
    
    def GetDescription(self, description):
        r"""GetDescription(SBFileSpec self, SBStream description) -> bool"""
        ...
    
    def AppendPathComponent(self, file_or_directory):
        r"""AppendPathComponent(SBFileSpec self, char const * file_or_directory)"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBFileSpec self) -> std::string"""
        ...
    
    fullpath = ...
    basename = ...
    dirname = ...
    exists = ...


class SBFileSpecList:
    r"""Represents a list of :py:class:`SBFileSpec`."""
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBFileSpecList self) -> SBFileSpecList
        __init__(SBFileSpecList self, SBFileSpecList rhs) -> SBFileSpecList
        """
        ...
    
    __swig_destroy__ = ...
    def GetSize(self):
        r"""GetSize(SBFileSpecList self) -> uint32_t"""
        ...
    
    def GetDescription(self, description):
        r"""GetDescription(SBFileSpecList self, SBStream description) -> bool"""
        ...
    
    def Append(self, sb_file):
        r"""Append(SBFileSpecList self, SBFileSpec sb_file)"""
        ...
    
    def AppendIfUnique(self, sb_file):
        r"""AppendIfUnique(SBFileSpecList self, SBFileSpec sb_file) -> bool"""
        ...
    
    def Clear(self):
        r"""Clear(SBFileSpecList self)"""
        ...
    
    def FindFileIndex(self, idx, sb_file, full):
        r"""FindFileIndex(SBFileSpecList self, uint32_t idx, SBFileSpec sb_file, bool full) -> uint32_t"""
        ...
    
    def GetFileSpecAtIndex(self, idx):
        r"""GetFileSpecAtIndex(SBFileSpecList self, uint32_t idx) -> SBFileSpec"""
        ...


# noinspection PyPep8Naming
class SBFrame:
    r"""
    Represents one of the stack frames associated with a thread.

    SBThread contains SBFrame(s). For example (from test/lldbutil.py), ::

        def print_stacktrace(thread, string_buffer = False):
            '''Prints a simple stack trace of this thread.'''

            ...

            for i in range(depth):
                frame = thread.GetFrameAtIndex(i)
                function = frame.GetFunction()

                load_addr = addrs[i].GetLoadAddress(target)
                if not function:
                    file_addr = addrs[i].GetFileAddress()
                    start_addr = frame.GetSymbol().GetStartAddress().GetFileAddress()
                    symbol_offset = file_addr - start_addr
                    print >> output, '  frame #{num}: {addr:#016x} {mod}`{symbol} + {offset}'.format(
                        num=i, addr=load_addr, mod=mods[i], symbol=symbols[i], offset=symbol_offset)
                else:
                    print >> output, '  frame #{num}: {addr:#016x} {mod}`{func} at {file}:{line} {args}'.format(
                        num=i, addr=load_addr, mod=mods[i],
                        func='%s [inlined]' % funcs[i] if frame.IsInlined() else funcs[i],
                        file=files[i], line=lines[i],
                        args=get_args_as_string(frame, showFuncName=False) if not frame.IsInlined() else '()')

            ...

    And, ::

        for frame in thread:
            print frame

    See also SBThread.
    """
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBFrame self) -> SBFrame
        __init__(SBFrame self, SBFrame rhs) -> SBFrame
        """
        ...
    
    __swig_destroy__ = ...
    def IsEqual(self, that) -> bool:
        r"""IsEqual(SBFrame self, SBFrame that) -> bool"""
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self) -> bool:
        r"""IsValid(SBFrame self) -> bool"""
        ...
    
    def GetFrameID(self) -> int:
        r"""GetFrameID(SBFrame self) -> uint32_t"""
        ...
    
    def GetCFA(self) -> int:
        r"""
        GetCFA(SBFrame self) -> lldb::addr_t

            Get the Canonical Frame Address for this stack frame.
            This is the DWARF standard's definition of a CFA, a stack address
            that remains constant throughout the lifetime of the function.
            Returns an lldb::addr_t stack address, or LLDB_INVALID_ADDRESS if
            the CFA cannot be determined.
        """
        ...
    
    def GetPC(self) -> int:
        r"""GetPC(SBFrame self) -> lldb::addr_t"""
        ...
    
    def SetPC(self, new_pc: int) -> bool:
        r"""SetPC(SBFrame self, lldb::addr_t new_pc) -> bool"""
        ...
    
    def GetSP(self) -> int:
        r"""GetSP(SBFrame self) -> lldb::addr_t"""
        ...
    
    def GetFP(self) -> int:
        r"""GetFP(SBFrame self) -> lldb::addr_t"""
        ...
    
    def GetPCAddress(self) -> SBAddress:
        r"""GetPCAddress(SBFrame self) -> SBAddress"""
        ...
    
    def GetSymbolContext(self, resolve_scope: int) -> SBSymbolContext:
        r"""GetSymbolContext(SBFrame self, uint32_t resolve_scope) -> SBSymbolContext"""
        ...
    
    def GetModule(self) -> SBModule:
        r"""GetModule(SBFrame self) -> SBModule"""
        ...
    
    def GetCompileUnit(self) -> SBCompileUnit:
        r"""GetCompileUnit(SBFrame self) -> SBCompileUnit"""
        ...
    
    def GetFunction(self) -> SBFunction:
        r"""GetFunction(SBFrame self) -> SBFunction"""
        ...
    
    def GetSymbol(self) -> SBSymbol:
        r"""GetSymbol(SBFrame self) -> SBSymbol"""
        ...
    
    def GetBlock(self) -> SBBlock:
        r"""
        GetBlock(SBFrame self) -> SBBlock

            Gets the deepest block that contains the frame PC.

            See also GetFrameBlock().
        """
        ...
    
    def GetDisplayFunctionName(self) -> str:
        r"""GetDisplayFunctionName(SBFrame self) -> char const *"""
        ...
    
    def GetFunctionName(self, *args) -> str:
        r"""
        GetFunctionName(SBFrame self) -> char const
        GetFunctionName(SBFrame self) -> char const *

            Get the appropriate function name for this frame. Inlined functions in
            LLDB are represented by Blocks that have inlined function information, so
            just looking at the SBFunction or SBSymbol for a frame isn't enough.
            This function will return the appropriate function, symbol or inlined
            function name for the frame.

            This function returns:
            - the name of the inlined function (if there is one)
            - the name of the concrete function (if there is one)
            - the name of the symbol (if there is one)
            - NULL

            See also IsInlined().
        """
        ...
    
    def GuessLanguage(self):
        r"""
        GuessLanguage(SBFrame self) -> lldb::LanguageType

            Returns the language of the frame's SBFunction, or if there.
            is no SBFunction, guess the language from the mangled name.
            .
        """
        ...
    
    def IsSwiftThunk(self) -> bool:
        r"""IsSwiftThunk(SBFrame self) -> bool"""
        ...
    
    def GetLanguageSpecificData(self) -> SBStructuredData:
        r"""GetLanguageSpecificData(SBFrame self) -> SBStructuredData"""
        ...
    
    def IsInlined(self, *args) -> bool:
        r"""
        IsInlined(SBFrame self) -> bool
        IsInlined(SBFrame self) -> bool

            Return true if this frame represents an inlined function.

            See also GetFunctionName().
        """
        ...
    
    def IsArtificial(self, *args) -> bool:
        r"""
        IsArtificial(SBFrame self) -> bool
        IsArtificial(SBFrame self) -> bool

            Return true if this frame is artificial (e.g a frame synthesized to
            capture a tail call). Local variables may not be available in an artificial
            frame.
        """
        ...
    
    def EvaluateExpression(self, *args) -> SBValue:
        r"""
        EvaluateExpression(SBFrame self, char const * expr) -> SBValue
        EvaluateExpression(SBFrame self, char const * expr, lldb::DynamicValueType use_dynamic) -> SBValue
        EvaluateExpression(SBFrame self, char const * expr, lldb::DynamicValueType use_dynamic, bool unwind_on_error) -> SBValue
        EvaluateExpression(SBFrame self, char const * expr, SBExpressionOptions options) -> SBValue

            The version that doesn't supply a 'use_dynamic' value will use the
            target's default.
        """
        ...
    
    def GetFrameBlock(self) -> SBBlock:
        r"""
        GetFrameBlock(SBFrame self) -> SBBlock

            Gets the lexical block that defines the stack frame. Another way to think
            of this is it will return the block that contains all of the variables
            for a stack frame. Inlined functions are represented as SBBlock objects
            that have inlined function information: the name of the inlined function,
            where it was called from. The block that is returned will be the first
            block at or above the block for the PC (SBFrame::GetBlock()) that defines
            the scope of the frame. When a function contains no inlined functions,
            this will be the top most lexical block that defines the function.
            When a function has inlined functions and the PC is currently
            in one of those inlined functions, this method will return the inlined
            block that defines this frame. If the PC isn't currently in an inlined
            function, the lexical block that defines the function is returned.
        """
        ...
    
    def GetLineEntry(self) -> SBLineEntry:
        r"""GetLineEntry(SBFrame self) -> SBLineEntry"""
        ...
    
    def GetThread(self) -> SBThread:
        r"""GetThread(SBFrame self) -> SBThread"""
        ...
    
    def Disassemble(self) -> str:
        r"""Disassemble(SBFrame self) -> char const *"""
        ...
    
    def Clear(self):
        r"""Clear(SBFrame self)"""
        ...
    
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBFrame self, SBFrame rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBFrame self, SBFrame rhs) -> bool"""
        ...
    
    def GetVariables(self, *args) -> SBValueList:
        r"""
        GetVariables(SBFrame self, bool arguments, bool locals, bool statics, bool in_scope_only) -> SBValueList
        GetVariables(SBFrame self, bool arguments, bool locals, bool statics, bool in_scope_only, lldb::DynamicValueType use_dynamic) -> SBValueList
        GetVariables(SBFrame self, SBVariablesOptions options) -> SBValueList

            The version that doesn't supply a 'use_dynamic' value will use the
            target's default.
        """
        ...
    
    def GetRegisters(self) -> SBValueList:
        r"""GetRegisters(SBFrame self) -> SBValueList"""
        ...
    
    def FindRegister(self, name: str) -> SBValue:
        r"""FindRegister(SBFrame self, char const * name) -> SBValue"""
        ...
    
    def FindVariable(self, *args) -> SBValue:
        r"""
        FindVariable(SBFrame self, char const * var_name) -> SBValue
        FindVariable(SBFrame self, char const * var_name, lldb::DynamicValueType use_dynamic) -> SBValue

            The version that doesn't supply a 'use_dynamic' value will use the
            target's default.
        """
        ...
    
    def GetValueForVariablePath(self, *args) -> SBValue:
        r"""
        GetValueForVariablePath(SBFrame self, char const * var_expr_cstr, lldb::DynamicValueType use_dynamic) -> SBValue
        GetValueForVariablePath(SBFrame self, char const * var_path) -> SBValue

            Get a lldb.SBValue for a variable path.

            Variable paths can include access to pointer or instance members: ::

                rect_ptr->origin.y
                pt.x

            Pointer dereferences: ::

                *this->foo_ptr
                **argv

            Address of: ::

                &pt
                &my_array[3].x

            Array accesses and treating pointers as arrays: ::

                int_array[1]
                pt_ptr[22].x

            Unlike `EvaluateExpression()` which returns :py:class:`SBValue` objects
            with constant copies of the values at the time of evaluation,
            the result of this function is a value that will continue to
            track the current value of the value as execution progresses
            in the current frame.
        """
        ...
    
    def FindValue(self, *args) -> SBValue:
        r"""
        FindValue(SBFrame self, char const * name, lldb::ValueType value_type) -> SBValue
        FindValue(SBFrame self, char const * name, lldb::ValueType value_type, lldb::DynamicValueType use_dynamic) -> SBValue

            Find variables, register sets, registers, or persistent variables using
            the frame as the scope.

            The version that doesn't supply a ``use_dynamic`` value will use the
            target's default.
        """
        ...
    
    def GetDescription(self, description) -> bool:
        r"""GetDescription(SBFrame self, SBStream description) -> bool"""
        ...
    
    def __repr__(self) -> str:
        r"""__repr__(SBFrame self) -> std::string"""
        ...
    
    def get_all_variables(self):
        ...
    
    def get_parent_frame(self): # -> Any | SBFrame:
        ...
    
    def get_arguments(self):
        ...
    
    def get_locals(self):
        ...
    
    def get_statics(self):
        ...
    
    def var(self, var_expr_path):
        '''Calls through to lldb.SBFrame.GetValueForVariablePath() and returns
        a value that represents the variable expression path'''
        ...
    
    def get_registers_access(self): # -> registers_access:
        class registers_access:
            '''A helper object that exposes a flattened view of registers, masking away the notion of register sets for easy scripting.'''
            ...
        
        
    
    pc: int = ...
    addr: SBAddress = ...
    fp: int = ...
    sp: int = ...
    module: SBModule = ...
    compile_unit: SBCompileUnit = ...
    function: SBFunction = ...
    symbol: SBSymbol = ...
    block: SBBlock = ...
    is_inlined: bool = ...
    name: str = ...
    line_entry: SBLineEntry = ...
    thread: SBThread = ...
    disassembly: str = ...
    idx: int = ...
    variables: SBValueList = ...
    vars: SBValueList = ...
    locals: SBValueList = ...
    args: SBValueList = ...
    arguments: SBValueList = ...
    statics: SBValueList = ...
    registers: SBValueList = ...
    regs: SBValueList = ...
    register = ...
    reg = ...
    parent: SBFrame = ...


class SBFunction:
    r"""
    Represents a generic function, which can be inlined or not.

    For example (from test/lldbutil.py, but slightly modified for doc purpose),::

            ...

            frame = thread.GetFrameAtIndex(i)
            addr = frame.GetPCAddress()
            load_addr = addr.GetLoadAddress(target)
            function = frame.GetFunction()
            mod_name = frame.GetModule().GetFileSpec().GetFilename()

            if not function:
                # No debug info for 'function'.
                symbol = frame.GetSymbol()
                file_addr = addr.GetFileAddress()
                start_addr = symbol.GetStartAddress().GetFileAddress()
                symbol_name = symbol.GetName()
                symbol_offset = file_addr - start_addr
                print >> output, '  frame #{num}: {addr:#016x} {mod}`{symbol} + {offset}'.format(
                    num=i, addr=load_addr, mod=mod_name, symbol=symbol_name, offset=symbol_offset)
            else:
                # Debug info is available for 'function'.
                func_name = frame.GetFunctionName()
                file_name = frame.GetLineEntry().GetFileSpec().GetFilename()
                line_num = frame.GetLineEntry().GetLine()
                print >> output, '  frame #{num}: {addr:#016x} {mod}`{func} at {file}:{line} {args}'.format(
                    num=i, addr=load_addr, mod=mod_name,
                    func='%s [inlined]' % func_name] if frame.IsInlined() else func_name,
                    file=file_name, line=line_num, args=get_args_as_string(frame, showFuncName=False))

            ...
    """
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBFunction self) -> SBFunction
        __init__(SBFunction self, SBFunction rhs) -> SBFunction
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBFunction self) -> bool"""
        ...
    
    def GetName(self):
        r"""GetName(SBFunction self) -> char const *"""
        ...
    
    def GetDisplayName(self):
        r"""GetDisplayName(SBFunction self) -> char const *"""
        ...
    
    def GetMangledName(self):
        r"""GetMangledName(SBFunction self) -> char const *"""
        ...
    
    def GetInstructions(self, *args):
        r"""
        GetInstructions(SBFunction self, SBTarget target) -> SBInstructionList
        GetInstructions(SBFunction self, SBTarget target, char const * flavor) -> SBInstructionList
        """
        ...
    
    def GetStartAddress(self):
        r"""GetStartAddress(SBFunction self) -> SBAddress"""
        ...
    
    def GetEndAddress(self):
        r"""GetEndAddress(SBFunction self) -> SBAddress"""
        ...
    
    def GetArgumentName(self, arg_idx):
        r"""GetArgumentName(SBFunction self, uint32_t arg_idx) -> char const *"""
        ...
    
    def GetPrologueByteSize(self):
        r"""GetPrologueByteSize(SBFunction self) -> uint32_t"""
        ...
    
    def GetType(self):
        r"""GetType(SBFunction self) -> SBType"""
        ...
    
    def GetBlock(self):
        r"""GetBlock(SBFunction self) -> SBBlock"""
        ...
    
    def GetLanguage(self):
        r"""GetLanguage(SBFunction self) -> lldb::LanguageType"""
        ...
    
    def GetIsOptimized(self):
        r"""
        GetIsOptimized(SBFunction self) -> bool

            Returns true if the function was compiled with optimization.
            Optimization, in this case, is meant to indicate that the debugger
            experience may be confusing for the user -- variables optimized away,
            stepping jumping between source lines -- and the driver may want to
            provide some guidance to the user about this.
            Returns false if unoptimized, or unknown.
        """
        ...
    
    def GetCanThrow(self):
        r"""GetCanThrow(SBFunction self) -> bool"""
        ...
    
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBFunction self, SBFunction rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBFunction self, SBFunction rhs) -> bool"""
        ...
    
    def GetDescription(self, description):
        r"""GetDescription(SBFunction self, SBStream description) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBFunction self) -> std::string"""
        ...
    
    def get_instructions_from_current_target(self):
        ...
    
    addr = ...
    end_addr = ...
    block = ...
    instructions = ...
    mangled = ...
    name = ...
    prologue_size = ...
    type = ...
    def __eq__(self, rhs) -> bool:
        ...
    
    def __ne__(self, rhs) -> bool:
        ...
    


class SBHostOS:
    r"""Provides information about the host system."""
    thisown = ...
    __repr__ = ...
    @staticmethod
    def GetProgramFileSpec():
        r"""GetProgramFileSpec() -> SBFileSpec"""
        ...
    
    @staticmethod
    def GetLLDBPythonPath():
        r"""GetLLDBPythonPath() -> SBFileSpec"""
        ...
    
    @staticmethod
    def GetLLDBPath(path_type):
        r"""GetLLDBPath(lldb::PathType path_type) -> SBFileSpec"""
        ...
    
    @staticmethod
    def GetUserHomeDirectory():
        r"""GetUserHomeDirectory() -> SBFileSpec"""
        ...
    
    @staticmethod
    def ThreadCreated(name):
        r"""ThreadCreated(char const * name)"""
        ...
    
    @staticmethod
    def ThreadCreate(name, thread_function, thread_arg, err):
        r"""ThreadCreate(char const * name, lldb::thread_func_t thread_function, void * thread_arg, SBError err) -> lldb::thread_t"""
        ...
    
    @staticmethod
    def ThreadCancel(thread, err):
        r"""ThreadCancel(lldb::thread_t thread, SBError err) -> bool"""
        ...
    
    @staticmethod
    def ThreadDetach(thread, err):
        r"""ThreadDetach(lldb::thread_t thread, SBError err) -> bool"""
        ...
    
    @staticmethod
    def ThreadJoin(thread, result, err):
        r"""ThreadJoin(lldb::thread_t thread, lldb::thread_result_t * result, SBError err) -> bool"""
        ...
    
    def __init__(self) -> None:
        r"""__init__(SBHostOS self) -> SBHostOS"""
        ...
    
    __swig_destroy__ = ...


class SBInstruction:
    r"""Represents a (machine language) instruction."""
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBInstruction self) -> SBInstruction
        __init__(SBInstruction self, SBInstruction rhs) -> SBInstruction
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBInstruction self) -> bool"""
        ...
    
    def GetAddress(self):
        r"""GetAddress(SBInstruction self) -> SBAddress"""
        ...
    
    def GetMnemonic(self, target):
        r"""GetMnemonic(SBInstruction self, SBTarget target) -> char const *"""
        ...
    
    def GetOperands(self, target) -> string:
        r"""GetOperands(SBInstruction self, SBTarget target) -> char const *"""
        ...
    
    def GetComment(self, target):
        r"""GetComment(SBInstruction self, SBTarget target) -> char const *"""
        ...
    
    def GetControlFlowKind(self, target):
        r"""GetControlFlowKind(SBInstruction self, SBTarget target) -> lldb::InstructionControlFlowKind"""
        ...
    
    def GetData(self, target):
        r"""GetData(SBInstruction self, SBTarget target) -> SBData"""
        ...
    
    def GetByteSize(self):
        r"""GetByteSize(SBInstruction self) -> size_t"""
        ...
    
    def DoesBranch(self):
        r"""DoesBranch(SBInstruction self) -> bool"""
        ...
    
    def HasDelaySlot(self):
        r"""HasDelaySlot(SBInstruction self) -> bool"""
        ...
    
    def CanSetBreakpoint(self):
        r"""CanSetBreakpoint(SBInstruction self) -> bool"""
        ...
    
    def Print(self, *args):
        r"""
        Print(SBInstruction self, SBFile out)
        Print(SBInstruction self, lldb::FileSP BORROWED)
        """
        ...
    
    def GetDescription(self, description):
        r"""GetDescription(SBInstruction self, SBStream description) -> bool"""
        ...
    
    def EmulateWithFrame(self, frame, evaluate_options):
        r"""EmulateWithFrame(SBInstruction self, SBFrame frame, uint32_t evaluate_options) -> bool"""
        ...
    
    def DumpEmulation(self, triple):
        r"""DumpEmulation(SBInstruction self, char const * triple) -> bool"""
        ...
    
    def TestEmulation(self, output_stream, test_file):
        r"""TestEmulation(SBInstruction self, SBStream output_stream, char const * test_file) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBInstruction self) -> std::string"""
        ...
    
    def __mnemonic_property__(self):
        ...
    
    def __operands_property__(self):
        ...
    
    def __comment_property__(self):
        ...
    
    def __file_addr_property__(self):
        ...
    
    def __load_adrr_property__(self):
        ...
    
    mnemonic = ...
    operands = ...
    comment = ...
    addr = ...
    size = ...
    is_branch = ...


class SBInstructionList:
    r"""
    Represents a list of machine instructions.  SBFunction and SBSymbol have
    GetInstructions() methods which return SBInstructionList instances.

    SBInstructionList supports instruction (:py:class:`SBInstruction` instance) iteration.
    For example (see also :py:class:`SBDebugger` for a more complete example), ::

        def disassemble_instructions (insts):
            for i in insts:
                print i

    defines a function which takes an SBInstructionList instance and prints out
    the machine instructions in assembly format.
    """
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBInstructionList self) -> SBInstructionList
        __init__(SBInstructionList self, SBInstructionList rhs) -> SBInstructionList
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBInstructionList self) -> bool"""
        ...
    
    def GetSize(self):
        r"""GetSize(SBInstructionList self) -> size_t"""
        ...
    
    def GetInstructionAtIndex(self, idx):
        r"""GetInstructionAtIndex(SBInstructionList self, uint32_t idx) -> SBInstruction"""
        ...
    
    def GetInstructionsCount(self, start, end, canSetBreakpoint=...):
        r"""GetInstructionsCount(SBInstructionList self, SBAddress start, SBAddress end, bool canSetBreakpoint=False) -> size_t"""
        ...
    
    def Clear(self):
        r"""Clear(SBInstructionList self)"""
        ...
    
    def AppendInstruction(self, inst):
        r"""AppendInstruction(SBInstructionList self, SBInstruction inst)"""
        ...
    
    def Print(self, *args):
        r"""
        Print(SBInstructionList self, SBFile out)
        Print(SBInstructionList self, lldb::FileSP BORROWED)
        """
        ...
    
    def GetDescription(self, description):
        r"""GetDescription(SBInstructionList self, SBStream description) -> bool"""
        ...
    
    def DumpEmulationForAllInstructions(self, triple):
        r"""DumpEmulationForAllInstructions(SBInstructionList self, char const * triple) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBInstructionList self) -> std::string"""
        ...
    
    def __iter__(self) -> Iterator[SBInstruction]: # -> Generator[Any, Any, None]:
        '''Iterate over all instructions in a lldb.SBInstructionList
        object.'''
        ...
    
    def __len__(self): # -> int:
        '''Access len of the instruction list.'''
        ...
    
    def __getitem__(self, key) -> SBInstruction:
        '''Access instructions by integer index for array access or by lldb.SBAddress to find an instruction that matches a section offset address object.'''
        ...
    


class SBLanguageRuntime:
    r"""Utility functions for :ref:`LanguageType`"""
    thisown = ...
    __repr__ = ...
    @staticmethod
    def GetLanguageTypeFromString(string):
        r"""GetLanguageTypeFromString(char const * string) -> lldb::LanguageType"""
        ...
    
    @staticmethod
    def GetNameForLanguageType(language):
        r"""GetNameForLanguageType(lldb::LanguageType language) -> char const *"""
        ...
    
    def __init__(self) -> None:
        r"""__init__(SBLanguageRuntime self) -> SBLanguageRuntime"""
        ...
    
    __swig_destroy__ = ...


class SBLaunchInfo:
    r"""Describes how a target or program should be launched."""
    thisown = ...
    __repr__ = ...
    __swig_destroy__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBLaunchInfo self, char const ** argv) -> SBLaunchInfo
        __init__(SBLaunchInfo self, SBLaunchInfo rhs) -> SBLaunchInfo
        """
        ...
    
    def GetProcessID(self):
        r"""GetProcessID(SBLaunchInfo self) -> lldb::pid_t"""
        ...
    
    def GetUserID(self):
        r"""GetUserID(SBLaunchInfo self) -> uint32_t"""
        ...
    
    def GetGroupID(self):
        r"""GetGroupID(SBLaunchInfo self) -> uint32_t"""
        ...
    
    def UserIDIsValid(self):
        r"""UserIDIsValid(SBLaunchInfo self) -> bool"""
        ...
    
    def GroupIDIsValid(self):
        r"""GroupIDIsValid(SBLaunchInfo self) -> bool"""
        ...
    
    def SetUserID(self, uid):
        r"""SetUserID(SBLaunchInfo self, uint32_t uid)"""
        ...
    
    def SetGroupID(self, gid):
        r"""SetGroupID(SBLaunchInfo self, uint32_t gid)"""
        ...
    
    def GetExecutableFile(self):
        r"""GetExecutableFile(SBLaunchInfo self) -> SBFileSpec"""
        ...
    
    def SetExecutableFile(self, exe_file, add_as_first_arg):
        r"""SetExecutableFile(SBLaunchInfo self, SBFileSpec exe_file, bool add_as_first_arg)"""
        ...
    
    def GetListener(self):
        r"""GetListener(SBLaunchInfo self) -> SBListener"""
        ...
    
    def SetListener(self, listener):
        r"""SetListener(SBLaunchInfo self, SBListener listener)"""
        ...
    
    def GetShadowListener(self):
        r"""GetShadowListener(SBLaunchInfo self) -> SBListener"""
        ...
    
    def SetShadowListener(self, listener):
        r"""SetShadowListener(SBLaunchInfo self, SBListener listener)"""
        ...
    
    def GetNumArguments(self):
        r"""GetNumArguments(SBLaunchInfo self) -> uint32_t"""
        ...
    
    def GetArgumentAtIndex(self, idx):
        r"""GetArgumentAtIndex(SBLaunchInfo self, uint32_t idx) -> char const *"""
        ...
    
    def SetArguments(self, argv, append):
        r"""SetArguments(SBLaunchInfo self, char const ** argv, bool append)"""
        ...
    
    def GetNumEnvironmentEntries(self):
        r"""GetNumEnvironmentEntries(SBLaunchInfo self) -> uint32_t"""
        ...
    
    def GetEnvironmentEntryAtIndex(self, idx):
        r"""GetEnvironmentEntryAtIndex(SBLaunchInfo self, uint32_t idx) -> char const *"""
        ...
    
    def SetEnvironmentEntries(self, envp, append):
        r"""SetEnvironmentEntries(SBLaunchInfo self, char const ** envp, bool append)"""
        ...
    
    def SetEnvironment(self, env, append):
        r"""SetEnvironment(SBLaunchInfo self, SBEnvironment env, bool append)"""
        ...
    
    def GetEnvironment(self):
        r"""GetEnvironment(SBLaunchInfo self) -> SBEnvironment"""
        ...
    
    def Clear(self):
        r"""Clear(SBLaunchInfo self)"""
        ...
    
    def GetWorkingDirectory(self):
        r"""GetWorkingDirectory(SBLaunchInfo self) -> char const *"""
        ...
    
    def SetWorkingDirectory(self, working_dir):
        r"""SetWorkingDirectory(SBLaunchInfo self, char const * working_dir)"""
        ...
    
    def GetLaunchFlags(self):
        r"""GetLaunchFlags(SBLaunchInfo self) -> uint32_t"""
        ...
    
    def SetLaunchFlags(self, flags):
        r"""SetLaunchFlags(SBLaunchInfo self, uint32_t flags)"""
        ...
    
    def GetProcessPluginName(self):
        r"""GetProcessPluginName(SBLaunchInfo self) -> char const *"""
        ...
    
    def SetProcessPluginName(self, plugin_name):
        r"""SetProcessPluginName(SBLaunchInfo self, char const * plugin_name)"""
        ...
    
    def GetShell(self):
        r"""GetShell(SBLaunchInfo self) -> char const *"""
        ...
    
    def SetShell(self, path):
        r"""SetShell(SBLaunchInfo self, char const * path)"""
        ...
    
    def GetShellExpandArguments(self):
        r"""GetShellExpandArguments(SBLaunchInfo self) -> bool"""
        ...
    
    def SetShellExpandArguments(self, expand):
        r"""SetShellExpandArguments(SBLaunchInfo self, bool expand)"""
        ...
    
    def GetResumeCount(self):
        r"""GetResumeCount(SBLaunchInfo self) -> uint32_t"""
        ...
    
    def SetResumeCount(self, c):
        r"""SetResumeCount(SBLaunchInfo self, uint32_t c)"""
        ...
    
    def AddCloseFileAction(self, fd):
        r"""AddCloseFileAction(SBLaunchInfo self, int fd) -> bool"""
        ...
    
    def AddDuplicateFileAction(self, fd, dup_fd):
        r"""AddDuplicateFileAction(SBLaunchInfo self, int fd, int dup_fd) -> bool"""
        ...
    
    def AddOpenFileAction(self, fd, path, read, write):
        r"""AddOpenFileAction(SBLaunchInfo self, int fd, char const * path, bool read, bool write) -> bool"""
        ...
    
    def AddSuppressFileAction(self, fd, read, write):
        r"""AddSuppressFileAction(SBLaunchInfo self, int fd, bool read, bool write) -> bool"""
        ...
    
    def SetLaunchEventData(self, data):
        r"""SetLaunchEventData(SBLaunchInfo self, char const * data)"""
        ...
    
    def GetLaunchEventData(self):
        r"""GetLaunchEventData(SBLaunchInfo self) -> char const *"""
        ...
    
    def GetDetachOnError(self):
        r"""GetDetachOnError(SBLaunchInfo self) -> bool"""
        ...
    
    def SetDetachOnError(self, enable):
        r"""SetDetachOnError(SBLaunchInfo self, bool enable)"""
        ...
    
    def GetScriptedProcessClassName(self):
        r"""GetScriptedProcessClassName(SBLaunchInfo self) -> char const *"""
        ...
    
    def SetScriptedProcessClassName(self, class_name):
        r"""SetScriptedProcessClassName(SBLaunchInfo self, char const * class_name)"""
        ...
    
    def GetScriptedProcessDictionary(self):
        r"""GetScriptedProcessDictionary(SBLaunchInfo self) -> SBStructuredData"""
        ...
    
    def SetScriptedProcessDictionary(self, dict):
        r"""SetScriptedProcessDictionary(SBLaunchInfo self, SBStructuredData dict)"""
        ...
    


class SBLineEntry:
    r"""
    Specifies an association with a contiguous range of instructions and
    a source file location.

    :py:class:`SBCompileUnit` contains SBLineEntry(s). For example, ::

        for lineEntry in compileUnit:
            print('line entry: %s:%d' % (str(lineEntry.GetFileSpec()),
                                        lineEntry.GetLine()))
            print('start addr: %s' % str(lineEntry.GetStartAddress()))
            print('end   addr: %s' % str(lineEntry.GetEndAddress()))

    produces: ::

        line entry: /Volumes/data/lldb/svn/trunk/test/python_api/symbol-context/main.c:20
        start addr: a.out[0x100000d98]
        end   addr: a.out[0x100000da3]
        line entry: /Volumes/data/lldb/svn/trunk/test/python_api/symbol-context/main.c:21
        start addr: a.out[0x100000da3]
        end   addr: a.out[0x100000da9]
        line entry: /Volumes/data/lldb/svn/trunk/test/python_api/symbol-context/main.c:22
        start addr: a.out[0x100000da9]
        end   addr: a.out[0x100000db6]
        line entry: /Volumes/data/lldb/svn/trunk/test/python_api/symbol-context/main.c:23
        start addr: a.out[0x100000db6]
        end   addr: a.out[0x100000dbc]
        ...

    See also :py:class:`SBCompileUnit` .
    """
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBLineEntry self) -> SBLineEntry
        __init__(SBLineEntry self, SBLineEntry rhs) -> SBLineEntry
        """
        ...
    
    __swig_destroy__ = ...
    def GetStartAddress(self):
        r"""GetStartAddress(SBLineEntry self) -> SBAddress"""
        ...
    
    def GetEndAddress(self):
        r"""GetEndAddress(SBLineEntry self) -> SBAddress"""
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBLineEntry self) -> bool"""
        ...
    
    def GetFileSpec(self):
        r"""GetFileSpec(SBLineEntry self) -> SBFileSpec"""
        ...
    
    def GetLine(self):
        r"""GetLine(SBLineEntry self) -> uint32_t"""
        ...
    
    def GetColumn(self):
        r"""GetColumn(SBLineEntry self) -> uint32_t"""
        ...
    
    def SetFileSpec(self, filespec):
        r"""SetFileSpec(SBLineEntry self, SBFileSpec filespec)"""
        ...
    
    def SetLine(self, line):
        r"""SetLine(SBLineEntry self, uint32_t line)"""
        ...
    
    def SetColumn(self, column):
        r"""SetColumn(SBLineEntry self, uint32_t column)"""
        ...
    
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBLineEntry self, SBLineEntry rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBLineEntry self, SBLineEntry rhs) -> bool"""
        ...
    
    def GetDescription(self, description: SBStream) -> bool:
        r"""GetDescription(SBLineEntry self, SBStream description) -> bool"""
        ...
    
    def __repr__(self) -> str:
        r"""__repr__(SBLineEntry self) -> std::string"""
        ...
    
    file: SBFileSpec = ...
    line: int = ...
    column: int = ...
    addr: SBAddress = ...
    end_addr: SBAddress = ...
    def __eq__(self, rhs) -> bool:
        ...
    
    def __ne__(self, rhs) -> bool:
        ...
    


class SBListener:
    r"""
    API clients can register its own listener to debugger events.

    See also :py:class:`SBEvent` for example usage of creating and adding a listener.
    """
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBListener self) -> SBListener
        __init__(SBListener self, char const * name) -> SBListener
        __init__(SBListener self, SBListener rhs) -> SBListener
        """
        ...
    
    __swig_destroy__ = ...
    def AddEvent(self, event):
        r"""AddEvent(SBListener self, SBEvent event)"""
        ...
    
    def Clear(self):
        r"""Clear(SBListener self)"""
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBListener self) -> bool"""
        ...
    
    def StartListeningForEventClass(self, debugger, broadcaster_class, event_mask):
        r"""StartListeningForEventClass(SBListener self, SBDebugger debugger, char const * broadcaster_class, uint32_t event_mask) -> uint32_t"""
        ...
    
    def StopListeningForEventClass(self, debugger, broadcaster_class, event_mask):
        r"""StopListeningForEventClass(SBListener self, SBDebugger debugger, char const * broadcaster_class, uint32_t event_mask) -> bool"""
        ...
    
    def StartListeningForEvents(self, broadcaster, event_mask):
        r"""StartListeningForEvents(SBListener self, SBBroadcaster broadcaster, uint32_t event_mask) -> uint32_t"""
        ...
    
    def StopListeningForEvents(self, broadcaster, event_mask):
        r"""StopListeningForEvents(SBListener self, SBBroadcaster broadcaster, uint32_t event_mask) -> bool"""
        ...
    
    def WaitForEvent(self, num_seconds, event):
        r"""WaitForEvent(SBListener self, uint32_t num_seconds, SBEvent event) -> bool"""
        ...
    
    def WaitForEventForBroadcaster(self, num_seconds, broadcaster, sb_event):
        r"""WaitForEventForBroadcaster(SBListener self, uint32_t num_seconds, SBBroadcaster broadcaster, SBEvent sb_event) -> bool"""
        ...
    
    def WaitForEventForBroadcasterWithType(self, num_seconds, broadcaster, event_type_mask, sb_event):
        r"""WaitForEventForBroadcasterWithType(SBListener self, uint32_t num_seconds, SBBroadcaster broadcaster, uint32_t event_type_mask, SBEvent sb_event) -> bool"""
        ...
    
    def PeekAtNextEvent(self, sb_event):
        r"""PeekAtNextEvent(SBListener self, SBEvent sb_event) -> bool"""
        ...
    
    def PeekAtNextEventForBroadcaster(self, broadcaster, sb_event):
        r"""PeekAtNextEventForBroadcaster(SBListener self, SBBroadcaster broadcaster, SBEvent sb_event) -> bool"""
        ...
    
    def PeekAtNextEventForBroadcasterWithType(self, broadcaster, event_type_mask, sb_event):
        r"""PeekAtNextEventForBroadcasterWithType(SBListener self, SBBroadcaster broadcaster, uint32_t event_type_mask, SBEvent sb_event) -> bool"""
        ...
    
    def GetNextEvent(self, sb_event):
        r"""GetNextEvent(SBListener self, SBEvent sb_event) -> bool"""
        ...
    
    def GetNextEventForBroadcaster(self, broadcaster, sb_event):
        r"""GetNextEventForBroadcaster(SBListener self, SBBroadcaster broadcaster, SBEvent sb_event) -> bool"""
        ...
    
    def GetNextEventForBroadcasterWithType(self, broadcaster, event_type_mask, sb_event):
        r"""GetNextEventForBroadcasterWithType(SBListener self, SBBroadcaster broadcaster, uint32_t event_type_mask, SBEvent sb_event) -> bool"""
        ...
    
    def HandleBroadcastEvent(self, event):
        r"""HandleBroadcastEvent(SBListener self, SBEvent event) -> bool"""
        ...
    


class SBMemoryRegionInfo:
    r"""API clients can get information about memory regions in processes."""
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBMemoryRegionInfo self) -> SBMemoryRegionInfo
        __init__(SBMemoryRegionInfo self, SBMemoryRegionInfo rhs) -> SBMemoryRegionInfo
        __init__(SBMemoryRegionInfo self, char const * name, lldb::addr_t begin, lldb::addr_t end, uint32_t permissions, bool mapped, bool stack_memory=False) -> SBMemoryRegionInfo
        """
        ...
    
    __swig_destroy__ = ...
    def Clear(self):
        r"""Clear(SBMemoryRegionInfo self)"""
        ...
    
    def GetRegionBase(self):
        r"""GetRegionBase(SBMemoryRegionInfo self) -> lldb::addr_t"""
        ...
    
    def GetRegionEnd(self):
        r"""GetRegionEnd(SBMemoryRegionInfo self) -> lldb::addr_t"""
        ...
    
    def IsReadable(self):
        r"""IsReadable(SBMemoryRegionInfo self) -> bool"""
        ...
    
    def IsWritable(self):
        r"""IsWritable(SBMemoryRegionInfo self) -> bool"""
        ...
    
    def IsExecutable(self):
        r"""IsExecutable(SBMemoryRegionInfo self) -> bool"""
        ...
    
    def IsMapped(self):
        r"""IsMapped(SBMemoryRegionInfo self) -> bool"""
        ...
    
    def GetName(self):
        r"""GetName(SBMemoryRegionInfo self) -> char const *"""
        ...
    
    def HasDirtyMemoryPageList(self):
        r"""

        GetRegionEnd(SBMemoryRegionInfo self) -> lldb::addr_t
        Returns whether this memory region has a list of modified (dirty)
        pages available or not.  When calling GetNumDirtyPages(), you will
        have 0 returned for both "dirty page list is not known" and 
        "empty dirty page list" (that is, no modified pages in this
        memory region).  You must use this method to disambiguate.
        """
        ...
    
    def GetNumDirtyPages(self):
        r"""

        GetNumDirtyPages(SBMemoryRegionInfo self) -> uint32_t
        Return the number of dirty (modified) memory pages in this
        memory region, if available.  You must use the 
        SBMemoryRegionInfo::HasDirtyMemoryPageList() method to
        determine if a dirty memory list is available; it will depend
        on the target system can provide this information.
        """
        ...
    
    def GetDirtyPageAddressAtIndex(self, idx):
        r"""

        GetDirtyPageAddressAtIndex(SBMemoryRegionInfo self, uint32_t idx) -> lldb::addr_t
        Return the address of a modified, or dirty, page of memory.
        If the provided index is out of range, or this memory region 
        does not have dirty page information, LLDB_INVALID_ADDRESS 
        is returned.
        """
        ...
    
    def GetPageSize(self):
        r"""

        GetPageSize(SBMemoryRegionInfo self) -> int
        Return the size of pages in this memory region.  0 will be returned
        if this information was unavailable.
        """
        ...
    
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBMemoryRegionInfo self, SBMemoryRegionInfo rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBMemoryRegionInfo self, SBMemoryRegionInfo rhs) -> bool"""
        ...
    
    def GetDescription(self, description):
        r"""GetDescription(SBMemoryRegionInfo self, SBStream description) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBMemoryRegionInfo self) -> std::string"""
        ...
    


class SBMemoryRegionInfoList:
    r"""Represents a list of :py:class:`SBMemoryRegionInfo`."""
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBMemoryRegionInfoList self) -> SBMemoryRegionInfoList
        __init__(SBMemoryRegionInfoList self, SBMemoryRegionInfoList rhs) -> SBMemoryRegionInfoList
        """
        ...
    
    __swig_destroy__ = ...
    def GetSize(self):
        r"""GetSize(SBMemoryRegionInfoList self) -> uint32_t"""
        ...
    
    def GetMemoryRegionContainingAddress(self, addr, region_info):
        r"""GetMemoryRegionContainingAddress(SBMemoryRegionInfoList self, lldb::addr_t addr, SBMemoryRegionInfo region_info) -> bool"""
        ...
    
    def GetMemoryRegionAtIndex(self, idx, region_info):
        r"""GetMemoryRegionAtIndex(SBMemoryRegionInfoList self, uint32_t idx, SBMemoryRegionInfo region_info) -> bool"""
        ...
    
    def Append(self, *args):
        r"""
        Append(SBMemoryRegionInfoList self, SBMemoryRegionInfo region)
        Append(SBMemoryRegionInfoList self, SBMemoryRegionInfoList region_list)
        """
        ...
    
    def Clear(self):
        r"""Clear(SBMemoryRegionInfoList self)"""
        ...
    


class SBModule:
    r"""
    Represents an executable image and its associated object and symbol files.

    The module is designed to be able to select a single slice of an
    executable image as it would appear on disk and during program
    execution.

    You can retrieve SBModule from :py:class:`SBSymbolContext` , which in turn is available
    from SBFrame.

    SBModule supports symbol iteration, for example, ::

        for symbol in module:
            name = symbol.GetName()
            saddr = symbol.GetStartAddress()
            eaddr = symbol.GetEndAddress()

    and rich comparison methods which allow the API program to use, ::

        if thisModule == thatModule:
            print('This module is the same as that module')

    to test module equality.  A module also contains object file sections, namely
    :py:class:`SBSection` .  SBModule supports section iteration through section_iter(), for
    example, ::

        print('Number of sections: %d' % module.GetNumSections())
        for sec in module.section_iter():
            print(sec)

    And to iterate the symbols within a SBSection, use symbol_in_section_iter(), ::

        # Iterates the text section and prints each symbols within each sub-section.
        for subsec in text_sec:
            print(INDENT + repr(subsec))
            for sym in exe_module.symbol_in_section_iter(subsec):
                print(INDENT2 + repr(sym))
                print(INDENT2 + 'symbol type: %s' % symbol_type_to_str(sym.GetType()))

    produces this following output: ::

        [0x0000000100001780-0x0000000100001d5c) a.out.__TEXT.__text
            id = {0x00000004}, name = 'mask_access(MaskAction, unsigned int)', range = [0x00000001000017c0-0x0000000100001870)
            symbol type: code
            id = {0x00000008}, name = 'thread_func(void*)', range = [0x0000000100001870-0x00000001000019b0)
            symbol type: code
            id = {0x0000000c}, name = 'main', range = [0x00000001000019b0-0x0000000100001d5c)
            symbol type: code
            id = {0x00000023}, name = 'start', address = 0x0000000100001780
            symbol type: code
        [0x0000000100001d5c-0x0000000100001da4) a.out.__TEXT.__stubs
            id = {0x00000024}, name = '__stack_chk_fail', range = [0x0000000100001d5c-0x0000000100001d62)
            symbol type: trampoline
            id = {0x00000028}, name = 'exit', range = [0x0000000100001d62-0x0000000100001d68)
            symbol type: trampoline
            id = {0x00000029}, name = 'fflush', range = [0x0000000100001d68-0x0000000100001d6e)
            symbol type: trampoline
            id = {0x0000002a}, name = 'fgets', range = [0x0000000100001d6e-0x0000000100001d74)
            symbol type: trampoline
            id = {0x0000002b}, name = 'printf', range = [0x0000000100001d74-0x0000000100001d7a)
            symbol type: trampoline
            id = {0x0000002c}, name = 'pthread_create', range = [0x0000000100001d7a-0x0000000100001d80)
            symbol type: trampoline
            id = {0x0000002d}, name = 'pthread_join', range = [0x0000000100001d80-0x0000000100001d86)
            symbol type: trampoline
            id = {0x0000002e}, name = 'pthread_mutex_lock', range = [0x0000000100001d86-0x0000000100001d8c)
            symbol type: trampoline
            id = {0x0000002f}, name = 'pthread_mutex_unlock', range = [0x0000000100001d8c-0x0000000100001d92)
            symbol type: trampoline
            id = {0x00000030}, name = 'rand', range = [0x0000000100001d92-0x0000000100001d98)
            symbol type: trampoline
            id = {0x00000031}, name = 'strtoul', range = [0x0000000100001d98-0x0000000100001d9e)
            symbol type: trampoline
            id = {0x00000032}, name = 'usleep', range = [0x0000000100001d9e-0x0000000100001da4)
            symbol type: trampoline
        [0x0000000100001da4-0x0000000100001e2c) a.out.__TEXT.__stub_helper
        [0x0000000100001e2c-0x0000000100001f10) a.out.__TEXT.__cstring
        [0x0000000100001f10-0x0000000100001f68) a.out.__TEXT.__unwind_info
        [0x0000000100001f68-0x0000000100001ff8) a.out.__TEXT.__eh_frame

    """
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBModule self) -> SBModule
        __init__(SBModule self, SBModule rhs) -> SBModule
        __init__(SBModule self, SBModuleSpec module_spec) -> SBModule
        __init__(SBModule self, SBProcess process, lldb::addr_t header_addr) -> SBModule
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self) -> bool:
        r"""IsValid(SBModule self) -> bool"""
        ...
    
    def Clear(self):
        r"""Clear(SBModule self)"""
        ...
    
    def IsFileBacked(self) -> bool:
        r"""
        IsFileBacked(SBModule self) -> bool

            Check if the module is file backed.

            @return

                True, if the module is backed by an object file on disk.
                False, if the module is backed by an object file in memory.
        """
        ...
    
    def GetFileSpec(self):
        r"""
        GetFileSpec(SBModule self) -> SBFileSpec

            Get const accessor for the module file specification.

            This function returns the file for the module on the host system
            that is running LLDB. This can differ from the path on the
            platform since we might be doing remote debugging.

            @return
                A const reference to the file specification object.
        """
        ...
    
    def GetPlatformFileSpec(self):
        r"""
        GetPlatformFileSpec(SBModule self) -> SBFileSpec

            Get accessor for the module platform file specification.

            Platform file refers to the path of the module as it is known on
            the remote system on which it is being debugged. For local
            debugging this is always the same as Module::GetFileSpec(). But
            remote debugging might mention a file '/usr/lib/liba.dylib'
            which might be locally downloaded and cached. In this case the
            platform file could be something like:
            '/tmp/lldb/platform-cache/remote.host.computer/usr/lib/liba.dylib'
            The file could also be cached in a local developer kit directory.

            @return
                A const reference to the file specification object.
        """
        ...
    
    def SetPlatformFileSpec(self, platform_file):
        r"""SetPlatformFileSpec(SBModule self, SBFileSpec platform_file) -> bool"""
        ...
    
    def GetRemoteInstallFileSpec(self):
        r"""GetRemoteInstallFileSpec(SBModule self) -> SBFileSpec"""
        ...
    
    def SetRemoteInstallFileSpec(self, file):
        r"""SetRemoteInstallFileSpec(SBModule self, SBFileSpec file) -> bool"""
        ...
    
    def GetByteOrder(self):
        r"""GetByteOrder(SBModule self) -> lldb::ByteOrder"""
        ...
    
    def GetAddressByteSize(self):
        r"""GetAddressByteSize(SBModule self) -> uint32_t"""
        ...
    
    def GetTriple(self):
        r"""GetTriple(SBModule self) -> char const *"""
        ...
    
    def GetUUIDBytes(self):
        r"""GetUUIDBytes(SBModule self) -> uint8_t const *"""
        ...
    
    def GetUUIDString(self):
        r"""
        GetUUIDString(SBModule self) -> char const *
        Returns the UUID of the module as a Python string.
        """
        ...
    
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBModule self, SBModule rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBModule self, SBModule rhs) -> bool"""
        ...
    
    def FindSection(self, sect_name):
        r"""FindSection(SBModule self, char const * sect_name) -> SBSection"""
        ...
    
    def ResolveFileAddress(self, vm_addr):
        r"""ResolveFileAddress(SBModule self, lldb::addr_t vm_addr) -> SBAddress"""
        ...
    
    def ResolveSymbolContextForAddress(self, addr, resolve_scope):
        r"""ResolveSymbolContextForAddress(SBModule self, SBAddress addr, uint32_t resolve_scope) -> SBSymbolContext"""
        ...
    
    def GetDescription(self, description):
        r"""GetDescription(SBModule self, SBStream description) -> bool"""
        ...
    
    def GetNumCompileUnits(self):
        r"""GetNumCompileUnits(SBModule self) -> uint32_t"""
        ...
    
    def GetCompileUnitAtIndex(self, arg2):
        r"""GetCompileUnitAtIndex(SBModule self, uint32_t arg2) -> SBCompileUnit"""
        ...
    
    def FindCompileUnits(self, sb_file_spec):
        r"""
        FindCompileUnits(SBModule self, SBFileSpec sb_file_spec) -> SBSymbolContextList

            Find compile units related to this module and passed source
            file.

            @param[in] sb_file_spec
                A :py:class:`SBFileSpec` object that contains source file
                specification.

            @return
                A :py:class:`SBSymbolContextList` that gets filled in with all of
                the symbol contexts for all the matches.
        """
        ...
    
    def GetNumSymbols(self) -> int:
        r"""GetNumSymbols(SBModule self) -> size_t"""
        ...
    
    def GetSymbolAtIndex(self, idx) -> SBSymbol:
        r"""GetSymbolAtIndex(SBModule self, size_t idx) -> SBSymbol"""
        ...
    
    def FindSymbol(self, *args) -> SBSymbol:
        r"""FindSymbol(SBModule self, char const * name, lldb::SymbolType type=eSymbolTypeAny) -> SBSymbol"""
        ...
    
    def FindSymbols(self, *args) -> SBSymbolContextList:
        r"""FindSymbols(SBModule self, char const * name, lldb::SymbolType type=eSymbolTypeAny) -> SBSymbolContextList"""
        ...
    
    def GetNumSections(self) -> int:
        r"""GetNumSections(SBModule self) -> size_t"""
        ...
    
    def GetSectionAtIndex(self, idx) -> SBSection:
        r"""GetSectionAtIndex(SBModule self, size_t idx) -> SBSection"""
        ...
    
    def FindFunctions(self, *args) -> SBSymbolContextList:
        r"""
        FindFunctions(SBModule self, char const * name, uint32_t name_type_mask=eFunctionNameTypeAny) -> SBSymbolContextList

            Find functions by name.

            @param[in] name
                The name of the function we are looking for.

            @param[in] name_type_mask
                A logical OR of one or more FunctionNameType enum bits that
                indicate what kind of names should be used when doing the
                lookup. Bits include fully qualified names, base names,
                C++ methods, or ObjC selectors.
                See FunctionNameType for more details.

            @return
                A symbol context list that gets filled in with all of the
                matches.
        """
        ...
    
    def FindGlobalVariables(self, target, name, max_matches):
        r"""
        FindGlobalVariables(SBModule self, SBTarget target, char const * name, uint32_t max_matches) -> SBValueList

            Find global and static variables by name.

            @param[in] target
                A valid SBTarget instance representing the debuggee.

            @param[in] name
                The name of the global or static variable we are looking
                for.

            @param[in] max_matches
                Allow the number of matches to be limited to max_matches.

            @return
                A list of matched variables in an SBValueList.
        """
        ...
    
    def FindFirstGlobalVariable(self, target, name):
        r"""
        FindFirstGlobalVariable(SBModule self, SBTarget target, char const * name) -> SBValue

            Find the first global (or static) variable by name.

            @param[in] target
                A valid SBTarget instance representing the debuggee.

            @param[in] name
                The name of the global or static variable we are looking
                for.

            @return
                An SBValue that gets filled in with the found variable (if any).
        """
        ...
    
    def FindFirstType(self, name) -> SBType:
        r"""FindFirstType(SBModule self, char const * name) -> SBType"""
        ...
    
    def FindTypes(self, type) -> SBTypeList:
        r"""FindTypes(SBModule self, char const * type) -> SBTypeList"""
        ...
    
    def GetTypeByID(self, uid) -> SBType:
        r"""GetTypeByID(SBModule self, lldb::user_id_t uid) -> SBType"""
        ...
    
    def GetBasicType(self, type) -> SBType:
        r"""GetBasicType(SBModule self, lldb::BasicType type) -> SBType"""
        ...
    
    def GetTypes(self, *args) -> SBTypeList:
        r"""
        GetTypes(SBModule self, uint32_t type_mask=eTypeClassAny) -> SBTypeList

            Get all types matching type_mask from debug info in this
            module.

            @param[in] type_mask
                A bitfield that consists of one or more bits logically OR'ed
                together from the lldb::TypeClass enumeration. This allows
                you to request only structure types, or only class, struct
                and union types. Passing in lldb::eTypeClassAny will return
                all types found in the debug information for this module.

            @return
                A list of types in this module that match type_mask
        """
        ...
    
    def GetVersion(self):
        r"""GetVersion(SBModule self) -> uint32_t"""
        ...
    
    def GetSymbolFileSpec(self):
        r"""GetSymbolFileSpec(SBModule self) -> SBFileSpec"""
        ...
    
    def GetObjectFileHeaderAddress(self):
        r"""GetObjectFileHeaderAddress(SBModule self) -> SBAddress"""
        ...
    
    def GetObjectFileEntryPointAddress(self):
        r"""GetObjectFileEntryPointAddress(SBModule self) -> SBAddress"""
        ...
    
    def IsTypeSystemCompatible(self, language):
        r"""IsTypeSystemCompatible(SBModule self, lldb::LanguageType language) -> SBError"""
        ...
    
    @staticmethod
    def GetNumberAllocatedModules():
        r"""
        GetNumberAllocatedModules() -> uint32_t

            Returns the number of modules in the module cache. This is an
            implementation detail exposed for testing and should not be relied upon.

            @return
                The number of modules in the module cache.
        """
        ...
    
    @staticmethod
    def GarbageCollectAllocatedModules():
        r"""
        GarbageCollectAllocatedModules()

            Removes all modules which are no longer needed by any part of LLDB from
            the module cache.

            This is an implementation detail exposed for testing and should not be
            relied upon. Use SBDebugger::MemoryPressureDetected instead to reduce
            LLDB's memory consumption during execution.

        """
        ...
    
    def __repr__(self):
        r"""__repr__(SBModule self) -> std::string"""
        ...
    
    def __len__(self):
        '''Return the number of symbols in a lldb.SBModule object.'''
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        '''Iterate over all symbols in a lldb.SBModule object.'''
        ...
    
    def section_iter(self): # -> Generator[Any, Any, None]:
        '''Iterate over all sections in a lldb.SBModule object.'''
        ...
    
    def compile_unit_iter(self): # -> Generator[Any, Any, None]:
        '''Iterate over all compile units in a lldb.SBModule object.'''
        ...
    
    def symbol_in_section_iter(self, section): # -> Generator[Any, Any, None]:
        '''Given a module and its contained section, returns an iterator on the
        symbols within the section.'''
        ...
    
    class symbols_access:
        re_compile_type = ...
        def __init__(self, sbmodule) -> None:
            ...
        
        def __len__(self): # -> int:
            ...
        
        def __getitem__(self, key): # -> list[Any] | None:
            ...
        
    
    
    def get_symbols_access_object(self): # -> symbols_access:
        '''An accessor function that returns a symbols_access() object which allows lazy symbol access from a lldb.SBModule object.'''
        ...
    
    def get_compile_units_access_object(self): # -> compile_units_access:
        '''An accessor function that returns a compile_units_access() object which allows lazy compile unit access from a lldb.SBModule object.'''
        ...
    
    def get_symbols_array(self): # -> list[Any]:
        '''An accessor function that returns a list() that contains all symbols in a lldb.SBModule object.'''
        ...
    
    class sections_access:
        re_compile_type = ...
        def __init__(self, sbmodule) -> None:
            ...
        
        def __len__(self): # -> int:
            ...
        
        def __getitem__(self, key): # -> list[Any] | None:
            ...
        
    
    
    class compile_units_access:
        re_compile_type = ...
        def __init__(self, sbmodule) -> None:
            ...
        
        def __len__(self): # -> int:
            ...
        
        def __getitem__(self, key): # -> list[Any] | None:
            ...
        
    
    
    def get_sections_access_object(self): # -> sections_access:
        '''An accessor function that returns a sections_access() object which allows lazy section array access.'''
        ...
    
    def get_sections_array(self): # -> list[Any]:
        '''An accessor function that returns an array object that contains all sections in this module object.'''
        ...
    
    def get_compile_units_array(self): # -> list[Any]:
        '''An accessor function that returns an array object that contains all compile_units in this module object.'''
        ...
    
    symbols = ...
    symbol = ...
    sections = ...
    compile_units = ...
    section = ...
    section = ...
    def get_uuid(self): # -> UUID:
        ...
    
    uuid = ...
    file = ...
    platform_file = ...
    byte_order = ...
    addr_size = ...
    triple = ...
    num_symbols = ...
    num_sections = ...
    def __eq__(self, rhs) -> bool:
        ...
    
    def __ne__(self, rhs) -> bool:
        ...
    


class SBModuleSpec:
    r"""Proxy of C++ lldb::SBModuleSpec class."""
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBModuleSpec self) -> SBModuleSpec
        __init__(SBModuleSpec self, SBModuleSpec rhs) -> SBModuleSpec
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBModuleSpec self) -> bool"""
        ...
    
    def Clear(self):
        r"""Clear(SBModuleSpec self)"""
        ...
    
    def GetFileSpec(self):
        r"""
        GetFileSpec(SBModuleSpec self) -> SBFileSpec

            Get const accessor for the module file.

            This function returns the file for the module on the host system
            that is running LLDB. This can differ from the path on the
            platform since we might be doing remote debugging.

            @return
                A const reference to the file specification object.
        """
        ...
    
    def SetFileSpec(self, fspec):
        r"""SetFileSpec(SBModuleSpec self, SBFileSpec fspec)"""
        ...
    
    def GetPlatformFileSpec(self):
        r"""
        GetPlatformFileSpec(SBModuleSpec self) -> SBFileSpec

            Get accessor for the module platform file.

            Platform file refers to the path of the module as it is known on
            the remote system on which it is being debugged. For local
            debugging this is always the same as Module::GetFileSpec(). But
            remote debugging might mention a file '/usr/lib/liba.dylib'
            which might be locally downloaded and cached. In this case the
            platform file could be something like:
            '/tmp/lldb/platform-cache/remote.host.computer/usr/lib/liba.dylib'
            The file could also be cached in a local developer kit directory.

            @return
                A const reference to the file specification object.
        """
        ...
    
    def SetPlatformFileSpec(self, fspec):
        r"""SetPlatformFileSpec(SBModuleSpec self, SBFileSpec fspec)"""
        ...
    
    def GetSymbolFileSpec(self):
        r"""GetSymbolFileSpec(SBModuleSpec self) -> SBFileSpec"""
        ...
    
    def SetSymbolFileSpec(self, fspec):
        r"""SetSymbolFileSpec(SBModuleSpec self, SBFileSpec fspec)"""
        ...
    
    def GetObjectName(self):
        r"""GetObjectName(SBModuleSpec self) -> char const *"""
        ...
    
    def SetObjectName(self, name):
        r"""SetObjectName(SBModuleSpec self, char const * name)"""
        ...
    
    def GetTriple(self):
        r"""GetTriple(SBModuleSpec self) -> char const *"""
        ...
    
    def SetTriple(self, triple):
        r"""SetTriple(SBModuleSpec self, char const * triple)"""
        ...
    
    def GetUUIDBytes(self):
        r"""GetUUIDBytes(SBModuleSpec self) -> uint8_t const *"""
        ...
    
    def GetUUIDLength(self):
        r"""GetUUIDLength(SBModuleSpec self) -> size_t"""
        ...
    
    def SetUUIDBytes(self, uuid, uuid_len):
        r"""SetUUIDBytes(SBModuleSpec self, uint8_t const * uuid, size_t uuid_len) -> bool"""
        ...
    
    def GetDescription(self, description):
        r"""GetDescription(SBModuleSpec self, SBStream description) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBModuleSpec self) -> std::string"""
        ...
    


class SBModuleSpecList:
    r"""Represents a list of :py:class:`SBModuleSpec`."""
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBModuleSpecList self) -> SBModuleSpecList
        __init__(SBModuleSpecList self, SBModuleSpecList rhs) -> SBModuleSpecList
        """
        ...
    
    __swig_destroy__ = ...
    @staticmethod
    def GetModuleSpecifications(path):
        r"""GetModuleSpecifications(char const * path) -> SBModuleSpecList"""
        ...
    
    def Append(self, *args):
        r"""
        Append(SBModuleSpecList self, SBModuleSpec spec)
        Append(SBModuleSpecList self, SBModuleSpecList spec_list)
        """
        ...
    
    def FindFirstMatchingSpec(self, match_spec):
        r"""FindFirstMatchingSpec(SBModuleSpecList self, SBModuleSpec match_spec) -> SBModuleSpec"""
        ...
    
    def FindMatchingSpecs(self, match_spec):
        r"""FindMatchingSpecs(SBModuleSpecList self, SBModuleSpec match_spec) -> SBModuleSpecList"""
        ...
    
    def GetSize(self):
        r"""GetSize(SBModuleSpecList self) -> size_t"""
        ...
    
    def GetSpecAtIndex(self, i):
        r"""GetSpecAtIndex(SBModuleSpecList self, size_t i) -> SBModuleSpec"""
        ...
    
    def GetDescription(self, description):
        r"""GetDescription(SBModuleSpecList self, SBStream description) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBModuleSpecList self) -> std::string"""
        ...
    


class SBPlatformConnectOptions:
    r"""Describes how :py:class:`SBPlatform.ConnectRemote` connects to a remote platform."""
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBPlatformConnectOptions self, char const * url) -> SBPlatformConnectOptions
        __init__(SBPlatformConnectOptions self, SBPlatformConnectOptions rhs) -> SBPlatformConnectOptions
        """
        ...
    
    __swig_destroy__ = ...
    def GetURL(self):
        r"""GetURL(SBPlatformConnectOptions self) -> char const *"""
        ...
    
    def SetURL(self, url):
        r"""SetURL(SBPlatformConnectOptions self, char const * url)"""
        ...
    
    def GetRsyncEnabled(self):
        r"""GetRsyncEnabled(SBPlatformConnectOptions self) -> bool"""
        ...
    
    def EnableRsync(self, options, remote_path_prefix, omit_remote_hostname):
        r"""EnableRsync(SBPlatformConnectOptions self, char const * options, char const * remote_path_prefix, bool omit_remote_hostname)"""
        ...
    
    def DisableRsync(self):
        r"""DisableRsync(SBPlatformConnectOptions self)"""
        ...
    
    def GetLocalCacheDirectory(self):
        r"""GetLocalCacheDirectory(SBPlatformConnectOptions self) -> char const *"""
        ...
    
    def SetLocalCacheDirectory(self, path):
        r"""SetLocalCacheDirectory(SBPlatformConnectOptions self, char const * path)"""
        ...
    


class SBPlatformShellCommand:
    r"""Represents a shell command that can be run by :py:class:`SBPlatform.Run`."""
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBPlatformShellCommand self, char const * shell, char const * shell_command) -> SBPlatformShellCommand
        __init__(SBPlatformShellCommand self, char const * shell_command) -> SBPlatformShellCommand
        __init__(SBPlatformShellCommand self, SBPlatformShellCommand rhs) -> SBPlatformShellCommand
        """
        ...
    
    __swig_destroy__ = ...
    def Clear(self):
        r"""Clear(SBPlatformShellCommand self)"""
        ...
    
    def GetShell(self):
        r"""GetShell(SBPlatformShellCommand self) -> char const *"""
        ...
    
    def SetShell(self, shell):
        r"""SetShell(SBPlatformShellCommand self, char const * shell)"""
        ...
    
    def GetCommand(self):
        r"""GetCommand(SBPlatformShellCommand self) -> char const *"""
        ...
    
    def SetCommand(self, shell_command):
        r"""SetCommand(SBPlatformShellCommand self, char const * shell_command)"""
        ...
    
    def GetWorkingDirectory(self):
        r"""GetWorkingDirectory(SBPlatformShellCommand self) -> char const *"""
        ...
    
    def SetWorkingDirectory(self, path):
        r"""SetWorkingDirectory(SBPlatformShellCommand self, char const * path)"""
        ...
    
    def GetTimeoutSeconds(self):
        r"""GetTimeoutSeconds(SBPlatformShellCommand self) -> uint32_t"""
        ...
    
    def SetTimeoutSeconds(self, sec):
        r"""SetTimeoutSeconds(SBPlatformShellCommand self, uint32_t sec)"""
        ...
    
    def GetSignal(self):
        r"""GetSignal(SBPlatformShellCommand self) -> int"""
        ...
    
    def GetStatus(self):
        r"""GetStatus(SBPlatformShellCommand self) -> int"""
        ...
    
    def GetOutput(self):
        r"""GetOutput(SBPlatformShellCommand self) -> char const *"""
        ...
    


class SBPlatform:
    r"""
    A class that represents a platform that can represent the current host or a remote host debug platform.

    The SBPlatform class represents the current host, or a remote host.
    It can be connected to a remote platform in order to provide ways
    to remotely launch and attach to processes, upload/download files,
    create directories, run remote shell commands, find locally cached
    versions of files from the remote system, and much more.

    SBPlatform objects can be created and then used to connect to a remote
    platform which allows the SBPlatform to be used to get a list of the
    current processes on the remote host, attach to one of those processes,
    install programs on the remote system, attach and launch processes,
    and much more.

    Every :py:class:`SBTarget` has a corresponding SBPlatform. The platform can be
    specified upon target creation, or the currently selected platform
    will attempt to be used when creating the target automatically as long
    as the currently selected platform matches the target architecture
    and executable type. If the architecture or executable type do not match,
    a suitable platform will be found automatically.
    """
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBPlatform self) -> SBPlatform
        __init__(SBPlatform self, char const * platform_name) -> SBPlatform
        __init__(SBPlatform self, SBPlatform rhs) -> SBPlatform
        """
        ...
    
    __swig_destroy__ = ...
    @staticmethod
    def GetHostPlatform():
        r"""GetHostPlatform() -> SBPlatform"""
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBPlatform self) -> bool"""
        ...
    
    def Clear(self):
        r"""Clear(SBPlatform self)"""
        ...
    
    def GetWorkingDirectory(self):
        r"""GetWorkingDirectory(SBPlatform self) -> char const *"""
        ...
    
    def SetWorkingDirectory(self, path):
        r"""SetWorkingDirectory(SBPlatform self, char const * path) -> bool"""
        ...
    
    def GetName(self):
        r"""GetName(SBPlatform self) -> char const *"""
        ...
    
    def ConnectRemote(self, connect_options):
        r"""ConnectRemote(SBPlatform self, SBPlatformConnectOptions connect_options) -> SBError"""
        ...
    
    def DisconnectRemote(self):
        r"""DisconnectRemote(SBPlatform self)"""
        ...
    
    def IsConnected(self):
        r"""IsConnected(SBPlatform self) -> bool"""
        ...
    
    def GetTriple(self):
        r"""GetTriple(SBPlatform self) -> char const *"""
        ...
    
    def GetHostname(self):
        r"""GetHostname(SBPlatform self) -> char const *"""
        ...
    
    def GetOSBuild(self):
        r"""GetOSBuild(SBPlatform self) -> char const *"""
        ...
    
    def GetOSDescription(self):
        r"""GetOSDescription(SBPlatform self) -> char const *"""
        ...
    
    def GetOSMajorVersion(self):
        r"""GetOSMajorVersion(SBPlatform self) -> uint32_t"""
        ...
    
    def GetOSMinorVersion(self):
        r"""GetOSMinorVersion(SBPlatform self) -> uint32_t"""
        ...
    
    def GetOSUpdateVersion(self):
        r"""GetOSUpdateVersion(SBPlatform self) -> uint32_t"""
        ...
    
    def SetSDKRoot(self, sysroot):
        r"""SetSDKRoot(SBPlatform self, char const * sysroot)"""
        ...
    
    def Put(self, src, dst):
        r"""Put(SBPlatform self, SBFileSpec src, SBFileSpec dst) -> SBError"""
        ...
    
    def Get(self, src, dst):
        r"""Get(SBPlatform self, SBFileSpec src, SBFileSpec dst) -> SBError"""
        ...
    
    def Install(self, src, dst):
        r"""Install(SBPlatform self, SBFileSpec src, SBFileSpec dst) -> SBError"""
        ...
    
    def Run(self, shell_command):
        r"""Run(SBPlatform self, SBPlatformShellCommand shell_command) -> SBError"""
        ...
    
    def Launch(self, launch_info):
        r"""Launch(SBPlatform self, SBLaunchInfo launch_info) -> SBError"""
        ...
    
    def Attach(self, attach_info, debugger, target, error):
        r"""Attach(SBPlatform self, SBAttachInfo attach_info, SBDebugger debugger, SBTarget target, SBError error) -> SBProcess"""
        ...
    
    def GetAllProcesses(self, error):
        r"""GetAllProcesses(SBPlatform self, SBError error) -> SBProcessInfoList"""
        ...
    
    def Kill(self, pid):
        r"""Kill(SBPlatform self, lldb::pid_t const pid) -> SBError"""
        ...
    
    def MakeDirectory(self, *args):
        r"""MakeDirectory(SBPlatform self, char const * path, uint32_t file_permissions=eFilePermissionsDirectoryDefault) -> SBError"""
        ...
    
    def GetFilePermissions(self, path):
        r"""GetFilePermissions(SBPlatform self, char const * path) -> uint32_t"""
        ...
    
    def SetFilePermissions(self, path, file_permissions):
        r"""SetFilePermissions(SBPlatform self, char const * path, uint32_t file_permissions) -> SBError"""
        ...
    
    def GetUnixSignals(self):
        r"""GetUnixSignals(SBPlatform self) -> SBUnixSignals"""
        ...
    
    def GetEnvironment(self):
        r"""GetEnvironment(SBPlatform self) -> SBEnvironment"""
        ...


# noinspection PyPep8Naming
class SBProcess:
    r"""
    Represents the process associated with the target program.

    SBProcess supports thread iteration. For example (from test/lldbutil.py), ::

        # ==================================================
        # Utility functions related to Threads and Processes
        # ==================================================

        def get_stopped_threads(process, reason):
            '''Returns the thread(s) with the specified stop reason in a list.

            The list can be empty if no such thread exists.
            '''
            threads = []
            for t in process:
                if t.GetStopReason() == reason:
                    threads.append(t)
            return threads

    """
    thisown = ...
    eBroadcastBitStateChanged = ...
    eBroadcastBitInterrupt = ...
    eBroadcastBitSTDOUT = ...
    eBroadcastBitSTDERR = ...
    eBroadcastBitProfileData = ...
    eBroadcastBitStructuredData = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBProcess self) -> SBProcess
        __init__(SBProcess self, SBProcess rhs) -> SBProcess
        """
        ...
    
    __swig_destroy__ = ...
    @staticmethod
    def GetBroadcasterClassName() -> str:
        r"""GetBroadcasterClassName() -> char const *"""
        ...
    
    def GetPluginName(self) -> str:
        r"""GetPluginName(SBProcess self) -> char const *"""
        ...
    
    def GetShortPluginName(self) -> str:
        r"""GetShortPluginName(SBProcess self) -> char const *"""
        ...
    
    def Clear(self):
        r"""Clear(SBProcess self)"""
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self) -> bool:
        r"""IsValid(SBProcess self) -> bool"""
        ...
    
    def GetTarget(self) -> SBTarget:
        r"""GetTarget(SBProcess self) -> SBTarget"""
        ...
    
    def GetByteOrder(self):
        r"""GetByteOrder(SBProcess self) -> lldb::ByteOrder"""
        ...
    
    def PutSTDIN(self, src):
        r"""

        Writes data into the current process's stdin. API client specifies a Python
        string as the only argument.
        """
        ...
    
    def GetSTDOUT(self, dst):
        r"""

        Reads data from the current process's stdout stream. API client specifies
        the size of the buffer to read data into. It returns the byte buffer in a
        Python string.
        """
        ...
    
    def GetSTDERR(self, dst):
        r"""

        Reads data from the current process's stderr stream. API client specifies
        the size of the buffer to read data into. It returns the byte buffer in a
        Python string.
        """
        ...
    
    def GetAsyncProfileData(self, dst: str) -> int:
        r"""GetAsyncProfileData(SBProcess self, char * dst) -> size_t"""
        ...
    
    def ReportEventState(self, *args):
        r"""
        ReportEventState(SBProcess self, SBEvent event, SBFile file)
        ReportEventState(SBProcess self, SBEvent event, lldb::FileSP BORROWED)
        """
        ...
    
    def AppendEventStateReport(self, event: SBevent, result: SBCommandReturnObject):
        r"""AppendEventStateReport(SBProcess self, SBEvent event, SBCommandReturnObject result)"""
        ...
    
    def RemoteAttachToProcessWithID(self, pid: int, error: SBError) -> bool:
        r"""
        RemoteAttachToProcessWithID(SBProcess self, lldb::pid_t pid, SBError error) -> bool

            Remote connection related functions. These will fail if the
            process is not in eStateConnected. They are intended for use
            when connecting to an externally managed debugserver instance.
        """
        ...
    
    def RemoteLaunch(self, argv, envp, stdin_path, stdout_path, stderr_path, working_directory, launch_flags, stop_at_entry, error):
        r"""
        RemoteLaunch(SBProcess self, char const ** argv, char const ** envp, char const * stdin_path, char const * stdout_path, char const * stderr_path, char const * working_directory, uint32_t launch_flags, bool stop_at_entry, SBError error) -> bool
        See SBTarget.Launch for argument description and usage.
        """
        ...
    
    def GetNumThreads(self) -> int:
        r"""GetNumThreads(SBProcess self) -> uint32_t"""
        ...
    
    def GetThreadAtIndex(self, index):
        r"""

        Returns the INDEX'th thread from the list of current threads.  The index
        of a thread is only valid for the current stop.  For a persistent thread
        identifier use either the thread ID or the IndexID.  See help on SBThread
        for more details.
        """
        ...
    
    def GetThreadByID(self, sb_thread_id):
        r"""

        Returns the thread with the given thread ID.
        """
        ...
    
    def GetThreadByIndexID(self, index_id):
        r"""

        Returns the thread with the given thread IndexID.
        """
        ...
    
    def GetSelectedThread(self) -> SBThread:
        r"""

        Returns the currently selected thread.
        """
        ...
    
    def CreateOSPluginThread(self, tid, context):
        r"""

        Lazily create a thread on demand through the current OperatingSystem plug-in, if the current OperatingSystem plug-in supports it.
        """
        ...
    
    def SetSelectedThread(self, thread: SBThread) -> bool:
        r"""SetSelectedThread(SBProcess self, SBThread thread) -> bool"""
        ...
    
    def SetSelectedThreadByID(self, tid) -> bool:
        r"""SetSelectedThreadByID(SBProcess self, lldb::tid_t tid) -> bool"""
        ...
    
    def SetSelectedThreadByIndexID(self, index_id: int) -> bool:
        r"""SetSelectedThreadByIndexID(SBProcess self, uint32_t index_id) -> bool"""
        ...
    
    def GetNumQueues(self) -> int:
        r"""GetNumQueues(SBProcess self) -> uint32_t"""
        ...
    
    def GetQueueAtIndex(self, index: int) -> SBQueue:
        r"""GetQueueAtIndex(SBProcess self, size_t index) -> SBQueue"""
        ...
    
    def GetState(self):
        r"""GetState(SBProcess self) -> lldb::StateType"""
        ...
    
    def GetExitStatus(self) -> int:
        r"""GetExitStatus(SBProcess self) -> int"""
        ...
    
    def GetExitDescription(self) -> str:
        r"""GetExitDescription(SBProcess self) -> char const *"""
        ...
    
    def GetProcessID(self):
        r"""

        Returns the process ID of the process.
        """
        ...
    
    def GetUniqueID(self):
        r"""

        Returns an integer ID that is guaranteed to be unique across all process instances. This is not the process ID, just a unique integer for comparison and caching purposes.
        """
        ...
    
    def GetAddressByteSize(self) -> int:
        r"""GetAddressByteSize(SBProcess self) -> uint32_t"""
        ...
    
    def Destroy(self) -> SBError:
        r"""
        Destroy(SBProcess self) -> SBError

            Kills the process and shuts down all threads that were spawned to
            track and monitor process.
        """
        ...
    
    def Continue(self) -> SBError:
        r"""Continue(SBProcess self) -> SBError"""
        ...
    
    def Stop(self) -> SBError:
        r"""Stop(SBProcess self) -> SBError"""
        ...
    
    def Kill(self) -> SBError:
        r"""
        Kill(SBProcess self) -> SBError
        Same as Destroy(self).
        """
        ...
    
    def Detach(self, *args) -> SBError:
        r"""
        Detach(SBProcess self) -> SBError
        Detach(SBProcess self, bool keep_stopped) -> SBError
        """
        ...
    
    def Signal(self, signal) -> SBError:
        r"""
        Signal(SBProcess self, int signal) -> SBError
        Sends the process a unix signal.
        """
        ...
    
    def GetUnixSignals(self) -> SBUnixSignals:
        r"""GetUnixSignals(SBProcess self) -> SBUnixSignals"""
        ...
    
    def SendAsyncInterrupt(self):
        r"""SendAsyncInterrupt(SBProcess self)"""
        ...
    
    def GetStopID(self, include_expression_stops: bool=...) -> int:
        r"""
        GetStopID(SBProcess self, bool include_expression_stops=False) -> uint32_t

            Returns a stop id that will increase every time the process executes.  If
            include_expression_stops is true, then stops caused by expression evaluation
            will cause the returned value to increase, otherwise the counter returned will
            only increase when execution is continued explicitly by the user.  Note, the value
            will always increase, but may increase by more than one per stop.
        """
        ...
    
    def GetStopEventForStopID(self, stop_id: int) -> SBEvent:
        r"""GetStopEventForStopID(SBProcess self, uint32_t stop_id) -> SBEvent"""
        ...
    
    def ForceScriptedState(self, new_state):
        r"""ForceScriptedState(SBProcess self, lldb::StateType new_state)"""
        ...
    
    def ReadMemory(self, addr: int, buf: int, error: SBError):
        r"""

        Reads memory from the current process's address space and removes any
        traps that may have been inserted into the memory. It returns the byte
        buffer in a Python string. Example: ::

            # Read 4 bytes from address 'addr' and assume error.Success() is True.
            content = process.ReadMemory(addr, 4, error)
            new_bytes = bytearray(content)
        """
        ...
    
    def WriteMemory(self, addr: int, buf: int, error: SBError) -> int:
        r"""

        Writes memory to the current process's address space and maintains any
        traps that might be present due to software breakpoints. Example: ::

            # Create a Python string from the byte array.
            new_value = str(bytes)
            result = process.WriteMemory(addr, new_value, error)
            if not error.Success() or result != len(bytes):
                print('SBProcess.WriteMemory() failed!')
        """
        ...
    
    def ReadCStringFromMemory(self, addr: int, char_buf: int, error: SBError) -> str:
        r"""

        Reads a NULL terminated C string from the current process's address space.
        It returns a python string of the exact length, or truncates the string if
        the maximum character limit is reached. Example: ::

            # Read a C string of at most 256 bytes from address '0x1000'
            error = lldb.SBError()
            cstring = process.ReadCStringFromMemory(0x1000, 256, error)
            if error.Success():
                print('cstring: ', cstring)
            else
                print('error: ', error)
        """
        ...
    
    def ReadUnsignedFromMemory(self, addr: int, byte_size: int, error: SBError):
        r"""

        Reads an unsigned integer from memory given a byte size and an address.
        Returns the unsigned integer that was read. Example: ::

            # Read a 4 byte unsigned integer from address 0x1000
            error = lldb.SBError()
            uint = ReadUnsignedFromMemory(0x1000, 4, error)
            if error.Success():
                print('integer: %u' % uint)
            else
                print('error: ', error)
        """
        ...
    
    def ReadPointerFromMemory(self, addr: int, error: SBError):
        r"""

        Reads a pointer from memory from an address and returns the value. Example: ::

            # Read a pointer from address 0x1000
            error = lldb.SBError()
            ptr = ReadPointerFromMemory(0x1000, error)
            if error.Success():
                print('pointer: 0x%x' % ptr)
            else
                print('error: ', error)
        """
        ...
    
    @staticmethod
    def GetStateFromEvent(event):
        r"""GetStateFromEvent(SBEvent event) -> lldb::StateType"""
        ...
    
    @staticmethod
    def GetRestartedFromEvent(event: SBEvent) -> bool:
        r"""GetRestartedFromEvent(SBEvent event) -> bool"""
        ...
    
    @staticmethod
    def GetNumRestartedReasonsFromEvent(event: SBEvent) -> int:
        r"""GetNumRestartedReasonsFromEvent(SBEvent event) -> size_t"""
        ...
    
    @staticmethod
    def GetRestartedReasonAtIndexFromEvent(event: SBEvent, idx: int) -> str:
        r"""GetRestartedReasonAtIndexFromEvent(SBEvent event, size_t idx) -> char const *"""
        ...
    
    @staticmethod
    def GetProcessFromEvent(event: SBEvent) -> SBProcess:
        r"""GetProcessFromEvent(SBEvent event) -> SBProcess"""
        ...
    
    @staticmethod
    def GetInterruptedFromEvent(event: SBEvent) -> bool:
        r"""GetInterruptedFromEvent(SBEvent event) -> bool"""
        ...
    
    @staticmethod
    def GetStructuredDataFromEvent(event: SBEvent) -> SBStructuredData:
        r"""GetStructuredDataFromEvent(SBEvent event) -> SBStructuredData"""
        ...
    
    @staticmethod
    def EventIsProcessEvent(event: SBEvent) -> bool:
        r"""EventIsProcessEvent(SBEvent event) -> bool"""
        ...
    
    @staticmethod
    def EventIsStructuredDataEvent(event: SBEvent) -> bool:
        r"""EventIsStructuredDataEvent(SBEvent event) -> bool"""
        ...
    
    def GetBroadcaster(self) -> SBBroadcaster:
        r"""GetBroadcaster(SBProcess self) -> SBBroadcaster"""
        ...
    
    @staticmethod
    def GetBroadcasterClass() -> str:
        r"""GetBroadcasterClass() -> char const *"""
        ...
    
    def GetDescription(self, description: SBStream) -> bool:
        r"""GetDescription(SBProcess self, SBStream description) -> bool"""
        ...
    
    def GetExtendedCrashInformation(self):
        r"""

        Returns the process' extended crash information.
        """
        ...
    
    def GetNumSupportedHardwareWatchpoints(self, error: SBError) -> int:
        r"""GetNumSupportedHardwareWatchpoints(SBProcess self, SBError error) -> uint32_t"""
        ...
    
    def LoadImage(self, *args) -> int:
        r"""
        LoadImage(SBProcess self, SBFileSpec remote_image_spec, SBError error) -> uint32_t
        LoadImage(SBProcess self, SBFileSpec local_image_spec, SBFileSpec remote_image_spec, SBError error) -> uint32_t
        """
        ...
    
    def LoadImageUsingPaths(self, image_spec, paths, loaded_path, error):
        r"""

        Load the library whose filename is given by image_spec looking in all the
        paths supplied in the paths argument.  If successful, return a token that
        can be passed to UnloadImage and fill loaded_path with the path that was
        successfully loaded.  On failure, return
        lldb.LLDB_INVALID_IMAGE_TOKEN.
        """
        ...
    
    def UnloadImage(self, image_token: int) -> SBError:
        r"""UnloadImage(SBProcess self, uint32_t image_token) -> SBError"""
        ...
    
    def SendEventData(self, data: str) -> SBError:
        r"""SendEventData(SBProcess self, char const * data) -> SBError"""
        ...
    
    def GetNumExtendedBacktraceTypes(self) -> int:
        r"""

        Return the number of different thread-origin extended backtraces
        this process can support as a uint32_t.
        When the process is stopped and you have an SBThread, lldb may be
        able to show a backtrace of when that thread was originally created,
        or the work item was enqueued to it (in the case of a libdispatch
        queue).
        """
        ...
    
    def GetExtendedBacktraceTypeAtIndex(self, idx):
        r"""

        Takes an index argument, returns the name of one of the thread-origin
        extended backtrace methods as a str.
        """
        ...
    
    def GetHistoryThreads(self, addr: int) -> SBThreadCollection:
        r"""GetHistoryThreads(SBProcess self, lldb::addr_t addr) -> SBThreadCollection"""
        ...
    
    def IsInstrumentationRuntimePresent(self, type) -> bool:
        r"""IsInstrumentationRuntimePresent(SBProcess self, lldb::InstrumentationRuntimeType type) -> bool"""
        ...
    
    def SaveCore(self, *args) -> SBError:
        r"""
        SaveCore(SBProcess self, char const * file_name, char const * flavor, lldb::SaveCoreStyle core_style) -> SBError
        SaveCore(SBProcess self, char const * file_name) -> SBError
        """
        ...
    
    def GetMemoryRegionInfo(self, load_addr: int, region_info: SBMemoryRegionInfo) -> SBError:
        r"""GetMemoryRegionInfo(SBProcess self, lldb::addr_t load_addr, SBMemoryRegionInfo region_info) -> SBError"""
        ...
    
    def GetMemoryRegions(self) -> SBMemoryRegionInfoList:
        r"""GetMemoryRegions(SBProcess self) -> SBMemoryRegionInfoList"""
        ...
    
    def GetProcessInfo(self) -> SBProcessInfo:
        r"""

        Get information about the process.
        Valid process info will only be returned when the process is alive,
        use IsValid() to check if the info returned is valid. ::

            process_info = process.GetProcessInfo()
            if process_info.IsValid():
                process_info.GetProcessID()
        """
        ...
    
    def AllocateMemory(self, size: int, permissions: int, error: SBError) -> int:
        r"""

        Allocates a block of memory within the process, with size and
        access permissions specified in the arguments. The permissions
        argument is an or-combination of zero or more of
        lldb.ePermissionsWritable, lldb.ePermissionsReadable, and
        lldb.ePermissionsExecutable. Returns the address
        of the allocated buffer in the process, or
        lldb.LLDB_INVALID_ADDRESS if the allocation failed.
        """
        ...
    
    def DeallocateMemory(self, ptr: int):
        r"""

        Deallocates the block of memory (previously allocated using
        AllocateMemory) given in the argument.
        """
        ...
    
    def GetScriptedImplementation(self):
        r"""

        Returns the implementation object of the process plugin if available. None
        otherwise.
        """
        ...
    
    def __repr__(self):
        r"""__repr__(SBProcess self) -> std::string"""
        ...
    
    def WriteMemoryAsCString(self, addr: int, str: str, error: SBError) -> int:
        '''
          WriteMemoryAsCString(self, addr, str, error):
            This functions the same as `WriteMemory` except a null-terminator is appended
            to the end of the buffer if it is not there already.
        '''
        ...
    
    def __get_is_alive__(self): # -> bool:
        '''Returns "True" if the process is currently alive, "False" otherwise'''
        ...
    
    def __get_is_running__(self): # -> bool:
        '''Returns "True" if the process is currently running, "False" otherwise'''
        ...
    
    def __get_is_stopped__(self): # -> bool:
        '''Returns "True" if the process is currently stopped, "False" otherwise'''
        ...
    
    class threads_access:
        '''A helper object that will lazily hand out thread for a process when supplied an index.'''
        def __init__(self, sbprocess) -> None:
            ...
        
        def __len__(self): # -> int:
            ...
        
        def __getitem__(self, key): # -> None:
            ...
        
    
    
    def get_threads_access_object(self): # -> threads_access:
        '''An accessor function that returns a modules_access() object which allows lazy thread access from a lldb.SBProcess object.'''
        ...
    
    def get_process_thread_list(self): # -> list[Any]:
        '''An accessor function that returns a list() that contains all threads in a lldb.SBProcess object.'''
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        '''Iterate over all threads in a lldb.SBProcess object.'''
        ...
    
    def __len__(self):
        '''Return the number of threads in a lldb.SBProcess object.'''
        ...
    
    threads = ...
    thread: SBThread = ...
    is_alive: bool = ...
    is_running: bool = ...
    is_stopped: bool = ...
    id = ...
    target: SBTarget = ...
    num_threads = ...
    selected_thread: SBThread = ...
    state = ...
    exit_state = ...
    exit_description = ...
    broadcaster: SBBroadcaster = ...


class SBProcessInfo:
    r"""
    Describes an existing process and any discoverable information that pertains to
    that process.
    """
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBProcessInfo self) -> SBProcessInfo
        __init__(SBProcessInfo self, SBProcessInfo rhs) -> SBProcessInfo
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBProcessInfo self) -> bool"""
        ...
    
    def GetName(self):
        r"""GetName(SBProcessInfo self) -> char const *"""
        ...
    
    def GetExecutableFile(self):
        r"""GetExecutableFile(SBProcessInfo self) -> SBFileSpec"""
        ...
    
    def GetProcessID(self):
        r"""GetProcessID(SBProcessInfo self) -> lldb::pid_t"""
        ...
    
    def GetUserID(self):
        r"""GetUserID(SBProcessInfo self) -> uint32_t"""
        ...
    
    def GetGroupID(self):
        r"""GetGroupID(SBProcessInfo self) -> uint32_t"""
        ...
    
    def UserIDIsValid(self):
        r"""UserIDIsValid(SBProcessInfo self) -> bool"""
        ...
    
    def GroupIDIsValid(self):
        r"""GroupIDIsValid(SBProcessInfo self) -> bool"""
        ...
    
    def GetEffectiveUserID(self):
        r"""GetEffectiveUserID(SBProcessInfo self) -> uint32_t"""
        ...
    
    def GetEffectiveGroupID(self):
        r"""GetEffectiveGroupID(SBProcessInfo self) -> uint32_t"""
        ...
    
    def EffectiveUserIDIsValid(self):
        r"""EffectiveUserIDIsValid(SBProcessInfo self) -> bool"""
        ...
    
    def EffectiveGroupIDIsValid(self):
        r"""EffectiveGroupIDIsValid(SBProcessInfo self) -> bool"""
        ...
    
    def GetParentProcessID(self):
        r"""GetParentProcessID(SBProcessInfo self) -> lldb::pid_t"""
        ...
    
    def GetTriple(self):
        r"""
        GetTriple(SBProcessInfo self) -> char const *
        Return the target triple (arch-vendor-os) for the described process.
        """
        ...
    


class SBProcessInfoList:
    r"""Proxy of C++ lldb::SBProcessInfoList class."""
    thisown = ...
    __repr__ = ...
    __swig_destroy__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBProcessInfoList self) -> SBProcessInfoList
        __init__(SBProcessInfoList self, SBProcessInfoList rhs) -> SBProcessInfoList
        """
        ...
    
    def GetSize(self):
        r"""GetSize(SBProcessInfoList self) -> uint32_t"""
        ...
    
    def GetProcessInfoAtIndex(self, idx, info):
        r"""GetProcessInfoAtIndex(SBProcessInfoList self, uint32_t idx, SBProcessInfo info) -> bool"""
        ...
    
    def Clear(self):
        r"""Clear(SBProcessInfoList self)"""
        ...
    
    def __len__(self):
        '''Return the number of process info in a lldb.SBProcessInfoListExtensions object.'''
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        '''Iterate over all the process info in a lldb.SBProcessInfoListExtensions object.'''
        ...
    


class SBQueue:
    r"""Represents a libdispatch queue in the process."""
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBQueue self) -> SBQueue
        __init__(SBQueue self, SBQueue rhs) -> SBQueue
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBQueue self) -> bool"""
        ...
    
    def Clear(self):
        r"""Clear(SBQueue self)"""
        ...
    
    def GetProcess(self):
        r"""GetProcess(SBQueue self) -> SBProcess"""
        ...
    
    def GetQueueID(self):
        r"""

        Returns an lldb::queue_id_t type unique identifier number for this
        queue that will not be used by any other queue during this process'
        execution.  These ID numbers often start at 1 with the first
        system-created queues and increment from there.
        """
        ...
    
    def GetName(self):
        r"""GetName(SBQueue self) -> char const *"""
        ...
    
    def GetIndexID(self):
        r"""GetIndexID(SBQueue self) -> uint32_t"""
        ...
    
    def GetNumThreads(self):
        r"""GetNumThreads(SBQueue self) -> uint32_t"""
        ...
    
    def GetThreadAtIndex(self, arg2):
        r"""GetThreadAtIndex(SBQueue self, uint32_t arg2) -> SBThread"""
        ...
    
    def GetNumPendingItems(self):
        r"""GetNumPendingItems(SBQueue self) -> uint32_t"""
        ...
    
    def GetPendingItemAtIndex(self, arg2):
        r"""GetPendingItemAtIndex(SBQueue self, uint32_t arg2) -> SBQueueItem"""
        ...
    
    def GetNumRunningItems(self):
        r"""GetNumRunningItems(SBQueue self) -> uint32_t"""
        ...
    
    def GetKind(self):
        r"""

        Returns an lldb::QueueKind enumerated value (e.g. eQueueKindUnknown,
        eQueueKindSerial, eQueueKindConcurrent) describing the type of this
        queue.
        """
        ...
    


class SBQueueItem:
    r"""This class represents an item in an :py:class:`SBQueue`."""
    thisown = ...
    __repr__ = ...
    def __init__(self) -> None:
        r"""__init__(SBQueueItem self) -> SBQueueItem"""
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBQueueItem self) -> bool"""
        ...
    
    def Clear(self):
        r"""Clear(SBQueueItem self)"""
        ...
    
    def GetKind(self):
        r"""GetKind(SBQueueItem self) -> lldb::QueueItemKind"""
        ...
    
    def SetKind(self, kind):
        r"""SetKind(SBQueueItem self, lldb::QueueItemKind kind)"""
        ...
    
    def GetAddress(self):
        r"""GetAddress(SBQueueItem self) -> SBAddress"""
        ...
    
    def SetAddress(self, addr):
        r"""SetAddress(SBQueueItem self, SBAddress addr)"""
        ...
    
    def GetExtendedBacktraceThread(self, type):
        r"""GetExtendedBacktraceThread(SBQueueItem self, char const * type) -> SBThread"""
        ...
    


class SBReproducer:
    r"""Controls LLDB's reproducer functionality."""
    thisown = ...
    __repr__ = ...
    @staticmethod
    def Capture(path):
        r"""Capture(char const * path) -> char const *"""
        ...
    
    @staticmethod
    def PassiveReplay(path):
        r"""PassiveReplay(char const * path) -> char const *"""
        ...
    
    @staticmethod
    def SetAutoGenerate(b):
        r"""SetAutoGenerate(bool b) -> bool"""
        ...
    
    @staticmethod
    def SetWorkingDirectory(path):
        r"""SetWorkingDirectory(char const * path)"""
        ...
    
    def __init__(self) -> None:
        r"""__init__(SBReproducer self) -> SBReproducer"""
        ...
    
    __swig_destroy__ = ...


class SBScriptObject:
    r"""Proxy of C++ lldb::SBScriptObject class."""
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBScriptObject self, lldb::ScriptObjectPtr const ptr, lldb::ScriptLanguage lang) -> SBScriptObject
        __init__(SBScriptObject self, SBScriptObject rhs) -> SBScriptObject
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBScriptObject self, SBScriptObject rhs) -> bool"""
        ...
    
    def IsValid(self):
        r"""IsValid(SBScriptObject self) -> bool"""
        ...
    
    def GetPointer(self):
        r"""GetPointer(SBScriptObject self) -> lldb::ScriptObjectPtr"""
        ...
    
    def GetLanguage(self):
        r"""GetLanguage(SBScriptObject self) -> lldb::ScriptLanguage"""
        ...
    
    ptr = ...
    lang = ...


class SBSection:
    r"""
    Represents an executable image section.

    SBSection supports iteration through its subsection, represented as SBSection
    as well.  For example, ::

        for sec in exe_module:
            if sec.GetName() == '__TEXT':
                print sec
                break
        print INDENT + 'Number of subsections: %d' % sec.GetNumSubSections()
        for subsec in sec:
            print INDENT + repr(subsec)

    produces: ::

      [0x0000000100000000-0x0000000100002000) a.out.__TEXT
          Number of subsections: 6
          [0x0000000100001780-0x0000000100001d5c) a.out.__TEXT.__text
          [0x0000000100001d5c-0x0000000100001da4) a.out.__TEXT.__stubs
          [0x0000000100001da4-0x0000000100001e2c) a.out.__TEXT.__stub_helper
          [0x0000000100001e2c-0x0000000100001f10) a.out.__TEXT.__cstring
          [0x0000000100001f10-0x0000000100001f68) a.out.__TEXT.__unwind_info
          [0x0000000100001f68-0x0000000100001ff8) a.out.__TEXT.__eh_frame

    See also :py:class:`SBModule` .
    """
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBSection self) -> SBSection
        __init__(SBSection self, SBSection rhs) -> SBSection
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBSection self) -> bool"""
        ...
    
    def GetName(self):
        r"""GetName(SBSection self) -> char const *"""
        ...
    
    def GetParent(self):
        r"""GetParent(SBSection self) -> SBSection"""
        ...
    
    def FindSubSection(self, sect_name):
        r"""FindSubSection(SBSection self, char const * sect_name) -> SBSection"""
        ...
    
    def GetNumSubSections(self):
        r"""GetNumSubSections(SBSection self) -> size_t"""
        ...
    
    def GetSubSectionAtIndex(self, idx):
        r"""GetSubSectionAtIndex(SBSection self, size_t idx) -> SBSection"""
        ...
    
    def GetFileAddress(self):
        r"""GetFileAddress(SBSection self) -> lldb::addr_t"""
        ...
    
    def GetLoadAddress(self, target):
        r"""GetLoadAddress(SBSection self, SBTarget target) -> lldb::addr_t"""
        ...
    
    def GetByteSize(self):
        r"""GetByteSize(SBSection self) -> lldb::addr_t"""
        ...
    
    def GetFileOffset(self):
        r"""GetFileOffset(SBSection self) -> uint64_t"""
        ...
    
    def GetFileByteSize(self):
        r"""GetFileByteSize(SBSection self) -> uint64_t"""
        ...
    
    def GetSectionData(self, *args):
        r"""
        GetSectionData(SBSection self) -> SBData
        GetSectionData(SBSection self, uint64_t offset, uint64_t size) -> SBData
        """
        ...
    
    def GetSectionType(self):
        r"""GetSectionType(SBSection self) -> lldb::SectionType"""
        ...
    
    def GetPermissions(self):
        r"""GetPermissions(SBSection self) -> uint32_t"""
        ...
    
    def GetTargetByteSize(self):
        r"""
        GetTargetByteSize(SBSection self) -> uint32_t

            Return the size of a target's byte represented by this section
            in numbers of host bytes. Note that certain architectures have
            varying minimum addressable unit (i.e. byte) size for their
            CODE or DATA buses.

            @return
                The number of host (8-bit) bytes needed to hold a target byte
        """
        ...
    
    def GetAlignment(self):
        r"""GetAlignment(SBSection self) -> uint32_t"""
        ...
    
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBSection self, SBSection rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBSection self, SBSection rhs) -> bool"""
        ...
    
    def GetDescription(self, description):
        r"""GetDescription(SBSection self, SBStream description) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBSection self) -> std::string"""
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        '''Iterate over all subsections in a lldb.SBSection object.'''
        ...
    
    def __len__(self):
        '''Return the number of subsections in a lldb.SBSection object.'''
        ...
    
    def get_addr(self): # -> SBAddress:
        ...
    
    name = ...
    addr = ...
    file_addr = ...
    size = ...
    file_offset = ...
    file_size = ...
    data = ...
    type = ...
    target_byte_size = ...
    alignment = ...
    def __eq__(self, rhs) -> bool:
        ...
    
    def __ne__(self, rhs) -> bool:
        ...
    


class SBSourceManager:
    r"""
    Represents a central authority for displaying source code.

    For example (from test/source-manager/TestSourceManager.py), ::

            # Create the filespec for 'main.c'.
            filespec = lldb.SBFileSpec('main.c', False)
            source_mgr = self.dbg.GetSourceManager()
            # Use a string stream as the destination.
            stream = lldb.SBStream()
            source_mgr.DisplaySourceLinesWithLineNumbers(filespec,
                                                         self.line,
                                                         2, # context before
                                                         2, # context after
                                                         '=>', # prefix for current line
                                                         stream)

            #    2
            #    3    int main(int argc, char const *argv[]) {
            # => 4        printf('Hello world.\n'); // Set break point at this line.
            #    5        return 0;
            #    6    }
            self.expect(stream.GetData(), 'Source code displayed correctly',
                        exe=False,
                patterns = ['=> %d.*Hello world' % self.line])
    """
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBSourceManager self, SBDebugger debugger) -> SBSourceManager
        __init__(SBSourceManager self, SBTarget target) -> SBSourceManager
        __init__(SBSourceManager self, SBSourceManager rhs) -> SBSourceManager
        """
        ...
    
    __swig_destroy__ = ...
    def DisplaySourceLinesWithLineNumbers(self, file, line, context_before, context_after, current_line_cstr, s):
        r"""DisplaySourceLinesWithLineNumbers(SBSourceManager self, SBFileSpec file, uint32_t line, uint32_t context_before, uint32_t context_after, char const * current_line_cstr, SBStream s) -> size_t"""
        ...
    
    def DisplaySourceLinesWithLineNumbersAndColumn(self, file, line, column, context_before, context_after, current_line_cstr, s):
        r"""DisplaySourceLinesWithLineNumbersAndColumn(SBSourceManager self, SBFileSpec file, uint32_t line, uint32_t column, uint32_t context_before, uint32_t context_after, char const * current_line_cstr, SBStream s) -> size_t"""
        ...
    


class SBStream:
    r"""
    Represents a destination for streaming data output to. By default, a string
    stream is created.

    For example (from test/source-manager/TestSourceManager.py), ::

            # Create the filespec for 'main.c'.
            filespec = lldb.SBFileSpec('main.c', False)
            source_mgr = self.dbg.GetSourceManager()
            # Use a string stream as the destination.
            stream = lldb.SBStream()
            source_mgr.DisplaySourceLinesWithLineNumbers(filespec,
                                                         self.line,
                                                         2, # context before
                                                         2, # context after
                                                         '=>', # prefix for current line
                                                         stream)

            #    2
            #    3    int main(int argc, char const *argv[]) {
            # => 4        printf('Hello world.\n'); // Set break point at this line.
            #    5        return 0;
            #    6    }
            self.expect(stream.GetData(), 'Source code displayed correctly',
                        exe=False,
                patterns = ['=> %d.*Hello world' % self.line])
    """
    thisown = ...
    __repr__ = ...
    def __init__(self) -> None:
        r"""__init__(SBStream self) -> SBStream"""
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBStream self) -> bool"""
        ...
    
    def GetData(self):
        r"""
        GetData(SBStream self) -> char const *

            If this stream is not redirected to a file, it will maintain a local
            cache for the stream data which can be accessed using this accessor.
        """
        ...
    
    def GetSize(self):
        r"""
        GetSize(SBStream self) -> size_t

            If this stream is not redirected to a file, it will maintain a local
            cache for the stream output whose length can be accessed using this
            accessor.
        """
        ...
    
    def Print(self, str):
        r"""Print(SBStream self, char const * str)"""
        ...
    
    def RedirectToFile(self, *args):
        r"""
        RedirectToFile(SBStream self, char const * path, bool append)
        RedirectToFile(SBStream self, SBFile file)
        RedirectToFile(SBStream self, lldb::FileSP file)
        """
        ...
    
    def RedirectToFileDescriptor(self, fd, transfer_fh_ownership):
        r"""RedirectToFileDescriptor(SBStream self, int fd, bool transfer_fh_ownership)"""
        ...
    
    def Clear(self):
        r"""
        Clear(SBStream self)

            If the stream is redirected to a file, forget about the file and if
            ownership of the file was transferred to this object, close the file.
            If the stream is backed by a local cache, clear this cache.
        """
        ...
    
    def RedirectToFileHandle(self, file, transfer_fh_ownership):
        r"""DEPRECATED, use RedirectToFile"""
        ...
    
    def write(self, str):
        r"""write(SBStream self, char const * str)"""
        ...
    
    def flush(self):
        r"""flush(SBStream self)"""
        ...
    


class SBStringList:
    r"""Represents a list of strings."""
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBStringList self) -> SBStringList
        __init__(SBStringList self, SBStringList rhs) -> SBStringList
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBStringList self) -> bool"""
        ...
    
    def AppendString(self, str):
        r"""AppendString(SBStringList self, char const * str)"""
        ...
    
    def AppendList(self, *args):
        r"""
        AppendList(SBStringList self, char const ** strv, int strc)
        AppendList(SBStringList self, SBStringList strings)
        """
        ...
    
    def GetSize(self):
        r"""GetSize(SBStringList self) -> uint32_t"""
        ...
    
    def GetStringAtIndex(self, *args):
        r"""
        GetStringAtIndex(SBStringList self, size_t idx) -> char const
        GetStringAtIndex(SBStringList self, size_t idx) -> char const *
        """
        ...
    
    def Clear(self):
        r"""Clear(SBStringList self)"""
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        '''Iterate over all strings in a lldb.SBStringList object.'''
        ...
    
    def __len__(self):
        '''Return the number of strings in a lldb.SBStringList object.'''
        ...
    


class SBStructuredData:
    r"""
    A class representing a StructuredData event.

    This class wraps the event type generated by StructuredData features.
    """
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBStructuredData self) -> SBStructuredData
        __init__(SBStructuredData self, SBStructuredData rhs) -> SBStructuredData
        __init__(SBStructuredData self, SBScriptObject obj, SBDebugger debugger) -> SBStructuredData
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBStructuredData self) -> bool"""
        ...
    
    def SetFromJSON(self, *args):
        r"""
        SetFromJSON(SBStructuredData self, SBStream stream) -> SBError
        SetFromJSON(SBStructuredData self, char const * json) -> SBError
        """
        ...
    
    def Clear(self):
        r"""Clear(SBStructuredData self)"""
        ...
    
    def GetAsJSON(self, stream):
        r"""GetAsJSON(SBStructuredData self, SBStream stream) -> SBError"""
        ...
    
    def GetDescription(self, stream):
        r"""GetDescription(SBStructuredData self, SBStream stream) -> SBError"""
        ...
    
    def GetType(self):
        r"""GetType(SBStructuredData self) -> lldb::StructuredDataType"""
        ...
    
    def GetSize(self):
        r"""GetSize(SBStructuredData self) -> size_t"""
        ...
    
    def GetKeys(self, keys):
        r"""GetKeys(SBStructuredData self, SBStringList keys) -> bool"""
        ...
    
    def GetValueForKey(self, key):
        r"""GetValueForKey(SBStructuredData self, char const * key) -> SBStructuredData"""
        ...
    
    def GetItemAtIndex(self, idx):
        r"""GetItemAtIndex(SBStructuredData self, size_t idx) -> SBStructuredData"""
        ...
    
    def GetUnsignedIntegerValue(self, fail_value=...):
        r"""GetUnsignedIntegerValue(SBStructuredData self, uint64_t fail_value=0) -> uint64_t"""
        ...
    
    def GetSignedIntegerValue(self, fail_value=...):
        r"""GetSignedIntegerValue(SBStructuredData self, int64_t fail_value=0) -> int64_t"""
        ...
    
    def GetIntegerValue(self, fail_value=...):
        r"""GetIntegerValue(SBStructuredData self, uint64_t fail_value=0) -> uint64_t"""
        ...
    
    def GetFloatValue(self, fail_value=...):
        r"""GetFloatValue(SBStructuredData self, double fail_value=0.0) -> double"""
        ...
    
    def GetBooleanValue(self, fail_value=...):
        r"""GetBooleanValue(SBStructuredData self, bool fail_value=False) -> bool"""
        ...
    
    def GetStringValue(self, dst):
        r"""GetStringValue(SBStructuredData self, char * dst) -> size_t"""
        ...
    
    def GetGenericValue(self):
        r"""GetGenericValue(SBStructuredData self) -> SBScriptObject"""
        ...
    


class SBSymbol:
    r"""
    Represents the symbol possibly associated with a stack frame.
    :py:class:`SBModule` contains SBSymbol(s). SBSymbol can also be retrieved from :py:class:`SBFrame` .
    """
    thisown = ...
    __swig_destroy__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBSymbol self) -> SBSymbol
        __init__(SBSymbol self, SBSymbol rhs) -> SBSymbol
        """
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self) -> bool:
        r"""IsValid(SBSymbol self) -> bool"""
        ...
    
    def GetName(self) -> str:
        r"""GetName(SBSymbol self) -> char const *"""
        ...
    
    def GetDisplayName(self) -> str:
        r"""GetDisplayName(SBSymbol self) -> char const *"""
        ...
    
    def GetMangledName(self) -> str:
        r"""GetMangledName(SBSymbol self) -> char const *"""
        ...
    
    def GetInstructions(self, *args) -> SBInstructionList:
        r"""
        GetInstructions(SBSymbol self, SBTarget target) -> SBInstructionList
        GetInstructions(SBSymbol self, SBTarget target, char const * flavor_string) -> SBInstructionList
        """
        ...
    
    def GetStartAddress(self) -> SBAddress:
        r"""GetStartAddress(SBSymbol self) -> SBAddress"""
        ...
    
    def GetEndAddress(self) -> SBAddress:
        r"""GetEndAddress(SBSymbol self) -> SBAddress"""
        ...
    
    def GetValue(self) -> int:
        r"""GetValue(SBSymbol self) -> uint64_t"""
        ...
    
    def GetSize(self) -> int:
        r"""GetSize(SBSymbol self) -> uint64_t"""
        ...
    
    def GetPrologueByteSize(self) -> int:
        r"""GetPrologueByteSize(SBSymbol self) -> uint32_t"""
        ...
    
    def GetType(self):
        r"""GetType(SBSymbol self) -> lldb::SymbolType"""
        ...
    
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBSymbol self, SBSymbol rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBSymbol self, SBSymbol rhs) -> bool"""
        ...
    
    def GetDescription(self, description: SBStream) -> bool:
        r"""GetDescription(SBSymbol self, SBStream description) -> bool"""
        ...
    
    def IsExternal(self) -> bool:
        r"""IsExternal(SBSymbol self) -> bool"""
        ...
    
    def IsSynthetic(self) -> bool:
        r"""IsSynthetic(SBSymbol self) -> bool"""
        ...
    
    def __repr__(self) -> str:
        r"""__repr__(SBSymbol self) -> std::string"""
        ...
    
    def get_instructions_from_current_target(self):
        ...
    
    name: str = ...
    mangled: str = ...
    type = ...
    addr: SBAddress = ...
    end_addr: SBAddress = ...
    prologue_size: int = ...
    instructions = ...
    external: bool = ...
    synthetic: bool = ...
    def __eq__(self, rhs) -> bool:
        ...
    
    def __ne__(self, rhs) -> bool:
        ...
    


class SBSymbolContext:
    r"""
    A context object that provides access to core debugger entities.

    Many debugger functions require a context when doing lookups. This class
    provides a common structure that can be used as the result of a query that
    can contain a single result.

    For example, ::

            exe = os.path.join(os.getcwd(), 'a.out')

            # Create a target for the debugger.
            target = self.dbg.CreateTarget(exe)

            # Now create a breakpoint on main.c by name 'c'.
            breakpoint = target.BreakpointCreateByName('c', 'a.out')

            # Now launch the process, and do not stop at entry point.
            process = target.LaunchSimple(None, None, os.getcwd())

            # The inferior should stop on 'c'.
            from lldbutil import get_stopped_thread
            thread = get_stopped_thread(process, lldb.eStopReasonBreakpoint)
            frame0 = thread.GetFrameAtIndex(0)

            # Now get the SBSymbolContext from this frame.  We want everything. :-)
            context = frame0.GetSymbolContext(lldb.eSymbolContextEverything)

            # Get the module.
            module = context.GetModule()
            ...

            # And the compile unit associated with the frame.
            compileUnit = context.GetCompileUnit()
            ...

    """
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBSymbolContext self) -> SBSymbolContext
        __init__(SBSymbolContext self, SBSymbolContext rhs) -> SBSymbolContext
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self) -> bool:
        r"""IsValid(SBSymbolContext self) -> bool"""
        ...
    
    def GetModule(self)-> SBModule:
        r"""GetModule(SBSymbolContext self) -> SBModule"""
        ...
    
    def GetCompileUnit(self) -> SBCompileUnit:
        r"""GetCompileUnit(SBSymbolContext self) -> SBCompileUnit"""
        ...
    
    def GetFunction(self) -> SBFunction:
        r"""GetFunction(SBSymbolContext self) -> SBFunction"""
        ...
    
    def GetBlock(self) -> SBBlock:
        r"""GetBlock(SBSymbolContext self) -> SBBlock"""
        ...
    
    def GetLineEntry(self) -> SBLineEntry:
        r"""GetLineEntry(SBSymbolContext self) -> SBLineEntry"""
        ...
    
    def GetSymbol(self) -> SBSymbol:
        r"""GetSymbol(SBSymbolContext self) -> SBSymbol"""
        ...
    
    def SetModule(self, module: SBModule):
        r"""SetModule(SBSymbolContext self, SBModule module)"""
        ...
    
    def SetCompileUnit(self, compile_unit: SBCompileUnit):
        r"""SetCompileUnit(SBSymbolContext self, SBCompileUnit compile_unit)"""
        ...
    
    def SetFunction(self, function: SBFunction):
        r"""SetFunction(SBSymbolContext self, SBFunction function)"""
        ...
    
    def SetBlock(self, block: SBBlock):
        r"""SetBlock(SBSymbolContext self, SBBlock block)"""
        ...
    
    def SetLineEntry(self, line_entry: SBLineEntry):
        r"""SetLineEntry(SBSymbolContext self, SBLineEntry line_entry)"""
        ...
    
    def SetSymbol(self, symbol: SBSymbol):
        r"""SetSymbol(SBSymbolContext self, SBSymbol symbol)"""
        ...
    
    def GetParentOfInlinedScope(self, curr_frame_pc: SBAddress, parent_frame_addr: SBAddress) -> SBSymbolContext:
        r"""GetParentOfInlinedScope(SBSymbolContext self, SBAddress curr_frame_pc, SBAddress parent_frame_addr) -> SBSymbolContext"""
        ...
    
    def GetDescription(self, description: SBStream) -> bool:
        r"""GetDescription(SBSymbolContext self, SBStream description) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBSymbolContext self) -> std::string"""
        ...
    
    module: SBModule = ...
    compile_unit: SBCompileUnit = ...
    function: SBFunction = ...
    block: SBBlock = ...
    symbol: SBSymbol = ...
    line_entry: SBLineEntry = ...


class SBSymbolContextList:
    r"""
    Represents a list of symbol context object. See also SBSymbolContext.

    For example (from test/python_api/target/TestTargetAPI.py), ::

        def find_functions(self, exe_name):
            '''Exercise SBTarget.FindFunctions() API.'''
            exe = os.path.join(os.getcwd(), exe_name)

            # Create a target by the debugger.
            target = self.dbg.CreateTarget(exe)
            self.assertTrue(target, VALID_TARGET)

            list = lldb.SBSymbolContextList()
            num = target.FindFunctions('c', lldb.eFunctionNameTypeAuto, False, list)
            self.assertTrue(num == 1 and list.GetSize() == 1)

            for sc in list:
                self.assertTrue(sc.GetModule().GetFileSpec().GetFilename() == exe_name)
                self.assertTrue(sc.GetSymbol().GetName() == 'c')
    """
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBSymbolContextList self) -> SBSymbolContextList
        __init__(SBSymbolContextList self, SBSymbolContextList rhs) -> SBSymbolContextList
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self) -> bool:
        r"""IsValid(SBSymbolContextList self) -> bool"""
        ...
    
    def GetSize(self) -> int:
        r"""GetSize(SBSymbolContextList self) -> uint32_t"""
        ...
    
    def GetContextAtIndex(self, idx) -> SBSymbolContext:
        r"""GetContextAtIndex(SBSymbolContextList self, uint32_t idx) -> SBSymbolContext"""
        ...
    
    def GetDescription(self, description: SBStream) -> bool:
        r"""GetDescription(SBSymbolContextList self, SBStream description) -> bool"""
        ...
    
    def Append(self, *args):
        r"""
        Append(SBSymbolContextList self, SBSymbolContext sc)
        Append(SBSymbolContextList self, SBSymbolContextList sc_list)
        """
        ...
    
    def Clear(self):
        r"""Clear(SBSymbolContextList self)"""
        ...
    
    def __repr__(self) -> str:
        r"""__repr__(SBSymbolContextList self) -> std::string"""
        ...
    
    def __iter__(self) -> Iterator[SBSymbolContext]:
        '''Iterate over all symbol contexts in a lldb.SBSymbolContextList
        object.'''
        ...
    
    def __len__(self) -> int:
        ...
    
    def __getitem__(self, key) -> SBSymbolContext:
        ...
    
    def get_module_array(self): # -> list[Any]:
        ...
    
    def get_compile_unit_array(self): # -> list[Any]:
        ...
    
    def get_function_array(self): # -> list[Any]:
        ...
    
    def get_block_array(self): # -> list[Any]:
        ...
    
    def get_symbol_array(self): # -> list[Any]:
        ...
    
    def get_line_entry_array(self): # -> list[Any]:
        ...
    
    modules = ...
    compile_units = ...
    functions = ...
    blocks = ...
    line_entries = ...
    symbols = ...


class SBTarget:
    r"""
    Represents the target program running under the debugger.

    SBTarget supports module, breakpoint, and watchpoint iterations. For example, ::

        for m in target.module_iter():
            print m

    produces: ::

        (x86_64) /Volumes/data/lldb/svn/trunk/test/python_api/lldbutil/iter/a.out
        (x86_64) /usr/lib/dyld
        (x86_64) /usr/lib/libstdc++.6.dylib
        (x86_64) /usr/lib/libSystem.B.dylib
        (x86_64) /usr/lib/system/libmathCommon.A.dylib
        (x86_64) /usr/lib/libSystem.B.dylib(__commpage)

    and, ::

        for b in target.breakpoint_iter():
            print b

    produces: ::

        SBBreakpoint: id = 1, file ='main.cpp', line = 66, locations = 1
        SBBreakpoint: id = 2, file ='main.cpp', line = 85, locations = 1

    and, ::

        for wp_loc in target.watchpoint_iter():
            print wp_loc

    produces: ::

        Watchpoint 1: addr = 0x1034ca048 size = 4 state = enabled type = rw
            declare @ '/Volumes/data/lldb/svn/trunk/test/python_api/watchpoint/main.c:12'
            hw_index = 0  hit_count = 2     ignore_count = 0
    """
    thisown = ...
    eBroadcastBitBreakpointChanged = ...
    eBroadcastBitModulesLoaded = ...
    eBroadcastBitModulesUnloaded = ...
    eBroadcastBitWatchpointChanged = ...
    eBroadcastBitSymbolsLoaded = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBTarget self) -> SBTarget
        __init__(SBTarget self, SBTarget rhs) -> SBTarget
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBTarget self) -> bool"""
        ...
    
    @staticmethod
    def EventIsTargetEvent(event: SBEvent) -> bool:
        r"""EventIsTargetEvent(SBEvent event) -> bool"""
        ...
    
    @staticmethod
    def GetTargetFromEvent(event: SBEvent) -> SBTarget:
        r"""GetTargetFromEvent(SBEvent event) -> SBTarget"""
        ...
    
    @staticmethod
    def GetNumModulesFromEvent(event: SBEvent) -> int:
        r"""GetNumModulesFromEvent(SBEvent event) -> uint32_t"""
        ...
    
    @staticmethod
    def GetModuleAtIndexFromEvent(idx: int, event: SBEvent) -> SBModule:
        r"""GetModuleAtIndexFromEvent(uint32_t const idx, SBEvent event) -> SBModule"""
        ...
    
    @staticmethod
    def GetBroadcasterClassName() -> str:
        r"""GetBroadcasterClassName() -> char const *"""
        ...
    
    def GetProcess(self) -> SBProcess:
        r"""GetProcess(SBTarget self) -> SBProcess"""
        ...
    
    def SetCollectingStats(self, v: bool):
        r"""SetCollectingStats(SBTarget self, bool v)"""
        ...
    
    def GetCollectingStats(self) -> bool:
        r"""GetCollectingStats(SBTarget self) -> bool"""
        ...
    
    def GetStatistics(self) -> SBStructuredData:
        r"""GetStatistics(SBTarget self) -> SBStructuredData"""
        ...
    
    def GetPlatform(self) -> SBPlatform:
        r"""
        GetPlatform(SBTarget self) -> SBPlatform

            Return the platform object associated with the target.

            After return, the platform object should be checked for
            validity.

            @return
                A platform object.
        """
        ...
    
    def GetEnvironment(self) -> SBEnvironment:
        r"""GetEnvironment(SBTarget self) -> SBEnvironment"""
        ...
    
    def Install(self) -> SBError:
        r"""
        Install(SBTarget self) -> SBError

            Install any binaries that need to be installed.

            This function does nothing when debugging on the host system.
            When connected to remote platforms, the target's main executable
            and any modules that have their install path set will be
            installed on the remote platform. If the main executable doesn't
            have an install location set, it will be installed in the remote
            platform's working directory.

            @return
                An error describing anything that went wrong during
                installation.
        """
        ...
    
    def LoadCore(self, *args) -> SBProcess:
        r"""
        LoadCore(SBTarget self, char const * core_file) -> SBProcess
        LoadCore(SBTarget self, char const * core_file, SBError error) -> SBProcess

            Load a core file

            @param[in] core_file
                File path of the core dump.

            @param[out] error
                An error explaining what went wrong if the operation fails.
                (Optional)

            @return
                 A process object for the newly created core file.

            For example,

                process = target.LoadCore('./a.out.core')

            loads a new core file and returns the process object.
        """
        ...
    
    def LaunchSimple(self, argv, envp, working_directory) -> SBProcess:
        r"""
        LaunchSimple(SBTarget self, char const ** argv, char const ** envp, char const * working_directory) -> SBProcess

            Launch a new process with sensible defaults.

            :param argv: The argument array.
            :param envp: The environment array.
            :param working_directory: The working directory to have the child process run in
            :return: The newly created process.
            :rtype: SBProcess

            A pseudo terminal will be used as stdin/stdout/stderr.
            No launch flags are passed and the target's debuger is used as a listener.

            For example, ::

                process = target.LaunchSimple(['X', 'Y', 'Z'], None, os.getcwd())

            launches a new process by passing 'X', 'Y', 'Z' as the args to the
            executable.
        """
        ...
    
    def Launch(self, *args) -> SBProcess:
        r"""
        Launch(SBTarget self, SBListener listener, char const ** argv, char const ** envp, char const * stdin_path, char const * stdout_path, char const * stderr_path, char const * working_directory, uint32_t launch_flags, bool stop_at_entry, SBError error) -> SBProcess
        Launch(SBTarget self, SBLaunchInfo launch_info, SBError error) -> SBProcess

            Launch a new process.

            Launch a new process by spawning a new process using the
            target object's executable module's file as the file to launch.
            Arguments are given in argv, and the environment variables
            are in envp. Standard input and output files can be
            optionally re-directed to stdin_path, stdout_path, and
            stderr_path.

            @param[in] listener
                An optional listener that will receive all process events.
                If listener is valid then listener will listen to all
                process events. If not valid, then this target's debugger
                (SBTarget::GetDebugger()) will listen to all process events.

            @param[in] argv
                The argument array.

            @param[in] envp
                The environment array.

            @param[in] launch_flags
                Flags to modify the launch (@see lldb::LaunchFlags)

            @param[in] stdin_path
                The path to use when re-directing the STDIN of the new
                process. If all stdXX_path arguments are NULL, a pseudo
                terminal will be used.

            @param[in] stdout_path
                The path to use when re-directing the STDOUT of the new
                process. If all stdXX_path arguments are NULL, a pseudo
                terminal will be used.

            @param[in] stderr_path
                The path to use when re-directing the STDERR of the new
                process. If all stdXX_path arguments are NULL, a pseudo
                terminal will be used.

            @param[in] working_directory
                The working directory to have the child process run in

            @param[in] launch_flags
                Some launch options specified by logical OR'ing
                lldb::LaunchFlags enumeration values together.

            @param[in] stop_at_entry
                If false do not stop the inferior at the entry point.

            @param[out]
                An error object. Contains the reason if there is some failure.

            @return
                 A process object for the newly created process.

            For example,

                process = target.Launch(self.dbg.GetListener(), None, None,
                                        None, '/tmp/stdout.txt', None,
                                        None, 0, False, error)

            launches a new process by passing nothing for both the args and the envs
            and redirect the standard output of the inferior to the /tmp/stdout.txt
            file. It does not specify a working directory so that the debug server
            will use its idea of what the current working directory is for the
            inferior. Also, we ask the debugger not to stop the inferior at the
            entry point. If no breakpoint is specified for the inferior, it should
            run to completion if no user interaction is required.
        """
        ...
    
    def Attach(self, attach_info: SBAttachInfo, error: SBError) -> SBProcess:
        r"""Attach(SBTarget self, SBAttachInfo attach_info, SBError error) -> SBProcess"""
        ...
    
    def AttachToProcessWithID(self, listener: SBListener, pid: int, error: SBError) -> SBProcess:
        r"""
        AttachToProcessWithID(SBTarget self, SBListener listener, lldb::pid_t pid, SBError error) -> SBProcess

            Attach to process with pid.

            @param[in] listener
                An optional listener that will receive all process events.
                If listener is valid then listener will listen to all
                process events. If not valid, then this target's debugger
                (SBTarget::GetDebugger()) will listen to all process events.

            @param[in] pid
                The process ID to attach to.

            @param[out]
                An error explaining what went wrong if attach fails.

            @return
                 A process object for the attached process.
        """
        ...
    
    def AttachToProcessWithName(self, listener: SBListener, name: str, wait_for: bool, error: SBError) -> SBProcess:
        r"""
        AttachToProcessWithName(SBTarget self, SBListener listener, char const * name, bool wait_for, SBError error) -> SBProcess

            Attach to process with name.

            @param[in] listener
                An optional listener that will receive all process events.
                If listener is valid then listener will listen to all
                process events. If not valid, then this target's debugger
                (SBTarget::GetDebugger()) will listen to all process events.

            @param[in] name
                Basename of process to attach to.

            @param[in] wait_for
                If true wait for a new instance of 'name' to be launched.

            @param[out]
                An error explaining what went wrong if attach fails.

            @return
                 A process object for the attached process.
        """
        ...
    
    def ConnectRemote(self, listener: SBListener, url: str, plugin_name: str, error: SBError) -> SBProcess:
        r"""
        ConnectRemote(SBTarget self, SBListener listener, char const * url, char const * plugin_name, SBError error) -> SBProcess

            Connect to a remote debug server with url.

            @param[in] listener
                An optional listener that will receive all process events.
                If listener is valid then listener will listen to all
                process events. If not valid, then this target's debugger
                (SBTarget::GetDebugger()) will listen to all process events.

            @param[in] url
                The url to connect to, e.g., 'connect://localhost:12345'.

            @param[in] plugin_name
                The plugin name to be used; can be NULL.

            @param[out]
                An error explaining what went wrong if the connect fails.

            @return
                 A process object for the connected process.
        """
        ...
    
    def GetExecutable(self) -> SBFileSpec:
        r"""GetExecutable(SBTarget self) -> SBFileSpec"""
        ...
    
    def AppendImageSearchPath(self, _from: str, to: str, error: SBError):
        r"""
        AppendImageSearchPath(SBTarget self, char const * _from, char const * to, SBError error)

            Append the path mapping (from -> to) to the target's paths mapping list.
        """
        ...
    
    def AddModule(self, *args):
        r"""
        AddModule(SBTarget self, SBModule module) -> bool
        AddModule(SBTarget self, char const * path, char const * triple, char const * uuid) -> SBModule
        AddModule(SBTarget self, char const * path, char const * triple, char const * uuid_cstr, char const * symfile) -> SBModule
        AddModule(SBTarget self, SBModuleSpec module_spec) -> SBModule
        """
        ...
    
    def GetNumModules(self) -> int:
        r"""GetNumModules(SBTarget self) -> uint32_t"""
        ...
    
    def GetModuleAtIndex(self, idx: int) -> SBModule:
        r"""GetModuleAtIndex(SBTarget self, uint32_t idx) -> SBModule"""
        ...
    
    def RemoveModule(self, module: SBModule) -> bool:
        r"""RemoveModule(SBTarget self, SBModule module) -> bool"""
        ...
    
    def GetDebugger(self) -> SBDebugger:
        r"""GetDebugger(SBTarget self) -> SBDebugger"""
        ...
    
    def FindModule(self, file_spec: SBFileSpec) -> SBModule:
        r"""FindModule(SBTarget self, SBFileSpec file_spec) -> SBModule"""
        ...
    
    def FindCompileUnits(self, sb_file_spec: SBFileSpec) -> SBSymbolContextList:
        r"""
        FindCompileUnits(SBTarget self, SBFileSpec sb_file_spec) -> SBSymbolContextList

            Find compile units related to this target and passed source
            file.

            :param sb_file_spec: A :py:class:`lldb::SBFileSpec` object that contains source file
                specification.
            :return: The symbol contexts for all the matches.
            :rtype: SBSymbolContextList
        """
        ...
    
    def GetByteOrder(self):
        r"""GetByteOrder(SBTarget self) -> lldb::ByteOrder"""
        ...
    
    def GetAddressByteSize(self) -> int:
        r"""GetAddressByteSize(SBTarget self) -> uint32_t"""
        ...
    
    def GetTriple(self) -> str:
        r"""GetTriple(SBTarget self) -> char const *"""
        ...
    
    def GetABIName(self) -> str:
        r"""GetABIName(SBTarget self) -> char const *"""
        ...
    
    def GetLabel(self) -> str:
        r"""GetLabel(SBTarget self) -> char const *"""
        ...
    
    def SetLabel(self, label: str) -> SBError:
        r"""SetLabel(SBTarget self, char const * label) -> SBError"""
        ...
    
    def GetDataByteSize(self) -> int:
        r"""
        GetDataByteSize(SBTarget self) -> uint32_t

            Architecture data byte width accessor

            :return: The size in 8-bit (host) bytes of a minimum addressable unit from the Architecture's data bus.


        """
        ...
    
    def GetCodeByteSize(self) -> int:
        r"""
        GetCodeByteSize(SBTarget self) -> uint32_t

            Architecture code byte width accessor.

            :return: The size in 8-bit (host) bytes of a minimum addressable unit from the Architecture's code bus.


        """
        ...
    
    def GetMaximumNumberOfChildrenToDisplay(self) -> int:
        r"""GetMaximumNumberOfChildrenToDisplay(SBTarget self) -> uint32_t"""
        ...
    
    def SetSectionLoadAddress(self, section: SBSection, section_base_addr: str) -> SBError:
        r"""SetSectionLoadAddress(SBTarget self, SBSection section, lldb::addr_t section_base_addr) -> SBError"""
        ...
    
    def ClearSectionLoadAddress(self, section: SBSection) -> SBError:
        r"""ClearSectionLoadAddress(SBTarget self, SBSection section) -> SBError"""
        ...
    
    def SetModuleLoadAddress(self, module: SBModule, sections_offset: int) -> SBError:
        r"""SetModuleLoadAddress(SBTarget self, SBModule module, uint64_t sections_offset) -> SBError"""
        ...
    
    def ClearModuleLoadAddress(self, module: SBModule) -> SBError:
        r"""ClearModuleLoadAddress(SBTarget self, SBModule module) -> SBError"""
        ...
    
    def FindFunctions(self, *args) -> SBSymbolContextList:
        r"""
        FindFunctions(SBTarget self, char const * name, uint32_t name_type_mask=eFunctionNameTypeAny) -> SBSymbolContextList

            Find functions by name.

            :param name: The name of the function we are looking for.

            :param name_type_mask:
                A logical OR of one or more FunctionNameType enum bits that
                indicate what kind of names should be used when doing the
                lookup. Bits include fully qualified names, base names,
                C++ methods, or ObjC selectors.
                See FunctionNameType for more details.

            :return:
                A lldb::SBSymbolContextList that gets filled in with all of
                the symbol contexts for all the matches.
        """
        ...
    
    def FindFirstGlobalVariable(self, name: str) -> SBValue:
        r"""
        FindFirstGlobalVariable(SBTarget self, char const * name) -> SBValue

            Find the first global (or static) variable by name.

            @param[in] name
                The name of the global or static variable we are looking
                for.

            @return
                An SBValue that gets filled in with the found variable (if any).
        """
        ...
    
    def FindGlobalVariables(self, *args) -> SBValueList:
        r"""
        FindGlobalVariables(SBTarget self, char const * name, uint32_t max_matches) -> SBValueList
        FindGlobalVariables(SBTarget self, char const * name, uint32_t max_matches, lldb::MatchType matchtype) -> SBValueList

            Find global and static variables by name.

            @param[in] name
                The name of the global or static variable we are looking
                for.

            @param[in] max_matches
                Allow the number of matches to be limited to max_matches.

            @return
                A list of matched variables in an SBValueList.
        """
        ...
    
    def FindGlobalFunctions(self, name, max_matches, matchtype) -> SBSymbolContextList:
        r"""FindGlobalFunctions(SBTarget self, char const * name, uint32_t max_matches, lldb::MatchType matchtype) -> SBSymbolContextList"""
        ...
    
    def Clear(self):
        r"""Clear(SBTarget self)"""
        ...
    
    def ResolveFileAddress(self, file_addr: int) -> SBAddress:
        r"""
        ResolveFileAddress(SBTarget self, lldb::addr_t file_addr) -> SBAddress

            Resolve a current file address into a section offset address.

            @param[in] file_addr

            @return
                An SBAddress which will be valid if...
        """
        ...
    
    def ResolveLoadAddress(self, vm_addr: int) -> SBAddress:
        r"""ResolveLoadAddress(SBTarget self, lldb::addr_t vm_addr) -> SBAddress"""
        ...
    
    def ResolvePastLoadAddress(self, stop_id: int, vm_addr: int) -> SBAddress:
        r"""ResolvePastLoadAddress(SBTarget self, uint32_t stop_id, lldb::addr_t vm_addr) -> SBAddress"""
        ...
    
    def ResolveSymbolContextForAddress(self, addr: SBAddress, resolve_scope: int) -> SBSymbolContext:
        r"""ResolveSymbolContextForAddress(SBTarget self, SBAddress addr, uint32_t resolve_scope) -> SBSymbolContext"""
        ...
    
    def ReadMemory(self, addr, buf, error: SBError) -> int:
        r"""
        ReadMemory(SBTarget self, SBAddress addr, void * buf, SBError error) -> size_t

            Read target memory. If a target process is running then memory
            is read from here. Otherwise the memory is read from the object
            files. For a target whose bytes are sized as a multiple of host
            bytes, the data read back will preserve the target's byte order.

            @param[in] addr
                A target address to read from.

            @param[out] buf
                The buffer to read memory into.

            @param[in] size
                The maximum number of host bytes to read in the buffer passed
                into this call

            @param[out] error
                Error information is written here if the memory read fails.

            @return
                The amount of data read in host bytes.
        """
        ...
    
    def BreakpointCreateByLocation(self, *args) -> SBBreakpoint:
        r"""
        BreakpointCreateByLocation(SBTarget self, char const * file, uint32_t line) -> SBBreakpoint
        BreakpointCreateByLocation(SBTarget self, SBFileSpec file_spec, uint32_t line) -> SBBreakpoint
        BreakpointCreateByLocation(SBTarget self, SBFileSpec file_spec, uint32_t line, lldb::addr_t offset) -> SBBreakpoint
        BreakpointCreateByLocation(SBTarget self, SBFileSpec file_spec, uint32_t line, lldb::addr_t offset, SBFileSpecList module_list) -> SBBreakpoint
        BreakpointCreateByLocation(SBTarget self, SBFileSpec file_spec, uint32_t line, uint32_t column, lldb::addr_t offset, SBFileSpecList module_list) -> SBBreakpoint
        BreakpointCreateByLocation(SBTarget self, SBFileSpec file_spec, uint32_t line, uint32_t column, lldb::addr_t offset, SBFileSpecList module_list, bool move_to_nearest_code) -> SBBreakpoint
        """
        ...
    
    def BreakpointCreateByName(self, *args) -> SBBreakpoint:
        r"""
        BreakpointCreateByName(SBTarget self, char const * symbol_name, char const * module_name=None) -> SBBreakpoint
        BreakpointCreateByName(SBTarget self, char const * symbol_name, SBFileSpecList module_list, SBFileSpecList comp_unit_list) -> SBBreakpoint
        BreakpointCreateByName(SBTarget self, char const * symbol_name, uint32_t name_type_mask, SBFileSpecList module_list, SBFileSpecList comp_unit_list) -> SBBreakpoint
        BreakpointCreateByName(SBTarget self, char const * symbol_name, uint32_t name_type_mask, lldb::LanguageType symbol_language, SBFileSpecList module_list, SBFileSpecList comp_unit_list) -> SBBreakpoint
        """
        ...
    
    def BreakpointCreateByNames(self, *args) -> SBBreakpoint:
        r"""
        BreakpointCreateByNames(SBTarget self, char const ** symbol_name, uint32_t name_type_mask, SBFileSpecList module_list, SBFileSpecList comp_unit_list) -> SBBreakpoint
        BreakpointCreateByNames(SBTarget self, char const ** symbol_name, uint32_t name_type_mask, lldb::LanguageType symbol_language, SBFileSpecList module_list, SBFileSpecList comp_unit_list) -> SBBreakpoint
        BreakpointCreateByNames(SBTarget self, char const ** symbol_name, uint32_t name_type_mask, lldb::LanguageType symbol_language, lldb::addr_t offset, SBFileSpecList module_list, SBFileSpecList comp_unit_list) -> SBBreakpoint
        """
        ...
    
    def BreakpointCreateByRegex(self, *args) -> SBBreakpoint:
        r"""
        BreakpointCreateByRegex(SBTarget self, char const * symbol_name_regex, char const * module_name=None) -> SBBreakpoint
        BreakpointCreateByRegex(SBTarget self, char const * symbol_name_regex, SBFileSpecList module_list, SBFileSpecList comp_unit_list) -> SBBreakpoint
        BreakpointCreateByRegex(SBTarget self, char const * symbol_name_regex, lldb::LanguageType symbol_language, SBFileSpecList module_list, SBFileSpecList comp_unit_list) -> SBBreakpoint
        """
        ...
    
    def BreakpointCreateBySourceRegex(self, *args) -> SBBreakpoint:
        r"""
        BreakpointCreateBySourceRegex(SBTarget self, char const * source_regex, SBFileSpec source_file, char const * module_name=None) -> SBBreakpoint
        BreakpointCreateBySourceRegex(SBTarget self, char const * source_regex, SBFileSpecList module_list, SBFileSpecList source_file) -> SBBreakpoint
        BreakpointCreateBySourceRegex(SBTarget self, char const * source_regex, SBFileSpecList module_list, SBFileSpecList source_file, SBStringList func_names) -> SBBreakpoint
        """
        ...
    
    def BreakpointCreateForException(self, *args) -> SBBreakpoint:
        r"""
        BreakpointCreateForException(SBTarget self, lldb::LanguageType language, bool catch_bp, bool throw_bp) -> SBBreakpoint
        BreakpointCreateForException(SBTarget self, lldb::LanguageType language, bool catch_bp, bool throw_bp, SBStringList extra_args) -> SBBreakpoint
        """
        ...
    
    def BreakpointCreateByAddress(self, address: int) -> SBBreakpoint:
        r"""BreakpointCreateByAddress(SBTarget self, lldb::addr_t address) -> SBBreakpoint"""
        ...
    
    def BreakpointCreateBySBAddress(self, address: SBAddress) -> SBBreakpoint:
        r"""BreakpointCreateBySBAddress(SBTarget self, SBAddress address) -> SBBreakpoint"""
        ...
    
    def BreakpointCreateFromScript(self, class_name: str, extra_args: SBStructuredData, module_list: SBFileSpecList, file_list: SBFileSpecList, request_hardware: bool=...) -> SBBreakpoint:
        r"""
        BreakpointCreateFromScript(SBTarget self, char const * class_name, SBStructuredData extra_args, SBFileSpecList module_list, SBFileSpecList file_list, bool request_hardware=False) -> SBBreakpoint

            Create a breakpoint using a scripted resolver.

            @param[in] class_name
               This is the name of the class that implements a scripted resolver.
               The class should have the following signature: ::

                   class Resolver:
                       def __init__(self, bkpt, extra_args):
                           # bkpt - the breakpoint for which this is the resolver.  When
                           # the resolver finds an interesting address, call AddLocation
                           # on this breakpoint to add it.
                           #
                           # extra_args - an SBStructuredData that can be used to
                           # parametrize this instance.  Same as the extra_args passed
                           # to BreakpointCreateFromScript.

                       def __get_depth__ (self):
                           # This is optional, but if defined, you should return the
                           # depth at which you want the callback to be called.  The
                           # available options are:
                           #    lldb.eSearchDepthModule
                           #    lldb.eSearchDepthCompUnit
                           # The default if you don't implement this method is
                           # eSearchDepthModule.

                       def __callback__(self, sym_ctx):
                           # sym_ctx - an SBSymbolContext that is the cursor in the
                           # search through the program to resolve breakpoints.
                           # The sym_ctx will be filled out to the depth requested in
                           # __get_depth__.
                           # Look in this sym_ctx for new breakpoint locations,
                           # and if found use bkpt.AddLocation to add them.
                           # Note, you will only get called for modules/compile_units that
                           # pass the SearchFilter provided by the module_list & file_list
                           # passed into BreakpointCreateFromScript.

                       def get_short_help(self):
                           # Optional, but if implemented return a short string that will
                           # be printed at the beginning of the break list output for the
                           # breakpoint.

            @param[in] extra_args
               This is an SBStructuredData object that will get passed to the
               constructor of the class in class_name.  You can use this to
               reuse the same class, parametrizing it with entries from this
               dictionary.

            @param module_list
               If this is non-empty, this will be used as the module filter in the
               SearchFilter created for this breakpoint.

            @param file_list
               If this is non-empty, this will be used as the comp unit filter in the
               SearchFilter created for this breakpoint.

            @return
                An SBBreakpoint that will set locations based on the logic in the
                resolver's search callback.
        """
        ...
    
    def BreakpointsCreateFromFile(self, *args):
        r"""
        BreakpointsCreateFromFile(SBTarget self, SBFileSpec source_file, SBBreakpointList new_bps) -> SBError
        BreakpointsCreateFromFile(SBTarget self, SBFileSpec source_file, SBStringList matching_names, SBBreakpointList new_bps) -> SBError

            Read breakpoints from source_file and return the newly created
            breakpoints in bkpt_list.

            @param[in] source_file
               The file from which to read the breakpoints

            @param[in] matching_names
               Only read in breakpoints whose names match one of the names in this
               list.

            @param[out] bkpt_list
               A list of the newly created breakpoints.

            @return
                An SBError detailing any errors in reading in the breakpoints.
        """
        ...
    
    def BreakpointsWriteToFile(self, *args):
        r"""
        BreakpointsWriteToFile(SBTarget self, SBFileSpec dest_file) -> SBError
        BreakpointsWriteToFile(SBTarget self, SBFileSpec dest_file, SBBreakpointList bkpt_list, bool append=False) -> SBError

            Write breakpoints listed in bkpt_list to dest_file.

            @param[in] dest_file
               The file to which to write the breakpoints.

            @param[in] bkpt_list
               Only write breakpoints from this list.

            @param[in] append
               If true, append the breakpoints in bkpt_list to the others
               serialized in dest_file.  If dest_file doesn't exist, then a new
               file will be created and the breakpoints in bkpt_list written to it.

            @return
                An SBError detailing any errors in writing in the breakpoints.
        """
        ...
    
    def GetNumBreakpoints(self):
        r"""GetNumBreakpoints(SBTarget self) -> uint32_t"""
        ...
    
    def GetBreakpointAtIndex(self, idx: int) -> SBBreakpoint:
        r"""GetBreakpointAtIndex(SBTarget self, uint32_t idx) -> SBBreakpoint"""
        ...
    
    def BreakpointDelete(self, break_id) -> bool:
        r"""BreakpointDelete(SBTarget self, lldb::break_id_t break_id) -> bool"""
        ...
    
    def FindBreakpointByID(self, break_id) -> SBBreakpoint:
        r"""FindBreakpointByID(SBTarget self, lldb::break_id_t break_id) -> SBBreakpoint"""
        ...
    
    def FindBreakpointsByName(self, name: str, bkpt_list: SBBreakpointList) -> bool:
        r"""FindBreakpointsByName(SBTarget self, char const * name, SBBreakpointList bkpt_list) -> bool"""
        ...
    
    def GetBreakpointNames(self, names: SBStringList):
        r"""GetBreakpointNames(SBTarget self, SBStringList names)"""
        ...
    
    def DeleteBreakpointName(self, name: str):
        r"""DeleteBreakpointName(SBTarget self, char const * name)"""
        ...
    
    def EnableAllBreakpoints(self) -> bool:
        r"""EnableAllBreakpoints(SBTarget self) -> bool"""
        ...
    
    def DisableAllBreakpoints(self) -> bool:
        r"""DisableAllBreakpoints(SBTarget self) -> bool"""
        ...
    
    def DeleteAllBreakpoints(self) -> bool:
        r"""DeleteAllBreakpoints(SBTarget self) -> bool"""
        ...
    
    def GetNumWatchpoints(self) -> int:
        r"""GetNumWatchpoints(SBTarget self) -> uint32_t"""
        ...
    
    def GetWatchpointAtIndex(self, idx: int) -> SBWatchpoint:
        r"""GetWatchpointAtIndex(SBTarget self, uint32_t idx) -> SBWatchpoint"""
        ...
    
    def DeleteWatchpoint(self, watch_id) -> bool:
        r"""DeleteWatchpoint(SBTarget self, lldb::watch_id_t watch_id) -> bool"""
        ...
    
    def FindWatchpointByID(self, watch_id) -> SBWatchpoint:
        r"""FindWatchpointByID(SBTarget self, lldb::watch_id_t watch_id) -> SBWatchpoint"""
        ...
    
    def WatchAddress(self, addr: int, size: int, read: bool, write: bool, error: SBError) -> SBWatchpoint:
        r"""WatchAddress(SBTarget self, lldb::addr_t addr, size_t size, bool read, bool write, SBError error) -> SBWatchpoint"""
        ...
    
    def EnableAllWatchpoints(self) -> bool:
        r"""EnableAllWatchpoints(SBTarget self) -> bool"""
        ...
    
    def DisableAllWatchpoints(self) -> bool:
        r"""DisableAllWatchpoints(SBTarget self) -> bool"""
        ...
    
    def DeleteAllWatchpoints(self) -> bool:
        r"""DeleteAllWatchpoints(SBTarget self) -> bool"""
        ...
    
    def GetBroadcaster(self) -> SBBroadcaster:
        r"""GetBroadcaster(SBTarget self) -> SBBroadcaster"""
        ...
    
    def FindFirstType(self, type: str) -> SBType:
        r"""FindFirstType(SBTarget self, char const * type) -> SBType"""
        ...
    
    def FindTypes(self, type: str) -> SBTypeList:
        r"""FindTypes(SBTarget self, char const * type) -> SBTypeList"""
        ...
    
    def GetBasicType(self, type) -> SBType:
        r"""GetBasicType(SBTarget self, lldb::BasicType type) -> SBType"""
        ...
    
    def CreateValueFromAddress(self, name: str, addr: SBAddress, type: SBType) -> SBValue:
        r"""
        CreateValueFromAddress(SBTarget self, char const * name, SBAddress addr, SBType type) -> SBValue

            Create an SBValue with the given name by treating the memory starting at addr as an entity of type.

            @param[in] name
                The name of the resultant SBValue

            @param[in] addr
                The address of the start of the memory region to be used.

            @param[in] type
                The type to use to interpret the memory starting at addr.

            @return
                An SBValue of the given type, may be invalid if there was an error reading
                the underlying memory.
        """
        ...
    
    def CreateValueFromData(self, name: str, data: SBData, type: SBType) -> SBValue:
        r"""CreateValueFromData(SBTarget self, char const * name, SBData data, SBType type) -> SBValue"""
        ...
    
    def CreateValueFromExpression(self, name: str, expr: str) -> SBValue:
        r"""CreateValueFromExpression(SBTarget self, char const * name, char const * expr) -> SBValue"""
        ...
    
    def GetSourceManager(self) -> SBSourceManager:
        r"""GetSourceManager(SBTarget self) -> SBSourceManager"""
        ...
    
    def ReadInstructions(self, *args) -> SBInstructionList:
        r"""
        ReadInstructions(SBTarget self, SBAddress base_addr, uint32_t count) -> SBInstructionList
        ReadInstructions(SBTarget self, SBAddress base_addr, uint32_t count, char const * flavor_string) -> SBInstructionList

            Disassemble a specified number of instructions starting at an address.

            :param base_addr: the address to start disassembly from.
            :param count: the number of instructions to disassemble.
            :param flavor_string: may be 'intel' or 'att' on x86 targets to specify that style of disassembly.
            :rtype: SBInstructionList

        """
        ...
    
    def GetInstructions(self, base_addr: SBAddress, buf) -> SBInstructionList:
        r"""
        GetInstructions(SBTarget self, SBAddress base_addr, void const * buf) -> SBInstructionList

            Disassemble the bytes in a buffer and return them in an SBInstructionList.

            :param base_addr: used for symbolicating the offsets in the byte stream when disassembling.
            :param buf: bytes to be disassembled.
            :param size: (C++) size of the buffer.
            :rtype: SBInstructionList

        """
        ...
    
    def GetInstructionsWithFlavor(self, base_addr: SBAddress, flavor_string: str, buf) -> SBInstructionList:
        r"""
        GetInstructionsWithFlavor(SBTarget self, SBAddress base_addr, char const * flavor_string, void const * buf) -> SBInstructionList

            Disassemble the bytes in a buffer and return them in an SBInstructionList, with a supplied flavor.

            :param base_addr: used for symbolicating the offsets in the byte stream when disassembling.
            :param flavor:  may be 'intel' or 'att' on x86 targets to specify that style of disassembly.
            :param buf: bytes to be disassembled.
            :param size: (C++) size of the buffer.
            :rtype: SBInstructionList

        """
        ...
    
    def FindSymbols(self, *args) -> SBSymbolContextList:
        r"""FindSymbols(SBTarget self, char const * name, lldb::SymbolType type=eSymbolTypeAny) -> SBSymbolContextList"""
        ...
    
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBTarget self, SBTarget rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBTarget self, SBTarget rhs) -> bool"""
        ...
    
    def GetDescription(self, description: SBStream, description_level) -> bool:
        r"""GetDescription(SBTarget self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        ...
    
    def EvaluateExpression(self, *args) -> SBValue:
        r"""
        EvaluateExpression(SBTarget self, char const * expr) -> SBValue
        EvaluateExpression(SBTarget self, char const * expr, SBExpressionOptions options) -> SBValue
        """
        ...
    
    def GetStackRedZoneSize(self) -> int:
        r"""GetStackRedZoneSize(SBTarget self) -> lldb::addr_t"""
        ...
    
    def IsLoaded(self, module: SBModule) -> bool:
        r"""
        IsLoaded(SBTarget self, SBModule module) -> bool

            Returns true if the module has been loaded in this `SBTarget`.
            A module can be loaded either by the dynamic loader or by being manually
            added to the target (see `SBTarget.AddModule` and the ``target module add`` command).

            :rtype: bool

        """
        ...
    
    def GetLaunchInfo(self) -> SBLaunchInfo:
        r"""GetLaunchInfo(SBTarget self) -> SBLaunchInfo"""
        ...
    
    def SetLaunchInfo(self, launch_info: SBLaunchInfo):
        r"""SetLaunchInfo(SBTarget self, SBLaunchInfo launch_info)"""
        ...

    def GetTrace(self) -> SBTrace:
        r"""GetTrace(SBTarget self) -> SBTrace"""
        ...
    
    def CreateTrace(self, error: SBError) -> SBTrace:
        r"""CreateTrace(SBTarget self, SBError error) -> SBTrace"""
        ...
    
    def __repr__(self) -> str:
        r"""__repr__(SBTarget self) -> std::string"""
        ...
    
    class modules_access:
        '''A helper object that will lazily hand out lldb.SBModule objects for a target when supplied an index, or by full or partial path.'''
        def __init__(self, sbtarget) -> None:
            ...
        
        def __len__(self): # -> int:
            ...
        
        def __getitem__(self, key): # -> list[Any] | None:
            ...
        
    
    
    def get_modules_access_object(self): # -> modules_access:
        '''An accessor function that returns a modules_access() object which allows lazy module access from a lldb.SBTarget object.'''
        ...
    
    def get_modules_array(self): # -> list[Any]:
        '''An accessor function that returns a list() that contains all modules in a lldb.SBTarget object.'''
        ...
    
    def module_iter(self): # -> Generator[Any, Any, None]:
        '''Returns an iterator over all modules in a lldb.SBTarget
        object.'''
        ...
    
    def breakpoint_iter(self): # -> Generator[Any, Any, None]:
        '''Returns an iterator over all breakpoints in a lldb.SBTarget
        object.'''
        ...
    
    class bkpts_access:
        '''A helper object that will lazily hand out bkpts for a target when supplied an index.'''
        def __init__(self, sbtarget) -> None:
            ...
        
        def __len__(self): # -> int:
            ...
        
        def __getitem__(self, key): # -> None:
            ...
        
    
    
    def get_bkpts_access_object(self): # -> bkpts_access:
        '''An accessor function that returns a bkpts_access() object which allows lazy bkpt access from a lldb.SBtarget object.'''
        ...
    
    def get_target_bkpts(self): # -> list[Any]:
        '''An accessor function that returns a list() that contains all bkpts in a lldb.SBtarget object.'''
        ...
    
    def watchpoint_iter(self): # -> Generator[Any, Any, None]:
        '''Returns an iterator over all watchpoints in a lldb.SBTarget
        object.'''
        ...
    
    class watchpoints_access:
        '''A helper object that will lazily hand out watchpoints for a target when supplied an index.'''
        def __init__(self, sbtarget) -> None:
            ...
        
        def __len__(self): # -> int:
            ...
        
        def __getitem__(self, key): # -> None:
            ...
        
    
    
    def get_watchpoints_access_object(self): # -> watchpoints_access:
        '''An accessor function that returns a watchpoints_access() object which allows lazy watchpoint access from a lldb.SBtarget object.'''
        ...
    
    def get_target_watchpoints(self): # -> list[Any]:
        '''An accessor function that returns a list() that contains all watchpoints in a lldb.SBtarget object.'''
        ...
    
    modules = ...
    module: SBModule = ...
    process: SBProcess = ...
    executable: SBFileSpec = ...
    debugger: SBDebugger = ...
    num_breakpoints: int = ...
    breakpoints = ...
    breakpoint = ...
    num_watchpoints: int = ...
    watchpoints = ...
    watchpoint = ...
    broadcaster: SBBroadcaster = ...
    byte_order = ...
    addr_size: int = ...
    triple: str = ...
    data_byte_size: int = ...
    code_byte_size: int = ...
    platform: SBPlatform = ...
    def __eq__(self, rhs) -> bool:
        ...
    
    def __ne__(self, rhs) -> bool:
        ...


class SBThread:
    r"""
    Represents a thread of execution. :py:class:`SBProcess` contains SBThread(s).

    SBThreads can be referred to by their ID, which maps to the system specific thread
    identifier, or by IndexID.  The ID may or may not be unique depending on whether the
    system reuses its thread identifiers.  The IndexID is a monotonically increasing identifier
    that will always uniquely reference a particular thread, and when that thread goes
    away it will not be reused.

    SBThread supports frame iteration. For example (from test/python_api/
    lldbutil/iter/TestLLDBIterator.py), ::

            from lldbutil import print_stacktrace
            stopped_due_to_breakpoint = False
            for thread in process:
                if self.TraceOn():
                    print_stacktrace(thread)
                ID = thread.GetThreadID()
                if thread.GetStopReason() == lldb.eStopReasonBreakpoint:
                    stopped_due_to_breakpoint = True
                for frame in thread:
                    self.assertTrue(frame.GetThread().GetThreadID() == ID)
                    if self.TraceOn():
                        print frame

            self.assertTrue(stopped_due_to_breakpoint)

    See also :py:class:`SBFrame` .
    """
    thisown = ...
    eBroadcastBitStackChanged = ...
    eBroadcastBitThreadSuspended = ...
    eBroadcastBitThreadResumed = ...
    eBroadcastBitSelectedFrameChanged = ...
    eBroadcastBitThreadSelected = ...
    @staticmethod
    def GetBroadcasterClassName():
        r"""GetBroadcasterClassName() -> char const *"""
        ...
    
    def __init__(self, *args) -> None:
        r"""
        __init__(SBThread self) -> SBThread
        __init__(SBThread self, SBThread thread) -> SBThread
        """
        ...
    
    __swig_destroy__ = ...
    def GetQueue(self):
        r"""

        Return the SBQueue for this thread.  If this thread is not currently associated
        with a libdispatch queue, the SBQueue object's IsValid() method will return false.
        If this SBThread is actually a HistoryThread, we may be able to provide QueueID
        and QueueName, but not provide an SBQueue.  Those individual attributes may have
        been saved for the HistoryThread without enough information to reconstitute the
        entire SBQueue at that time.
        This method takes no arguments, returns an SBQueue.
        """
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self) -> bool:
        r"""IsValid(SBThread self) -> bool"""
        ...
    
    def Clear(self):
        r"""Clear(SBThread self)"""
        ...
    
    def GetStopReason(self):
        r"""GetStopReason(SBThread self) -> lldb::StopReason"""
        ...
    
    def GetStopReasonDataCount(self) -> int:
        r"""
        GetStopReasonDataCount(SBThread self) -> size_t

            Get the number of words associated with the stop reason.
            See also GetStopReasonDataAtIndex().
        """
        ...
    
    def GetStopReasonDataAtIndex(self, idx: int) -> int:
        r"""
        GetStopReasonDataAtIndex(SBThread self, uint32_t idx) -> uint64_t

            Get information associated with a stop reason.

            Breakpoint stop reasons will have data that consists of pairs of
            breakpoint IDs followed by the breakpoint location IDs (they always come
            in pairs).

            Stop Reason              Count Data Type
            ======================== ===== =========================================
            eStopReasonNone          0
            eStopReasonTrace         0
            eStopReasonBreakpoint    N     duple: {breakpoint id, location id}
            eStopReasonWatchpoint    1     watchpoint id
            eStopReasonSignal        1     unix signal number
            eStopReasonException     N     exception data
            eStopReasonExec          0
            eStopReasonFork          1     pid of the child process
            eStopReasonVFork         1     pid of the child process
            eStopReasonVForkDone     0
            eStopReasonPlanComplete  0
        """
        ...
    
    def GetStopReasonExtendedInfoAsJSON(self, stream):
        r"""

        Collects a thread's stop reason extended information dictionary and prints it
        into the SBStream in a JSON format. The format of this JSON dictionary depends
        on the stop reason and is currently used only for instrumentation plugins.
        """
        ...
    
    def GetStopReasonExtendedBacktraces(self, type):
        r"""

        Returns a collection of historical stack traces that are significant to the
        current stop reason. Used by ThreadSanitizer, where we provide various stack
        traces that were involved in a data race or other type of detected issue.
        """
        ...
    
    def GetStopDescription(self, dst_or_null):
        r"""

        Pass only an (int)length and expect to get a Python string describing the
        stop reason.
        """
        ...
    
    def GetStopReturnValue(self) -> SBValue:
        r"""GetStopReturnValue(SBThread self) -> SBValue"""
        ...
    
    def GetStopErrorValue(self) -> SBValue:
        r"""GetStopErrorValue(SBThread self) -> SBValue"""
        ...
    
    def GetStopReturnOrErrorValue(self, is_swift_error_value) -> SBValue:
        r"""GetStopReturnOrErrorValue(SBThread self, bool & is_swift_error_value) -> SBValue"""
        ...
    
    def GetThreadID(self):
        r"""

        Returns a unique thread identifier (type lldb::tid_t, typically a 64-bit type)
        for the current SBThread that will remain constant throughout the thread's
        lifetime in this process and will not be reused by another thread during this
        process lifetime.  On Mac OS X systems, this is a system-wide unique thread
        identifier; this identifier is also used by other tools like sample which helps
        to associate data from those tools with lldb.  See related GetIndexID.
        """
        ...
    
    def GetIndexID(self):
        r"""

        Return the index number for this SBThread.  The index number is the same thing
        that a user gives as an argument to 'thread select' in the command line lldb.
        These numbers start at 1 (for the first thread lldb sees in a debug session)
        and increments up throughout the process lifetime.  An index number will not be
        reused for a different thread later in a process - thread 1 will always be
        associated with the same thread.  See related GetThreadID.
        This method returns a uint32_t index number, takes no arguments.
        """
        ...
    
    def GetName(self) -> str:
        r"""GetName(SBThread self) -> char const *"""
        ...
    
    def GetQueueName(self):
        r"""

        Return the queue name associated with this thread, if any, as a str.
        For example, with a libdispatch (aka Grand Central Dispatch) queue.
        """
        ...
    
    def GetQueueID(self):
        r"""

        Return the dispatch_queue_id for this thread, if any, as a lldb::queue_id_t.
        For example, with a libdispatch (aka Grand Central Dispatch) queue.
        """
        ...
    
    def GetInfoItemByPathAsString(self, path: str, strm: SBStream) -> bool:
        r"""
        GetInfoItemByPathAsString(SBThread self, char const * path, SBStream strm) -> bool

            Takes a path string and a SBStream reference as parameters, returns a bool.
            Collects the thread's 'info' dictionary from the remote system, uses the path
            argument to descend into the dictionary to an item of interest, and prints
            it into the SBStream in a natural format.  Return bool is to indicate if
            anything was printed into the stream (true) or not (false).
        """
        ...
    
    def StepOver(self, *args):
        r"""
        StepOver(SBThread self, lldb::RunMode stop_other_threads=eOnlyDuringStepping)
        StepOver(SBThread self, lldb::RunMode stop_other_threads, SBError error)
        Do a source level single step over in the currently selected thread.
        """
        ...
    
    def StepInto(self, *args):
        r"""
        StepInto(SBThread self, lldb::RunMode stop_other_threads=eOnlyDuringStepping)
        StepInto(SBThread self, char const * target_name, lldb::RunMode stop_other_threads=eOnlyDuringStepping)
        StepInto(SBThread self, char const * target_name, uint32_t end_line, SBError error, lldb::RunMode stop_other_threads=eOnlyDuringStepping)

            Step the current thread from the current source line to the line given by end_line, stopping if
            the thread steps into the function given by target_name.  If target_name is None, then stepping will stop
            in any of the places we would normally stop.
        """
        ...
    
    def StepOut(self, *args):
        r"""
        StepOut(SBThread self)
        StepOut(SBThread self, SBError error)
        Step out of the currently selected thread.
        """
        ...
    
    def StepOutOfFrame(self, *args):
        r"""
        StepOutOfFrame(SBThread self, SBFrame frame)
        StepOutOfFrame(SBThread self, SBFrame frame, SBError error)
        Step out of the specified frame.
        """
        ...
    
    def StepInstruction(self, *args):
        r"""
        StepInstruction(SBThread self, bool step_over)
        StepInstruction(SBThread self, bool step_over, SBError error)
        Do an instruction level single step in the currently selected thread.
        """
        ...
    
    def StepOverUntil(self, frame: SBFrame, file_spec: SBFileSpec, line: int) -> SBError:
        r"""StepOverUntil(SBThread self, SBFrame frame, SBFileSpec file_spec, uint32_t line) -> SBError"""
        ...
    
    def StepUsingScriptedThreadPlan(self, *args) -> SBError:
        r"""
        StepUsingScriptedThreadPlan(SBThread self, char const * script_class_name) -> SBError
        StepUsingScriptedThreadPlan(SBThread self, char const * script_class_name, bool resume_immediately) -> SBError
        StepUsingScriptedThreadPlan(SBThread self, char const * script_class_name, SBStructuredData args_data, bool resume_immediately) -> SBError
        """
        ...
    
    def JumpToLine(self, file_spec: SBFileSpec, line: int) -> SBError:
        r"""JumpToLine(SBThread self, SBFileSpec file_spec, uint32_t line) -> SBError"""
        ...
    
    def RunToAddress(self, *args):
        r"""
        RunToAddress(SBThread self, lldb::addr_t addr)
        RunToAddress(SBThread self, lldb::addr_t addr, SBError error)
        """
        ...
    
    def ReturnFromFrame(self, frame, return_value):
        r"""

        Force a return from the frame passed in (and any frames younger than it)
        without executing any more code in those frames.  If return_value contains
        a valid SBValue, that will be set as the return value from frame.  Note, at
        present only scalar return values are supported.
        """
        ...
    
    def UnwindInnermostExpression(self):
        r"""

        Unwind the stack frames from the innermost expression evaluation.
        This API is equivalent to 'thread return -x'.
        """
        ...
    
    def Suspend(self, *args) -> bool:
        r"""
        Suspend(SBThread self) -> bool
        Suspend(SBThread self, SBError error) -> bool

            LLDB currently supports process centric debugging which means when any
            thread in a process stops, all other threads are stopped. The Suspend()
            call here tells our process to suspend a thread and not let it run when
            the other threads in a process are allowed to run. So when
            SBProcess::Continue() is called, any threads that aren't suspended will
            be allowed to run. If any of the SBThread functions for stepping are
            called (StepOver, StepInto, StepOut, StepInstruction, RunToAddres), the
            thread will now be allowed to run and these functions will simply return.

            Eventually we plan to add support for thread centric debugging where
            each thread is controlled individually and each thread would broadcast
            its state, but we haven't implemented this yet.

            Likewise the SBThread::Resume() call will again allow the thread to run
            when the process is continued.

            Suspend() and Resume() functions are not currently reference counted, if
            anyone has the need for them to be reference counted, please let us
            know.
        """
        ...
    
    def Resume(self, *args) -> bool:
        r"""
        Resume(SBThread self) -> bool
        Resume(SBThread self, SBError error) -> bool
        """
        ...
    
    def IsSuspended(self) -> bool:
        r"""IsSuspended(SBThread self) -> bool"""
        ...
    
    def IsStopped(self) -> bool:
        r"""IsStopped(SBThread self) -> bool"""
        ...
    
    def GetNumFrames(self) -> int:
        r"""GetNumFrames(SBThread self) -> uint32_t"""
        ...
    
    def GetFrameAtIndex(self, idx: int) -> SBFrame:
        r"""GetFrameAtIndex(SBThread self, uint32_t idx) -> SBFrame"""
        ...
    
    def GetSelectedFrame(self) -> SBFrame:
        r"""GetSelectedFrame(SBThread self) -> SBFrame"""
        ...
    
    def SetSelectedFrame(self, frame_idx: int) -> SBFrame:
        r"""SetSelectedFrame(SBThread self, uint32_t frame_idx) -> SBFrame"""
        ...
    
    @staticmethod
    def EventIsThreadEvent(event: SBEvent) -> bool:
        r"""EventIsThreadEvent(SBEvent event) -> bool"""
        ...
    
    @staticmethod
    def GetStackFrameFromEvent(event: SBEvent) -> SBFrame:
        r"""GetStackFrameFromEvent(SBEvent event) -> SBFrame"""
        ...
    
    @staticmethod
    def GetThreadFromEvent(event: SBEvent) -> SBThread:
        r"""GetThreadFromEvent(SBEvent event) -> SBThread"""
        ...
    
    def GetProcess(self) -> SBProcess:
        r"""GetProcess(SBThread self) -> SBProcess"""
        ...
    
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBThread self, SBThread rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBThread self, SBThread rhs) -> bool"""
        ...
    
    def GetDescription(self, *args) -> bool:
        r"""
        GetDescription(SBThread self, SBStream description) -> bool
        GetDescription(SBThread self, SBStream description, bool stop_format) -> bool

            Get the description strings for this thread that match what the
            lldb driver will present, using the thread-format (stop_format==false)
            or thread-stop-format (stop_format = true).
        """
        ...
    
    def GetStatus(self, status: SBStream) -> bool:
        r"""GetStatus(SBThread self, SBStream status) -> bool"""
        ...
    
    def GetExtendedBacktraceThread(self, type):
        r"""

        Given an argument of str to specify the type of thread-origin extended
        backtrace to retrieve, query whether the origin of this thread is
        available.  An SBThread is retured; SBThread.IsValid will return true
        if an extended backtrace was available.  The returned SBThread is not
        a part of the SBProcess' thread list and it cannot be manipulated like
        normal threads -- you cannot step or resume it, for instance -- it is
        intended to used primarily for generating a backtrace.  You may request
        the returned thread's own thread origin in turn.
        """
        ...
    
    def GetExtendedBacktraceOriginatingIndexID(self):
        r"""

        Takes no arguments, returns a uint32_t.
        If this SBThread is an ExtendedBacktrace thread, get the IndexID of the
        original thread that this ExtendedBacktrace thread represents, if
        available.  The thread that was running this backtrace in the past may
        not have been registered with lldb's thread index (if it was created,
        did its work, and was destroyed without lldb ever stopping execution).
        In that case, this ExtendedBacktrace thread's IndexID will be returned.
        """
        ...
    
    def GetCurrentException(self):
        r"""

        Returns an SBValue object represeting the current exception for the thread,
        if there is any. Currently, this works for Obj-C code and returns an SBValue
        representing the NSException object at the throw site or that's currently
        being processes.
        """
        ...
    
    def GetCurrentExceptionBacktrace(self):
        r"""

        Returns a historical (fake) SBThread representing the stack trace of an
        exception, if there is one for the thread. Currently, this works for Obj-C
        code, and can retrieve the throw-site backtrace of an NSException object
        even when the program is no longer at the throw site.
        """
        ...
    
    def SafeToCallFunctions(self):
        r"""

        Takes no arguments, returns a bool.
        lldb may be able to detect that function calls should not be executed
        on a given thread at a particular point in time.  It is recommended that
        this is checked before performing an inferior function call on a given
        thread.
        """
        ...
    
    def GetSiginfo(self):
        r"""

        Retruns a SBValue object representing the siginfo for the current signal.

        """
        ...
    
    def __repr__(self):
        r"""__repr__(SBThread self) -> std::string"""
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        '''Iterate over all frames in a lldb.SBThread object.'''
        ...
    
    def __len__(self):
        '''Return the number of frames in a lldb.SBThread object.'''
        ...
    
    class frames_access:
        '''A helper object that will lazily hand out frames for a thread when supplied an index.'''
        def __init__(self, sbthread) -> None:
            ...
        
        def __len__(self): # -> int:
            ...
        
        def __getitem__(self, key): # -> None:
            ...
        
    
    
    def get_frames_access_object(self): # -> frames_access:
        '''An accessor function that returns a frames_access() object which allows lazy frame access from a lldb.SBThread object.'''
        ...
    
    def get_thread_frames(self): # -> list[Any]:
        '''An accessor function that returns a list() that contains all frames in a lldb.SBThread object.'''
        ...
    
    id = ...
    idx = ...
    return_value: SBValue = ...
    process: SBProcess = ...
    num_frames = ...
    frames = ...
    frame: SBFrame = ...
    name: str = ...
    queue = ...
    queue_id = ...
    stop_reason = ...
    is_suspended: bool = ...
    is_stopped: bool = ...
    def __eq__(self, rhs) -> bool:
        ...
    
    def __ne__(self, rhs) -> bool:
        ...
    


class SBThreadCollection:
    r"""Represents a collection of SBThread objects."""
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBThreadCollection self) -> SBThreadCollection
        __init__(SBThreadCollection self, SBThreadCollection rhs) -> SBThreadCollection
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBThreadCollection self) -> bool"""
        ...
    
    def GetSize(self):
        r"""GetSize(SBThreadCollection self) -> size_t"""
        ...
    
    def GetThreadAtIndex(self, idx):
        r"""GetThreadAtIndex(SBThreadCollection self, size_t idx) -> SBThread"""
        ...
    


class SBThreadPlan:
    r"""
    Represents a plan for the execution control of a given thread.

    See also :py:class:`SBThread` and :py:class:`SBFrame`.
    """
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBThreadPlan self) -> SBThreadPlan
        __init__(SBThreadPlan self, SBThreadPlan threadPlan) -> SBThreadPlan
        __init__(SBThreadPlan self, SBThread thread, char const * class_name) -> SBThreadPlan
        __init__(SBThreadPlan self, SBThread thread, char const * class_name, SBStructuredData args_data) -> SBThreadPlan
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def Clear(self):
        r"""Clear(SBThreadPlan self)"""
        ...
    
    def GetStopReason(self):
        r"""GetStopReason(SBThreadPlan self) -> lldb::StopReason"""
        ...
    
    def GetStopReasonDataCount(self):
        r"""
        GetStopReasonDataCount(SBThreadPlan self) -> size_t

            Get the number of words associated with the stop reason.
            See also GetStopReasonDataAtIndex().
        """
        ...
    
    def GetStopReasonDataAtIndex(self, idx):
        r"""
        GetStopReasonDataAtIndex(SBThreadPlan self, uint32_t idx) -> uint64_t

            Get information associated with a stop reason.

            Breakpoint stop reasons will have data that consists of pairs of
            breakpoint IDs followed by the breakpoint location IDs (they always come
            in pairs).

            Stop Reason              Count Data Type
            ======================== ===== =========================================
            eStopReasonNone          0
            eStopReasonTrace         0
            eStopReasonBreakpoint    N     duple: {breakpoint id, location id}
            eStopReasonWatchpoint    1     watchpoint id
            eStopReasonSignal        1     unix signal number
            eStopReasonException     N     exception data
            eStopReasonExec          0
            eStopReasonFork          1     pid of the child process
            eStopReasonVFork         1     pid of the child process
            eStopReasonVForkDone     0
            eStopReasonPlanComplete  0
        """
        ...
    
    def GetThread(self):
        r"""GetThread(SBThreadPlan self) -> SBThread"""
        ...
    
    def GetDescription(self, description):
        r"""GetDescription(SBThreadPlan self, SBStream description) -> bool"""
        ...
    
    def SetPlanComplete(self, success):
        r"""SetPlanComplete(SBThreadPlan self, bool success)"""
        ...
    
    def IsPlanComplete(self):
        r"""IsPlanComplete(SBThreadPlan self) -> bool"""
        ...
    
    def IsPlanStale(self):
        r"""IsPlanStale(SBThreadPlan self) -> bool"""
        ...
    
    def IsValid(self, *args):
        r"""
        IsValid(SBThreadPlan self) -> bool
        IsValid(SBThreadPlan self) -> bool
        """
        ...
    
    def GetStopOthers(self):
        r"""
        GetStopOthers(SBThreadPlan self) -> bool
        Return whether this plan will ask to stop other threads when it runs.
        """
        ...
    
    def SetStopOthers(self, stop_others):
        r"""
        SetStopOthers(SBThreadPlan self, bool stop_others)
        Set whether this plan will ask to stop other threads when it runs.
        """
        ...
    
    def QueueThreadPlanForStepOverRange(self, *args):
        r"""
        QueueThreadPlanForStepOverRange(SBThreadPlan self, SBAddress start_address, lldb::addr_t range_size) -> SBThreadPlan
        QueueThreadPlanForStepOverRange(SBThreadPlan self, SBAddress start_address, lldb::addr_t range_size, SBError error) -> SBThreadPlan
        """
        ...
    
    def QueueThreadPlanForStepInRange(self, *args):
        r"""
        QueueThreadPlanForStepInRange(SBThreadPlan self, SBAddress start_address, lldb::addr_t range_size) -> SBThreadPlan
        QueueThreadPlanForStepInRange(SBThreadPlan self, SBAddress start_address, lldb::addr_t range_size, SBError error) -> SBThreadPlan
        """
        ...
    
    def QueueThreadPlanForStepOut(self, *args):
        r"""
        QueueThreadPlanForStepOut(SBThreadPlan self, uint32_t frame_idx_to_step_to, bool first_insn=False) -> SBThreadPlan
        QueueThreadPlanForStepOut(SBThreadPlan self, uint32_t frame_idx_to_step_to, bool first_insn, SBError error) -> SBThreadPlan
        """
        ...
    
    def QueueThreadPlanForRunToAddress(self, *args):
        r"""
        QueueThreadPlanForRunToAddress(SBThreadPlan self, SBAddress address) -> SBThreadPlan
        QueueThreadPlanForRunToAddress(SBThreadPlan self, SBAddress address, SBError error) -> SBThreadPlan
        """
        ...
    
    def QueueThreadPlanForStepScripted(self, *args):
        r"""
        QueueThreadPlanForStepScripted(SBThreadPlan self, char const * script_class_name) -> SBThreadPlan
        QueueThreadPlanForStepScripted(SBThreadPlan self, char const * script_class_name, SBError error) -> SBThreadPlan
        QueueThreadPlanForStepScripted(SBThreadPlan self, char const * script_class_name, SBStructuredData args_data, SBError error) -> SBThreadPlan
        """
        ...
    


class SBTrace:
    r"""Represents a processor trace."""
    thisown = ...
    __repr__ = ...
    def __init__(self) -> None:
        r"""__init__(SBTrace self) -> SBTrace"""
        ...
    
    @staticmethod
    def LoadTraceFromFile(error, debugger, trace_description_file):
        r"""LoadTraceFromFile(SBError error, SBDebugger debugger, SBFileSpec trace_description_file) -> SBTrace"""
        ...
    
    def CreateNewCursor(self, error, thread):
        r"""CreateNewCursor(SBTrace self, SBError error, SBThread thread) -> SBTraceCursor"""
        ...
    
    def SaveToDisk(self, error, bundle_dir, compact=...):
        r"""SaveToDisk(SBTrace self, SBError error, SBFileSpec bundle_dir, bool compact=False) -> SBFileSpec"""
        ...
    
    def GetStartConfigurationHelp(self):
        r"""GetStartConfigurationHelp(SBTrace self) -> char const *"""
        ...
    
    def Start(self, *args):
        r"""
        Start(SBTrace self, SBStructuredData configuration) -> SBError
        Start(SBTrace self, SBThread thread, SBStructuredData configuration) -> SBError
        """
        ...
    
    def Stop(self, *args):
        r"""
        Stop(SBTrace self) -> SBError
        Stop(SBTrace self, SBThread thread) -> SBError
        """
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBTrace self) -> bool"""
        ...
    
    __swig_destroy__ = ...


class SBTraceCursor:
    r"""Represents a trace cursor."""
    thisown = ...
    __repr__ = ...
    def __init__(self) -> None:
        r"""__init__(SBTraceCursor self) -> SBTraceCursor"""
        ...
    
    def SetForwards(self, forwards):
        r"""SetForwards(SBTraceCursor self, bool forwards)"""
        ...
    
    def IsForwards(self):
        r"""IsForwards(SBTraceCursor self) -> bool"""
        ...
    
    def Next(self):
        r"""Next(SBTraceCursor self)"""
        ...
    
    def HasValue(self):
        r"""HasValue(SBTraceCursor self) -> bool"""
        ...
    
    def GoToId(self, id):
        r"""GoToId(SBTraceCursor self, lldb::user_id_t id) -> bool"""
        ...
    
    def HasId(self, id):
        r"""HasId(SBTraceCursor self, lldb::user_id_t id) -> bool"""
        ...
    
    def GetId(self):
        r"""GetId(SBTraceCursor self) -> lldb::user_id_t"""
        ...
    
    def Seek(self, offset, origin):
        r"""Seek(SBTraceCursor self, int64_t offset, lldb::TraceCursorSeekType origin) -> bool"""
        ...
    
    def GetItemKind(self):
        r"""GetItemKind(SBTraceCursor self) -> lldb::TraceItemKind"""
        ...
    
    def IsError(self):
        r"""IsError(SBTraceCursor self) -> bool"""
        ...
    
    def GetError(self):
        r"""GetError(SBTraceCursor self) -> char const *"""
        ...
    
    def IsEvent(self):
        r"""IsEvent(SBTraceCursor self) -> bool"""
        ...
    
    def GetEventType(self):
        r"""GetEventType(SBTraceCursor self) -> lldb::TraceEvent"""
        ...
    
    def GetEventTypeAsString(self):
        r"""GetEventTypeAsString(SBTraceCursor self) -> char const *"""
        ...
    
    def IsInstruction(self):
        r"""IsInstruction(SBTraceCursor self) -> bool"""
        ...
    
    def GetLoadAddress(self):
        r"""GetLoadAddress(SBTraceCursor self) -> lldb::addr_t"""
        ...
    
    def GetCPU(self):
        r"""GetCPU(SBTraceCursor self) -> lldb::cpu_id_t"""
        ...
    
    def IsValid(self):
        r"""IsValid(SBTraceCursor self) -> bool"""
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    __swig_destroy__ = ...


class SBTypeMember:
    r"""Represents a member of a type."""
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBTypeMember self) -> SBTypeMember
        __init__(SBTypeMember self, SBTypeMember rhs) -> SBTypeMember
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBTypeMember self) -> bool"""
        ...
    
    def GetName(self):
        r"""GetName(SBTypeMember self) -> char const *"""
        ...
    
    def GetType(self):
        r"""GetType(SBTypeMember self) -> SBType"""
        ...
    
    def GetOffsetInBytes(self):
        r"""GetOffsetInBytes(SBTypeMember self) -> uint64_t"""
        ...
    
    def GetOffsetInBits(self):
        r"""GetOffsetInBits(SBTypeMember self) -> uint64_t"""
        ...
    
    def IsBitfield(self):
        r"""IsBitfield(SBTypeMember self) -> bool"""
        ...
    
    def GetBitfieldSizeInBits(self):
        r"""GetBitfieldSizeInBits(SBTypeMember self) -> uint32_t"""
        ...
    
    def GetDescription(self, description, description_level):
        r"""GetDescription(SBTypeMember self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBTypeMember self) -> std::string"""
        ...
    
    name = ...
    type = ...
    byte_offset = ...
    bit_offset = ...
    is_bitfield = ...
    bitfield_bit_size = ...


class SBTypeMemberFunction:
    r"""Represents a member function of a type."""
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBTypeMemberFunction self) -> SBTypeMemberFunction
        __init__(SBTypeMemberFunction self, SBTypeMemberFunction rhs) -> SBTypeMemberFunction
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBTypeMemberFunction self) -> bool"""
        ...
    
    def GetName(self):
        r"""GetName(SBTypeMemberFunction self) -> char const *"""
        ...
    
    def GetDemangledName(self):
        r"""GetDemangledName(SBTypeMemberFunction self) -> char const *"""
        ...
    
    def GetMangledName(self):
        r"""GetMangledName(SBTypeMemberFunction self) -> char const *"""
        ...
    
    def GetType(self):
        r"""GetType(SBTypeMemberFunction self) -> SBType"""
        ...
    
    def GetReturnType(self):
        r"""GetReturnType(SBTypeMemberFunction self) -> SBType"""
        ...
    
    def GetNumberOfArguments(self):
        r"""GetNumberOfArguments(SBTypeMemberFunction self) -> uint32_t"""
        ...
    
    def GetArgumentTypeAtIndex(self, arg2):
        r"""GetArgumentTypeAtIndex(SBTypeMemberFunction self, uint32_t arg2) -> SBType"""
        ...
    
    def GetKind(self):
        r"""GetKind(SBTypeMemberFunction self) -> lldb::MemberFunctionKind"""
        ...
    
    def GetDescription(self, description, description_level):
        r"""GetDescription(SBTypeMemberFunction self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBTypeMemberFunction self) -> std::string"""
        ...
    


class SBType:
    r"""
    Represents a data type in lldb.

    The actual characteristics of each type are defined by the semantics of the
    programming language and the specific language implementation that was used
    to compile the target program. See the language-specific notes in the
    documentation of each method.

    SBType instances can be obtained by a variety of methods.
    `SBTarget.FindFirstType` and `SBModule.FindFirstType` can be used to create
    `SBType` representations of types in executables/libraries with debug
    information. For some languages such as C, C++ and Objective-C it is possible
    to create new types by evaluating expressions that define a new type.

    Note that most `SBType` properties are computed independently of any runtime
    information so for dynamic languages the functionality can be very limited.
    `SBValue` can be used to represent runtime values which then can be more
    accurately queried for certain information such as byte size.


    SBType supports the eq/ne operator. For example,::

        //main.cpp:

        class Task {
        public:
            int id;
            Task *next;
            Task(int i, Task *n):
                id(i),
                next(n)
            {}
        };

        int main (int argc, char const *argv[])
        {
            Task *task_head = new Task(-1, NULL);
            Task *task1 = new Task(1, NULL);
            Task *task2 = new Task(2, NULL);
            Task *task3 = new Task(3, NULL); // Orphaned.
            Task *task4 = new Task(4, NULL);
            Task *task5 = new Task(5, NULL);

            task_head->next = task1;
            task1->next = task2;
            task2->next = task4;
            task4->next = task5;

            int total = 0;
            Task *t = task_head;
            while (t != NULL) {
                if (t->id >= 0)
                    ++total;
                t = t->next;
            }
            printf('We have a total number of %d tasks\n', total);

            // This corresponds to an empty task list.
            Task *empty_task_head = new Task(-1, NULL);

            return 0; // Break at this line
        }

        # find_type.py:

                # Get the type 'Task'.
                task_type = target.FindFirstType('Task')
                self.assertTrue(task_type)

                # Get the variable 'task_head'.
                frame0.FindVariable('task_head')
                task_head_type = task_head.GetType()
                self.assertTrue(task_head_type.IsPointerType())

                # task_head_type is 'Task *'.
                task_pointer_type = task_type.GetPointerType()
                self.assertTrue(task_head_type == task_pointer_type)

                # Get the child mmember 'id' from 'task_head'.
                id = task_head.GetChildMemberWithName('id')
                id_type = id.GetType()

                # SBType.GetBasicType() takes an enum 'BasicType' (lldb-enumerations.h).
                int_type = id_type.GetBasicType(lldb.eBasicTypeInt)
                # id_type and int_type should be the same type!
                self.assertTrue(id_type == int_type)


    """
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBType self) -> SBType
        __init__(SBType self, SBType rhs) -> SBType
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self) -> bool:
        r"""IsValid(SBType self) -> bool"""
        ...
    
    def GetByteSize(self) -> int:
        r"""
        GetByteSize(SBType self) -> uint64_t
        Returns the number of bytes a variable with the given types occupies in memory.

            Returns ``0`` if the size can't be determined.

            If a type occupies ``N`` bytes + ``M`` bits in memory, this function returns
            the rounded up amount of bytes (i.e., if ``M`` is ``0``,
            this function returns ``N`` and otherwise ``N + 1``).

            Language-specific behaviour:

            * C: The output is expected to match the value of ``sizeof(Type)``. If
              ``sizeof(Type)`` is not a valid expression for the given type, the
              function returns ``0``.
            * C++: Same as in C.
            * Objective-C: Same as in C. For Objective-C classes this always returns
              ``0`` as the actual size depends on runtime information.

        """
        ...
    
    def IsPointerType(self) -> bool:
        r"""
        IsPointerType(SBType self) -> bool
        Returns true if this type is a pointer type.

            Language-specific behaviour:

            * C: Returns true for C pointer types (or typedefs of these types).
            * C++: Pointer types include the C pointer types as well as pointers to data
              mebers or member functions.
            * Objective-C: Pointer types include the C pointer types. ``id``, ``Class``
              and pointers to blocks are also considered pointer types.

        """
        ...
    
    def IsReferenceType(self) -> bool:
        r"""
        IsReferenceType(SBType self) -> bool
        Returns true if this type is a reference type.

            Language-specific behaviour:

            * C: Returns false for all types.
            * C++: Both l-value and r-value references are considered reference types.
            * Objective-C: Returns false for all types.

        """
        ...
    
    def IsFunctionType(self) -> bool:
        r"""IsFunctionType(SBType self) -> bool"""
        ...
    
    def IsPolymorphicClass(self) -> bool:
        r"""
        IsPolymorphicClass(SBType self) -> bool
        Returns true if this type is a polymorphic type.

            Language-specific behaviour:

            * C: Returns false for all types.
            * C++: Returns true if the type is a class type that contains at least one
              virtual member function or if at least one of its base classes is
              considered a polymorphic type.
            * Objective-C: Returns false for all types.

        """
        ...
    
    def IsArrayType(self) -> bool:
        r"""
        IsArrayType(SBType self) -> bool
        Returns true if this type is an array type.

            Language-specific behaviour:

            * C: Returns true if the types is an array type. This includes incomplete
              array types ``T[]`` and array types with integer (``T[1]``) or variable
              length (``T[some_variable]``). Pointer types are not considered arrays.
            * C++: Includes C's array types and dependent array types (i.e., array types
              in templates which size depends on template arguments).
            * Objective-C: Same as in C.

        """
        ...
    
    def IsVectorType(self) -> bool:
        r"""
        IsVectorType(SBType self) -> bool
        Returns true if this type is a vector type.

            Language-specific behaviour:

            * C: Returns true if the types is a vector type created with
              GCC's ``vector_size`` or Clang's ``ext_vector_type`` feature.
            * C++: Same as in C.
            * Objective-C: Same as in C.

        """
        ...
    
    def IsTypedefType(self) -> bool:
        r"""
        IsTypedefType(SBType self) -> bool
        Returns true if this type is a typedef.

            Language-specific behaviour:

            * C: Returns true if the type is a C typedef.
            * C++: Same as in C. Also treats type aliases as typedefs.
            * Objective-C: Same as in C.

        """
        ...
    
    def IsAnonymousType(self) -> bool:
        r"""
        IsAnonymousType(SBType self) -> bool
        Returns true if this type is an anonymous type.

            Language-specific behaviour:

            * C: Returns true for anonymous unions. Also returns true for
              anonymous structs (which are a GNU language extension).
            * C++: Same as in C.
            * Objective-C: Same as in C.

        """
        ...
    
    def IsScopedEnumerationType(self) -> bool:
        r"""
        IsScopedEnumerationType(SBType self) -> bool
        Returns true if this type is a scoped enum.

            Language-specific behaviour:

            * C: Returns false for all types.
            * C++: Return true only for C++11 scoped enums.
            * Objective-C: Returns false for all types.

        """
        ...
    
    def IsAggregateType(self) -> bool:
        r"""
        IsAggregateType(SBType self) -> bool
        Returns true if this type is an aggregate type.

            Language-specific behaviour:

            * C: Returns true for struct values, arrays, and vectors.
            * C++: Same a C. Also includes class instances.
            * Objective-C: Same as C. Also includes class instances.

        """
        ...
    
    def GetPointerType(self) -> SBType:
        r"""
        GetPointerType(SBType self) -> SBType
        Returns a type that represents a pointer to this type.

            If the type system of the current language can't represent a pointer to this
            type or this type is invalid, an invalid `SBType` is returned.

            Language-specific behaviour:

            * C: Returns the pointer type of this type.
            * C++: Same as in C.
            * Objective-C: Same as in C.

        """
        ...
    
    def GetPointeeType(self) -> SBType:
        r"""
        GetPointeeType(SBType self) -> SBType
        Returns the underlying pointee type.

            If this type is a pointer type as specified by `IsPointerType` then this
            returns the underlying type. If this is not a pointer type or an invalid
            `SBType` then this returns an invalid `SBType`.

            Language-specific behaviour:

            * C: Returns the underlying type for for C pointer types or typedefs of
              these types). For example, ``int *`` will return ``int``.
            * C++: Same as in C. Returns an `SBType` representation for data members/
              member functions in case the `SBType` is a pointer to data member or
              pointer to member function.
            * Objective-C: Same as in C. The pointee type of ``id`` and ``Class`` is
              an invalid `SBType`. The pointee type of pointers Objective-C types is an
              `SBType` for the non-pointer type of the respective type. For example,
              ``NSString *`` will return ``NSString`` as a pointee type.

        """
        ...
    
    def GetReferenceType(self) -> SBType:
        r"""
        GetReferenceType(SBType self) -> SBType
        Returns a type that represents a reference to this type.

            If the type system of the current language can't represent a reference to
            this type, an invalid `SBType` is returned.

            Language-specific behaviour:

            * C: Currently assumes the type system is C++ and returns an l-value
              reference type. For example, ``int`` will return ``int&``. This behavior
              is likely to change in the future and shouldn't be relied on.
            * C++: Same as in C.
            * Objective-C: Same as in C.

        """
        ...
    
    def GetTypedefedType(self) -> SBType:
        r"""
        GetTypedefedType(SBType self) -> SBType
        Returns the underlying type of a typedef.

            If this type is a typedef as designated by `IsTypedefType`, then the
            underlying type is being returned. Otherwise an invalid `SBType` is
            returned.

            Language-specific behaviour:

            * C: Returns the underlying type of a typedef type.
            * C++: Same as in C. For type aliases, the underlying type is returned.
            * Objective-C: Same as in C.

        """
        ...
    
    def GetDereferencedType(self) -> SBType:
        r"""
        GetDereferencedType(SBType self) -> SBType
        Returns the underlying type of a reference type.

            If this type is a reference as designated by `IsReferenceType`, then the
            underlying type is being returned. Otherwise an invalid `SBType` is
            returned.

            Language-specific behaviour:

            * C: Always returns an invalid type.
            * C++: For l-value and r-value references the underlying type is returned.
              For example, ``int &`` will return ``int``.
            * Objective-C: Same as in C.

        """
        ...
    
    def GetUnqualifiedType(self) -> SBType:
        r"""
        GetUnqualifiedType(SBType self) -> SBType
        Returns the unqualified version of this type.

            Language-specific behaviour:

            * C: If this type with any const or volatile specifier removed.
            * C++: Same as in C.
            * Objective-C: Same as in C.

        """
        ...
    
    def GetArrayElementType(self) -> SBType:
        r"""
        GetArrayElementType(SBType self) -> SBType
        Returns the array element type if this type is an array type.

            Otherwise returns an invalid `SBType` if this type is invalid or not an
            array type.

            Language-specific behaviour:

            * C: If this is an array type (see `IsArrayType`) such as ``T[]``, returns
              the element type.
            * C++: Same as in C.
            * Objective-C: Same as in C.

            See also `IsArrayType`.

        """
        ...
    
    def GetArrayType(self, size) -> SBType:
        r"""
        GetArrayType(SBType self, uint64_t size) -> SBType
        Returns the array type with the given constant size.

            Language-specific behaviour:

            * C: Returns a constant-size array `T[size]` for any non-void type.
            * C++: Same as in C.
            * Objective-C: Same as in C.

            See also `IsArrayType` and `GetArrayElementType`.

        """
        ...
    
    def GetVectorElementType(self) -> SBType:
        r"""
        GetVectorElementType(SBType self) -> SBType
        Returns the vector element type if this type is a vector type.

            Otherwise returns an invalid `SBType` if this type is invalid or not a
            vector type.

            Language-specific behaviour:

            * C: If this is a vector type (see `IsVectorType`), returns the element
              type.
            * C++: Same as in C.
            * Objective-C: Same as in C.

            See also `IsVectorType`.

        """
        ...
    
    def GetCanonicalType(self) -> SBType:
        r"""GetCanonicalType(SBType self) -> SBType"""
        ...
    
    def GetEnumerationIntegerType(self) -> SBType:
        r"""
        GetEnumerationIntegerType(SBType self) -> SBType
        Returns the underlying integer type if this is an enumeration type.

            If this type is an invalid `SBType` or not an enumeration type an invalid
            `SBType` is returned.

            Language-specific behaviour:

            * C: Returns the underlying type for enums.
            * C++: Same as in C but also returns the underlying type for scoped enums.
            * Objective-C: Same as in C.

        """
        ...
    
    def GetBasicType(self, *args):
        r"""
        GetBasicType(SBType self) -> lldb::BasicType
        GetBasicType(SBType self, lldb::BasicType type) -> SBType
        Returns the `BasicType` value that is most appropriate to this type.

            Returns `eBasicTypeInvalid` if no appropriate `BasicType` was found or this
            type is invalid. See the `BasicType` documentation for the language-specific
            meaning of each `BasicType` value.

            **Overload behaviour:** When called with a `BasicType` parameter, the
            following behaviour applies:

            Returns the `SBType` that represents the passed `BasicType` value. Returns
            an invalid `SBType` if no fitting `SBType` could be created.

            Language-specific behaviour:

            * C: Returns the respective builtin type. Note that some types
              (e.g. ``__uint128_t``) might even be successfully created even if they are
              not available on the target platform. C++ and Objective-C specific types
              might also be created even if the target program is not written in C++ or
              Objective-C.
            * C++: Same as in C.
            * Objective-C: Same as in C.

        """
        ...
    
    def GetNumberOfFields(self) -> int:
        r"""
        GetNumberOfFields(SBType self) -> uint32_t
        Returns the number of fields of this type.

            Returns ``0`` if this type does not have fields.

            Language-specific behaviour:

            * C: Returns the number of fields if the type is a struct. If the type
              contains an anonymous struct/union it only counts as a single field (even
              if the struct/union contains several fields).
            * C++: Returns the number of non-static fields if the type is a
              struct/class. If the type contains an anonymous struct/union it only
              counts as a single field (even if the struct/union contains several
              fields). The fields of any base classes are not included in the count.
            * Objective-C: Same as in C for structs. For Objective-C classes the number
              of ivars is returned.

            See also `GetFieldAtIndex`.

        """
        ...
    
    def GetNumberOfDirectBaseClasses(self) -> int:
        r"""
        GetNumberOfDirectBaseClasses(SBType self) -> uint32_t
        Returns the number of base/parent classes of this type.

            Returns ``0`` if this type doesn't have any base classes.

            Language-specific behaviour:

            * C: Returns always ``0``.
            * C++: The number of direct non-virtual base classes if this type is
              a class.
            * Objective-C: The number of super classes for Objective-C classes.
              As Objective-C doesn't have multiple inheritance this is usually returns 1
              except for NSObject.

        """
        ...
    
    def GetNumberOfVirtualBaseClasses(self) -> int:
        r"""
        GetNumberOfVirtualBaseClasses(SBType self) -> uint32_t
        Returns the number of virtual base/parent classes of this type

            Returns ``0`` if this type doesn't have any base classes.

            Language-specific behaviour:

            * C: Returns always ``0``.
            * C++: The number of direct virtual base classes if this type is a
              class.
            * Objective-C: Returns always ``0``.

        """
        ...
    
    def GetFieldAtIndex(self, idx: int) -> SBTypeMember:
        r"""
        GetFieldAtIndex(SBType self, uint32_t idx) -> SBTypeMember
        Returns the field at the given index.

            Returns an invalid `SBType` if the index is out of range or the current
            type doesn't have any fields.

            Language-specific behaviour:

            * C: Returns the field with the given index for struct types. Fields are
              ordered/indexed starting from ``0`` for the first field in a struct (as
              declared in the definition).
            * C++: Returns the non-static field with the given index for struct types.
              Fields are ordered/indexed starting from ``0`` for the first field in a
              struct (as declared in the definition).
            * Objective-C: Same as in C for structs. For Objective-C classes the ivar
              with the given index is returned. ivars are indexed starting from ``0``.

        """
        ...
    
    def GetDirectBaseClassAtIndex(self, idx: int) -> SBTypeMember:
        r"""
        GetDirectBaseClassAtIndex(SBType self, uint32_t idx) -> SBTypeMember
        Returns the direct base class as indexed by `GetNumberOfDirectBaseClasses`.

            Returns an invalid SBTypeMember if the index is invalid or this SBType is
            invalid.

        """
        ...
    
    def GetVirtualBaseClassAtIndex(self, idx: int) -> SBTypeMember:
        r"""
        GetVirtualBaseClassAtIndex(SBType self, uint32_t idx) -> SBTypeMember
        Returns the virtual base class as indexed by
            `GetNumberOfVirtualBaseClasses`.

            Returns an invalid SBTypeMember if the index is invalid or this SBType is
            invalid.

        """
        ...
    
    def GetEnumMembers(self) -> SBTypeEnumMemberList:
        r"""GetEnumMembers(SBType self) -> SBTypeEnumMemberList"""
        ...
    
    def GetNumberOfTemplateArguments(self) -> int:
        r"""
        GetNumberOfTemplateArguments(SBType self) -> uint32_t
        Returns the number of template arguments of this type.

            Returns ``0`` if this type is not a template.

            Language-specific behaviour:

            * C: Always returns ``0``.
            * C++: If this type is a class template instantiation then this returns the
              number of template parameters that were used in this instantiation. This
              includes both explicit and implicit template parameters.
            * Objective-C: Always returns ``0``.

        """
        ...
    
    def GetTemplateArgumentType(self, idx: int) -> SBType:
        r"""
        GetTemplateArgumentType(SBType self, uint32_t idx) -> SBType
        Returns the type of the template argument with the given index.

            Returns an invalid `SBType` if there is no template argument with the given
            index or this type is not a template. The first template  argument has the
            index ``0``.

            Language-specific behaviour:

            * C: Always returns an invalid SBType.
            * C++: If this type is a class template instantiation and the template
              parameter with the given index is a type template parameter, then this
              returns the type of that parameter. Otherwise returns an invalid `SBType`.
            * Objective-C: Always returns an invalid SBType.

        """
        ...
    
    def GetTemplateArgumentKind(self, idx: int):
        r"""
        GetTemplateArgumentKind(SBType self, uint32_t idx) -> lldb::TemplateArgumentKind
        Returns the kind of the template argument with the given index.

            Returns `eTemplateArgumentKindNull` if there is no template argument
            with the given index or this type is not a template. The first template
            argument has the index ``0``.

            Language-specific behaviour:

            * C: Always returns `eTemplateArgumentKindNull`.
            * C++: If this type is a class template instantiation then this returns
              the appropriate `TemplateArgument` value for the parameter with the given
              index. See the documentation of `TemplateArgument` for how certain C++
              template parameter kinds are mapped to `TemplateArgument` values.
            * Objective-C: Always returns `eTemplateArgumentKindNull`.

        """
        ...
    
    def GetFunctionReturnType(self) -> SBType:
        r"""
        GetFunctionReturnType(SBType self) -> SBType
        Returns the return type if this type represents a function.

            Returns an invalid `SBType` if this type is not a function type or invalid.

            Language-specific behaviour:

            * C: For functions return the return type. Returns an invalid `SBType` if
              this type is a function pointer type.
            * C++: Same as in C for functions and instantiated template functions.
              Member functions are also considered functions. For functions that have
              their return type specified by a placeholder type specifier (``auto``)
              this returns the deduced return type.
            * Objective-C: Same as in C for functions. For Objective-C methods this
              returns the return type of the method.

        """
        ...
    
    def GetFunctionArgumentTypes(self) -> SBTypeList:
        r"""
        GetFunctionArgumentTypes(SBType self) -> SBTypeList
        Returns the list of argument types if this type represents a function.

            Returns an invalid `SBType` if this type is not a function type or invalid.

            Language-specific behaviour:

            * C: For functions return the types of each parameter. Returns an invalid
              `SBType` if this type is a function pointer. For variadic functions this
              just returns the list of parameters before the variadic arguments.
            * C++: Same as in C for functions and instantiated template functions.
              Member functions are also considered functions.
            * Objective-C: Always returns an invalid SBType for Objective-C methods.

        """
        ...
    
    def GetNumberOfMemberFunctions(self) -> int:
        r"""
        GetNumberOfMemberFunctions(SBType self) -> uint32_t
        Returns the number of member functions of this type.

            Returns ``0`` if an error occurred or this type is invalid.

            Language-specific behaviour:

            * C: Always returns ``0``.
            * C++: If this type represents a struct/class, then the number of
              member functions (static and non-static) is returned. The count includes
              constructors and destructors (both explicit and implicit). Member
              functions of base classes are not included in the count.
            * Objective-C: If this type represents a struct/class, then the
              number of methods is returned. Methods in categories or super classes
              are not counted.

        """
        ...
    
    def GetMemberFunctionAtIndex(self, idx: int) -> SBTypeMemberFunction:
        r"""
        GetMemberFunctionAtIndex(SBType self, uint32_t idx) -> SBTypeMemberFunction
        Returns the member function of this type with the given index.

            Returns an invalid `SBTypeMemberFunction` if the index is invalid or this
            type is invalid.

            Language-specific behaviour:

            * C: Always returns an invalid `SBTypeMemberFunction`.
            * C++: Returns the member function or constructor/destructor with the given
              index.
            * Objective-C: Returns the method with the given index.

            See `GetNumberOfMemberFunctions` for what functions can be queried by this
            function.

        """
        ...
    
    def GetModule(self) -> SBModule:
        r"""
        GetModule(SBType self) -> SBModule
        Returns the `SBModule` this `SBType` belongs to.

            Returns no `SBModule` if this type does not belong to any specific
            `SBModule` or this `SBType` is invalid. An invalid `SBModule` might also
            indicate that once came from an `SBModule` but LLDB could no longer
            determine the original module.

        """
        ...
    
    def GetName(self) -> str:
        r"""
        GetName() -> string
        Returns the name of this type.

            Returns an empty string if an error occurred or this type is invalid.

            Use this function when trying to match a specific type by name in a script.
            The names returned by this function try to uniquely identify a name but
            conflicts can occur (for example, if a C++ program contains two different
            classes with the same name in different translation units. `GetName` can
            return the same name for both class types.)


            Language-specific behaviour:

            * C: The name of the type. For structs the ``struct`` prefix is omitted.
            * C++: Returns the qualified name of the type (including anonymous/inline
              namespaces and all template arguments).
            * Objective-C: Same as in C.

        """
        ...
    
    def GetDisplayTypeName(self) -> str:
        r"""
        GetDisplayTypeName() -> string
        Returns the name of this type in a user-friendly format.

            Returns an empty string if an error occurred or this type is invalid.

            Use this function when displaying a type name to the user.

            Language-specific behaviour:

            * C: Returns the type name. For structs the ``struct`` prefix is omitted.
            * C++: Returns the qualified name. Anonymous/inline namespaces are omitted.
              Template arguments that match their default value might also be hidden
              (this functionality depends on whether LLDB can determine the template's
              default arguments).
            * Objective-C: Same as in C.

        """
        ...
    
    def GetTypeClass(self):
        r"""
        GetTypeClass() -> TypeClass
        Returns the `TypeClass` for this type.

            Returns an `eTypeClassInvalid` if this `SBType` is invalid.

            See `TypeClass` for the language-specific meaning of each `TypeClass` value.

        """
        ...
    
    def IsTypeComplete(self) -> bool:
        r"""
        IsTypeComplete(SBType self) -> bool
        Returns true if the type is completely defined.

            Language-specific behaviour:

            * C: Returns false for struct types that were only forward declared in the
              type's `SBTarget`/`SBModule`. Otherwise returns true.
            * C++: Returns false for template/non-template struct/class types and
              scoped enums that were only forward declared inside the type's
              `SBTarget`/`SBModule`. Otherwise returns true.
            * Objective-C: Follows the same behavior as C for struct types. Objective-C
              classes are considered complete unless they were only forward declared via
              ``@class ClassName`` in the type's `SBTarget`/`SBModule`. Otherwise
              returns true.

        """
        ...
    
    def GetTypeFlags(self) -> int:
        r"""
        GetTypeFlags(SBType self) -> uint32_t
        Returns the `TypeFlags` values for this type.

            See the respective `TypeFlags` values for what values can be set. Returns an
            integer in which each `TypeFlags` value is represented by a bit. Specific
            flags can be checked via Python's bitwise operators. For example, the
            `eTypeIsInteger` flag can be checked like this:

            ``(an_sb_type.GetTypeFlags() & lldb.eTypeIsInteger) != 0``

            If this type is invalid this returns ``0``.

            See the different values for `TypeFlags` for the language-specific meanings
            of each `TypeFlags` value.

        """
        ...
    
    def GetDescription(self, description: SBStream, description_level) -> bool:
        r"""GetDescription(SBType self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        ...
    
    def __eq__(self, rhs: SBType) -> bool:
        r"""__eq__(SBType self, SBType rhs) -> bool"""
        ...
    
    def __ne__(self, rhs: SBType) -> bool:
        r"""__ne__(SBType self, SBType rhs) -> bool"""
        ...
    
    def __repr__(self) -> str:
        r"""__repr__(SBType self) -> std::string"""
        ...
    
    def template_arg_array(self): # -> list[Any] | None:
        ...
    
    module: SBModule = ...
    name: str = ...
    size: int = ...
    is_pointer: bool = ...
    is_reference: bool = ...
    is_reference: bool = ...
    num_fields: int = ...
    num_bases: int = ...
    num_vbases: int = ...
    num_template_args: int = ...
    template_args = ...
    type = ...
    is_complete: bool = ...
    def get_bases_array(self): # -> list[Any]:
        '''An accessor function that returns a list() that contains all direct base classes in a lldb.SBType object.'''
        ...
    
    def get_vbases_array(self): # -> list[Any]:
        '''An accessor function that returns a list() that contains all fields in a lldb.SBType object.'''
        ...
    
    def get_fields_array(self): # -> list[Any]:
        '''An accessor function that returns a list() that contains all fields in a lldb.SBType object.'''
        ...
    
    def get_members_array(self): # -> list[Any]:
        '''An accessor function that returns a list() that contains all members (base classes and fields) in a lldb.SBType object in ascending bit offset order.'''
        ...
    
    def get_enum_members_array(self): # -> list[Any]:
        '''An accessor function that returns a list() that contains all enum members in an lldb.SBType object.'''
        ...
    
    bases = ...
    vbases = ...
    fields = ...
    members = ...
    enum_members = ...


class SBTypeList:
    r"""
    Represents a list of :py:class:`SBType` s.

    The FindTypes() method of :py:class:`SBTarget`/:py:class:`SBModule` returns a SBTypeList.

    SBTypeList supports :py:class:`SBType` iteration. For example,

    .. code-block:: cpp

        // main.cpp:

        class Task {
        public:
            int id;
            Task *next;
            Task(int i, Task *n):
                id(i),
                next(n)
            {}
        };

    .. code-block:: python

        # find_type.py:

        # Get the type 'Task'.
        type_list = target.FindTypes('Task')
        self.assertTrue(len(type_list) == 1)
        # To illustrate the SBType iteration.
        for type in type_list:
            # do something with type


    """
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBTypeList self) -> SBTypeList
        __init__(SBTypeList self, SBTypeList rhs) -> SBTypeList
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self) -> bool:
        r"""IsValid(SBTypeList self) -> bool"""
        ...
    
    def Append(self, type: SBType):
        r"""Append(SBTypeList self, SBType type)"""
        ...
    
    def GetTypeAtIndex(self, index) -> SBType:
        r"""GetTypeAtIndex(SBTypeList self, uint32_t index) -> SBType"""
        ...
    
    def GetSize(self) -> int:
        r"""GetSize(SBTypeList self) -> uint32_t"""
        ...
    
    def __iter__(self) -> Iterator[SBType]:
        '''Iterate over all types in a lldb.SBTypeList object.'''
        ...
    
    def __len__(self) -> int:
        '''Return the number of types in a lldb.SBTypeList object.'''
        ...
    


class SBTypeCategory:
    r"""Represents a category that can contain formatters for types."""
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBTypeCategory self) -> SBTypeCategory
        __init__(SBTypeCategory self, SBTypeCategory rhs) -> SBTypeCategory
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self) -> bool:
        r"""IsValid(SBTypeCategory self) -> bool"""
        ...
    
    def GetEnabled(self) -> bool:
        r"""GetEnabled(SBTypeCategory self) -> bool"""
        ...
    
    def SetEnabled(self, arg2: bool):
        r"""SetEnabled(SBTypeCategory self, bool arg2)"""
        ...
    
    def GetName(self) -> str:
        r"""GetName(SBTypeCategory self) -> char const *"""
        ...
    
    def GetLanguageAtIndex(self, idx: int):
        r"""GetLanguageAtIndex(SBTypeCategory self, uint32_t idx) -> lldb::LanguageType"""
        ...
    
    def GetNumLanguages(self) -> int:
        r"""GetNumLanguages(SBTypeCategory self) -> uint32_t"""
        ...
    
    def AddLanguage(self, language):
        r"""AddLanguage(SBTypeCategory self, lldb::LanguageType language)"""
        ...
    
    def GetDescription(self, description: SBStream, description_level) -> bool:
        r"""GetDescription(SBTypeCategory self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        ...
    
    def GetNumFormats(self) -> int:
        r"""GetNumFormats(SBTypeCategory self) -> uint32_t"""
        ...
    
    def GetNumSummaries(self) -> int:
        r"""GetNumSummaries(SBTypeCategory self) -> uint32_t"""
        ...
    
    def GetNumFilters(self) -> int:
        r"""GetNumFilters(SBTypeCategory self) -> uint32_t"""
        ...
    
    def GetNumSynthetics(self) -> int:
        r"""GetNumSynthetics(SBTypeCategory self) -> uint32_t"""
        ...
    
    def GetTypeNameSpecifierForFilterAtIndex(self, arg2: int) -> SBTypeNameSpecifier:
        r"""GetTypeNameSpecifierForFilterAtIndex(SBTypeCategory self, uint32_t arg2) -> SBTypeNameSpecifier"""
        ...
    
    def GetTypeNameSpecifierForFormatAtIndex(self, arg2: int) -> SBTypeNameSpecifier:
        r"""GetTypeNameSpecifierForFormatAtIndex(SBTypeCategory self, uint32_t arg2) -> SBTypeNameSpecifier"""
        ...
    
    def GetTypeNameSpecifierForSummaryAtIndex(self, arg2: int) -> SBTypeNameSpecifier:
        r"""GetTypeNameSpecifierForSummaryAtIndex(SBTypeCategory self, uint32_t arg2) -> SBTypeNameSpecifier"""
        ...
    
    def GetTypeNameSpecifierForSyntheticAtIndex(self, arg2: int) -> SBTypeNameSpecifier:
        r"""GetTypeNameSpecifierForSyntheticAtIndex(SBTypeCategory self, uint32_t arg2) -> SBTypeNameSpecifier"""
        ...
    
    def GetFilterForType(self, arg2: SBTypeNameSpecifier) -> SBTypeFilter:
        r"""GetFilterForType(SBTypeCategory self, SBTypeNameSpecifier arg2) -> SBTypeFilter"""
        ...
    
    def GetFormatForType(self, arg2: SBTypeNameSpecifier) -> SBTypeFormat:
        r"""GetFormatForType(SBTypeCategory self, SBTypeNameSpecifier arg2) -> SBTypeFormat"""
        ...
    
    def GetSummaryForType(self, arg2: SBTypeNameSpecifier) -> SBTypeSummary:
        r"""GetSummaryForType(SBTypeCategory self, SBTypeNameSpecifier arg2) -> SBTypeSummary"""
        ...
    
    def GetSyntheticForType(self, arg2: SBTypeNameSpecifier) -> SBTypeSynthetic:
        r"""GetSyntheticForType(SBTypeCategory self, SBTypeNameSpecifier arg2) -> SBTypeSynthetic"""
        ...
    
    def GetFilterAtIndex(self, arg2: int) -> SBTypeFilter:
        r"""GetFilterAtIndex(SBTypeCategory self, uint32_t arg2) -> SBTypeFilter"""
        ...
    
    def GetFormatAtIndex(self, arg2: int) -> SBTypeFormat:
        r"""GetFormatAtIndex(SBTypeCategory self, uint32_t arg2) -> SBTypeFormat"""
        ...
    
    def GetSummaryAtIndex(self, arg2: int) -> SBTypeSummary:
        r"""GetSummaryAtIndex(SBTypeCategory self, uint32_t arg2) -> SBTypeSummary"""
        ...
    
    def GetSyntheticAtIndex(self, arg2: int) -> SBTypeSynthetic:
        r"""GetSyntheticAtIndex(SBTypeCategory self, uint32_t arg2) -> SBTypeSynthetic"""
        ...
    
    def AddTypeFormat(self, arg2: SBTypeNameSpecifier, arg3: SBTypeFormat) -> bool:
        r"""AddTypeFormat(SBTypeCategory self, SBTypeNameSpecifier arg2, SBTypeFormat arg3) -> bool"""
        ...
    
    def DeleteTypeFormat(self, arg2: SBTypeNameSpecifier) -> bool:
        r"""DeleteTypeFormat(SBTypeCategory self, SBTypeNameSpecifier arg2) -> bool"""
        ...
    
    def AddTypeSummary(self, arg2: SBTypeNameSpecifier, arg3: SBTypeSummary) -> bool:
        r"""AddTypeSummary(SBTypeCategory self, SBTypeNameSpecifier arg2, SBTypeSummary arg3) -> bool"""
        ...
    
    def DeleteTypeSummary(self, arg2: SBTypeNameSpecifier) -> bool:
        r"""DeleteTypeSummary(SBTypeCategory self, SBTypeNameSpecifier arg2) -> bool"""
        ...
    
    def AddTypeFilter(self, arg2: SBTypeNameSpecifier, arg3: SBTypeFilter) -> bool:
        r"""AddTypeFilter(SBTypeCategory self, SBTypeNameSpecifier arg2, SBTypeFilter arg3) -> bool"""
        ...
    
    def DeleteTypeFilter(self, arg2: SBTypeNameSpecifier) -> bool:
        r"""DeleteTypeFilter(SBTypeCategory self, SBTypeNameSpecifier arg2) -> bool"""
        ...
    
    def AddTypeSynthetic(self, arg2: SBTypeNameSpecifier, arg3: SBTypeSynthetic) -> bool:
        r"""AddTypeSynthetic(SBTypeCategory self, SBTypeNameSpecifier arg2, SBTypeSynthetic arg3) -> bool"""
        ...
    
    def DeleteTypeSynthetic(self, arg2: SBTypeNameSpecifier) -> bool:
        r"""DeleteTypeSynthetic(SBTypeCategory self, SBTypeNameSpecifier arg2) -> bool"""
        ...
    
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBTypeCategory self, SBTypeCategory rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBTypeCategory self, SBTypeCategory rhs) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBTypeCategory self) -> std::string"""
        ...
    
    class formatters_access_class:
        '''A helper object that will lazily hand out formatters for a specific category.'''
        def __init__(self, sbcategory, get_count_function, get_at_index_function, get_by_name_function) -> None:
            ...
        
        def __len__(self): # -> int:
            ...
        
        def __getitem__(self, key): # -> None:
            ...
        
    
    
    def get_formats_access_object(self): # -> formatters_access_class:
        '''An accessor function that returns an accessor object which allows lazy format access from a lldb.SBTypeCategory object.'''
        ...
    
    def get_formats_array(self): # -> list[Any]:
        '''An accessor function that returns a list() that contains all formats in a lldb.SBCategory object.'''
        ...
    
    def get_summaries_access_object(self): # -> formatters_access_class:
        '''An accessor function that returns an accessor object which allows lazy summary access from a lldb.SBTypeCategory object.'''
        ...
    
    def get_summaries_array(self): # -> list[Any]:
        '''An accessor function that returns a list() that contains all summaries in a lldb.SBCategory object.'''
        ...
    
    def get_synthetics_access_object(self): # -> formatters_access_class:
        '''An accessor function that returns an accessor object which allows lazy synthetic children provider access from a lldb.SBTypeCategory object.'''
        ...
    
    def get_synthetics_array(self): # -> list[Any]:
        '''An accessor function that returns a list() that contains all synthetic children providers in a lldb.SBCategory object.'''
        ...
    
    def get_filters_access_object(self): # -> formatters_access_class:
        '''An accessor function that returns an accessor object which allows lazy filter access from a lldb.SBTypeCategory object.'''
        ...
    
    def get_filters_array(self): # -> list[Any]:
        '''An accessor function that returns a list() that contains all filters in a lldb.SBCategory object.'''
        ...
    
    formats = ...
    format = ...
    summaries = ...
    summary = ...
    filters = ...
    filter = ...
    synthetics = ...
    synthetic = ...
    num_formats: int = ...
    num_summaries: int = ...
    num_filters: int = ...
    num_synthetics: int = ...
    name: str = ...
    enabled: bool = ...


class SBTypeEnumMember:
    r"""Represents a member of an enum in lldb."""
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBTypeEnumMember self) -> SBTypeEnumMember
        __init__(SBTypeEnumMember self, SBTypeEnumMember rhs) -> SBTypeEnumMember
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBTypeEnumMember self) -> bool"""
        ...
    
    def GetValueAsSigned(self):
        r"""GetValueAsSigned(SBTypeEnumMember self) -> int64_t"""
        ...
    
    def GetValueAsUnsigned(self):
        r"""GetValueAsUnsigned(SBTypeEnumMember self) -> uint64_t"""
        ...
    
    def GetName(self):
        r"""GetName(SBTypeEnumMember self) -> char const *"""
        ...
    
    def GetType(self):
        r"""GetType(SBTypeEnumMember self) -> SBType"""
        ...
    
    def GetDescription(self, description, description_level):
        r"""GetDescription(SBTypeEnumMember self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBTypeEnumMember self) -> std::string"""
        ...
    
    name = ...
    type = ...
    signed = ...
    unsigned = ...


class SBTypeEnumMemberList:
    r"""
    Represents a list of SBTypeEnumMembers.

    SBTypeEnumMemberList supports SBTypeEnumMember iteration.
    It also supports [] access either by index, or by enum
    element name by doing: ::

      myType = target.FindFirstType('MyEnumWithElementA')
      members = myType.GetEnumMembers()
      first_elem = members[0]
      elem_A = members['A']


    """
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBTypeEnumMemberList self) -> SBTypeEnumMemberList
        __init__(SBTypeEnumMemberList self, SBTypeEnumMemberList rhs) -> SBTypeEnumMemberList
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBTypeEnumMemberList self) -> bool"""
        ...
    
    def Append(self, entry):
        r"""Append(SBTypeEnumMemberList self, SBTypeEnumMember entry)"""
        ...
    
    def GetTypeEnumMemberAtIndex(self, index):
        r"""GetTypeEnumMemberAtIndex(SBTypeEnumMemberList self, uint32_t index) -> SBTypeEnumMember"""
        ...
    
    def GetSize(self):
        r"""GetSize(SBTypeEnumMemberList self) -> uint32_t"""
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        '''Iterate over all members in a lldb.SBTypeEnumMemberList object.'''
        ...
    
    def __len__(self):
        '''Return the number of members in a lldb.SBTypeEnumMemberList object.'''
        ...
    
    def __getitem__(self, key): # -> None:
        ...
    


class SBTypeFilter:
    r"""Represents a filter that can be associated to one or more types."""
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBTypeFilter self) -> SBTypeFilter
        __init__(SBTypeFilter self, uint32_t options) -> SBTypeFilter
        __init__(SBTypeFilter self, SBTypeFilter rhs) -> SBTypeFilter
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBTypeFilter self) -> bool"""
        ...
    
    def GetNumberOfExpressionPaths(self):
        r"""GetNumberOfExpressionPaths(SBTypeFilter self) -> uint32_t"""
        ...
    
    def GetExpressionPathAtIndex(self, i):
        r"""GetExpressionPathAtIndex(SBTypeFilter self, uint32_t i) -> char const *"""
        ...
    
    def ReplaceExpressionPathAtIndex(self, i, item):
        r"""ReplaceExpressionPathAtIndex(SBTypeFilter self, uint32_t i, char const * item) -> bool"""
        ...
    
    def AppendExpressionPath(self, item):
        r"""AppendExpressionPath(SBTypeFilter self, char const * item)"""
        ...
    
    def Clear(self):
        r"""Clear(SBTypeFilter self)"""
        ...
    
    def GetOptions(self):
        r"""GetOptions(SBTypeFilter self) -> uint32_t"""
        ...
    
    def SetOptions(self, arg2):
        r"""SetOptions(SBTypeFilter self, uint32_t arg2)"""
        ...
    
    def GetDescription(self, description, description_level):
        r"""GetDescription(SBTypeFilter self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        ...
    
    def IsEqualTo(self, rhs):
        r"""IsEqualTo(SBTypeFilter self, SBTypeFilter rhs) -> bool"""
        ...
    
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBTypeFilter self, SBTypeFilter rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBTypeFilter self, SBTypeFilter rhs) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBTypeFilter self) -> std::string"""
        ...
    
    options = ...
    count = ...
    def __eq__(self, rhs) -> bool:
        ...
    
    def __ne__(self, rhs) -> bool:
        ...
    


class SBTypeFormat:
    r"""Represents a format that can be associated to one or more types."""
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBTypeFormat self) -> SBTypeFormat
        __init__(SBTypeFormat self, lldb::Format format, uint32_t options=0) -> SBTypeFormat
        __init__(SBTypeFormat self, char const * type, uint32_t options=0) -> SBTypeFormat
        __init__(SBTypeFormat self, SBTypeFormat rhs) -> SBTypeFormat
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBTypeFormat self) -> bool"""
        ...
    
    def GetFormat(self):
        r"""GetFormat(SBTypeFormat self) -> lldb::Format"""
        ...
    
    def GetTypeName(self):
        r"""GetTypeName(SBTypeFormat self) -> char const *"""
        ...
    
    def GetOptions(self):
        r"""GetOptions(SBTypeFormat self) -> uint32_t"""
        ...
    
    def SetFormat(self, arg2):
        r"""SetFormat(SBTypeFormat self, lldb::Format arg2)"""
        ...
    
    def SetTypeName(self, arg2):
        r"""SetTypeName(SBTypeFormat self, char const * arg2)"""
        ...
    
    def SetOptions(self, arg2):
        r"""SetOptions(SBTypeFormat self, uint32_t arg2)"""
        ...
    
    def GetDescription(self, description, description_level):
        r"""GetDescription(SBTypeFormat self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        ...
    
    def IsEqualTo(self, rhs):
        r"""IsEqualTo(SBTypeFormat self, SBTypeFormat rhs) -> bool"""
        ...
    
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBTypeFormat self, SBTypeFormat rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBTypeFormat self, SBTypeFormat rhs) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBTypeFormat self) -> std::string"""
        ...
    
    format = ...
    options = ...


class SBTypeNameSpecifier:
    r"""Represents a general way to provide a type name to LLDB APIs."""
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBTypeNameSpecifier self) -> SBTypeNameSpecifier
        __init__(SBTypeNameSpecifier self, char const * name, bool is_regex=False) -> SBTypeNameSpecifier
        __init__(SBTypeNameSpecifier self, char const * name, lldb::FormatterMatchType match_type) -> SBTypeNameSpecifier
        __init__(SBTypeNameSpecifier self, SBType type) -> SBTypeNameSpecifier
        __init__(SBTypeNameSpecifier self, SBTypeNameSpecifier rhs) -> SBTypeNameSpecifier
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBTypeNameSpecifier self) -> bool"""
        ...
    
    def GetName(self):
        r"""GetName(SBTypeNameSpecifier self) -> char const *"""
        ...
    
    def GetType(self):
        r"""GetType(SBTypeNameSpecifier self) -> SBType"""
        ...
    
    def GetMatchType(self):
        r"""GetMatchType(SBTypeNameSpecifier self) -> lldb::FormatterMatchType"""
        ...
    
    def IsRegex(self):
        r"""IsRegex(SBTypeNameSpecifier self) -> bool"""
        ...
    
    def GetDescription(self, description, description_level):
        r"""GetDescription(SBTypeNameSpecifier self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        ...
    
    def IsEqualTo(self, rhs):
        r"""IsEqualTo(SBTypeNameSpecifier self, SBTypeNameSpecifier rhs) -> bool"""
        ...
    
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBTypeNameSpecifier self, SBTypeNameSpecifier rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBTypeNameSpecifier self, SBTypeNameSpecifier rhs) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBTypeNameSpecifier self) -> std::string"""
        ...
    
    name = ...
    is_regex = ...
    def __eq__(self, rhs) -> bool:
        ...
    
    def __ne__(self, rhs) -> bool:
        ...
    


class SBTypeSummaryOptions:
    r"""Proxy of C++ lldb::SBTypeSummaryOptions class."""
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBTypeSummaryOptions self) -> SBTypeSummaryOptions
        __init__(SBTypeSummaryOptions self, SBTypeSummaryOptions rhs) -> SBTypeSummaryOptions
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBTypeSummaryOptions self) -> bool"""
        ...
    
    def GetLanguage(self):
        r"""GetLanguage(SBTypeSummaryOptions self) -> lldb::LanguageType"""
        ...
    
    def GetCapping(self):
        r"""GetCapping(SBTypeSummaryOptions self) -> lldb::TypeSummaryCapping"""
        ...
    
    def SetLanguage(self, arg2):
        r"""SetLanguage(SBTypeSummaryOptions self, lldb::LanguageType arg2)"""
        ...
    
    def SetCapping(self, arg2):
        r"""SetCapping(SBTypeSummaryOptions self, lldb::TypeSummaryCapping arg2)"""
        ...
    


class SBTypeSummary:
    r"""Represents a summary that can be associated to one or more types."""
    thisown = ...
    @staticmethod
    def CreateWithSummaryString(data, options=...):
        r"""CreateWithSummaryString(char const * data, uint32_t options=0) -> SBTypeSummary"""
        ...
    
    @staticmethod
    def CreateWithFunctionName(data, options=...):
        r"""CreateWithFunctionName(char const * data, uint32_t options=0) -> SBTypeSummary"""
        ...
    
    @staticmethod
    def CreateWithScriptCode(data, options=...):
        r"""CreateWithScriptCode(char const * data, uint32_t options=0) -> SBTypeSummary"""
        ...
    
    def __init__(self, *args) -> None:
        r"""
        __init__(SBTypeSummary self) -> SBTypeSummary
        __init__(SBTypeSummary self, SBTypeSummary rhs) -> SBTypeSummary
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBTypeSummary self) -> bool"""
        ...
    
    def IsFunctionCode(self):
        r"""IsFunctionCode(SBTypeSummary self) -> bool"""
        ...
    
    def IsFunctionName(self):
        r"""IsFunctionName(SBTypeSummary self) -> bool"""
        ...
    
    def IsSummaryString(self):
        r"""IsSummaryString(SBTypeSummary self) -> bool"""
        ...
    
    def GetData(self):
        r"""GetData(SBTypeSummary self) -> char const *"""
        ...
    
    def SetSummaryString(self, data):
        r"""SetSummaryString(SBTypeSummary self, char const * data)"""
        ...
    
    def SetFunctionName(self, data):
        r"""SetFunctionName(SBTypeSummary self, char const * data)"""
        ...
    
    def SetFunctionCode(self, data):
        r"""SetFunctionCode(SBTypeSummary self, char const * data)"""
        ...
    
    def GetOptions(self):
        r"""GetOptions(SBTypeSummary self) -> uint32_t"""
        ...
    
    def SetOptions(self, arg2):
        r"""SetOptions(SBTypeSummary self, uint32_t arg2)"""
        ...
    
    def GetDescription(self, description, description_level):
        r"""GetDescription(SBTypeSummary self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        ...
    
    def DoesPrintValue(self, value):
        r"""DoesPrintValue(SBTypeSummary self, SBValue value) -> bool"""
        ...
    
    def IsEqualTo(self, rhs):
        r"""IsEqualTo(SBTypeSummary self, SBTypeSummary rhs) -> bool"""
        ...
    
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBTypeSummary self, SBTypeSummary rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBTypeSummary self, SBTypeSummary rhs) -> bool"""
        ...
    
    def __repr__(self):
        r"""__repr__(SBTypeSummary self) -> std::string"""
        ...
    
    options = ...
    is_summary_string = ...
    is_function_name = ...
    is_function_name = ...
    summary_data = ...
    def __eq__(self, rhs) -> bool:
        ...
    
    def __ne__(self, rhs) -> bool:
        ...
    


class SBTypeSynthetic:
    r"""Represents a summary that can be associated to one or more types."""
    thisown = ...
    @staticmethod
    def CreateWithClassName(data: str, options: int=...) -> SBTypeSynthetic:
        r"""CreateWithClassName(char const * data, uint32_t options=0) -> SBTypeSynthetic"""
        ...
    
    @staticmethod
    def CreateWithScriptCode(data: str, options: int=...) -> SBTypeSynthetic:
        r"""CreateWithScriptCode(char const * data, uint32_t options=0) -> SBTypeSynthetic"""
        ...
    
    def __init__(self, *args) -> None:
        r"""
        __init__(SBTypeSynthetic self) -> SBTypeSynthetic
        __init__(SBTypeSynthetic self, SBTypeSynthetic rhs) -> SBTypeSynthetic
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self) -> bool:
        r"""IsValid(SBTypeSynthetic self) -> bool"""
        ...
    
    def IsClassCode(self) -> bool:
        r"""IsClassCode(SBTypeSynthetic self) -> bool"""
        ...
    
    def IsClassName(self) -> bool:
        r"""IsClassName(SBTypeSynthetic self) -> bool"""
        ...
    
    def GetData(self) -> str:
        r"""GetData(SBTypeSynthetic self) -> char const *"""
        ...
    
    def SetClassName(self, data: str):
        r"""SetClassName(SBTypeSynthetic self, char const * data)"""
        ...
    
    def SetClassCode(self, data: str):
        r"""SetClassCode(SBTypeSynthetic self, char const * data)"""
        ...
    
    def GetOptions(self) -> int:
        r"""GetOptions(SBTypeSynthetic self) -> uint32_t"""
        ...
    
    def SetOptions(self, arg2: int):
        r"""SetOptions(SBTypeSynthetic self, uint32_t arg2)"""
        ...
    
    def GetDescription(self, description: SBStream, description_level) -> bool:
        r"""GetDescription(SBTypeSynthetic self, SBStream description, lldb::DescriptionLevel description_level) -> bool"""
        ...
    
    def IsEqualTo(self, rhs: SBTypeSynthetic) -> bool:
        r"""IsEqualTo(SBTypeSynthetic self, SBTypeSynthetic rhs) -> bool"""
        ...
    
    def __eq__(self, rhs: SBTypeSynthetic) -> bool:
        r"""__eq__(SBTypeSynthetic self, SBTypeSynthetic rhs) -> bool"""
        ...
    
    def __ne__(self, rhs: SBTypeSynthetic) -> bool:
        r"""__ne__(SBTypeSynthetic self, SBTypeSynthetic rhs) -> bool"""
        ...
    
    def __repr__(self) -> str:
        r"""__repr__(SBTypeSynthetic self) -> std::string"""
        ...
    
    options: int = ...
    contains_code: bool = ...
    synthetic_data: str = ...


class SBUnixSignals:
    r"""Allows you to manipulate LLDB's signal disposition"""
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBUnixSignals self) -> SBUnixSignals
        __init__(SBUnixSignals self, SBUnixSignals rhs) -> SBUnixSignals
        """
        ...
    
    __swig_destroy__ = ...
    def Clear(self):
        r"""Clear(SBUnixSignals self)"""
        ...
    
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBUnixSignals self) -> bool"""
        ...
    
    def GetSignalAsCString(self, signo):
        r"""GetSignalAsCString(SBUnixSignals self, int32_t signo) -> char const *"""
        ...
    
    def GetSignalNumberFromName(self, name):
        r"""GetSignalNumberFromName(SBUnixSignals self, char const * name) -> int32_t"""
        ...
    
    def GetShouldSuppress(self, signo):
        r"""GetShouldSuppress(SBUnixSignals self, int32_t signo) -> bool"""
        ...
    
    def SetShouldSuppress(self, signo, value):
        r"""SetShouldSuppress(SBUnixSignals self, int32_t signo, bool value) -> bool"""
        ...
    
    def GetShouldStop(self, signo):
        r"""GetShouldStop(SBUnixSignals self, int32_t signo) -> bool"""
        ...
    
    def SetShouldStop(self, signo, value):
        r"""SetShouldStop(SBUnixSignals self, int32_t signo, bool value) -> bool"""
        ...
    
    def GetShouldNotify(self, signo):
        r"""GetShouldNotify(SBUnixSignals self, int32_t signo) -> bool"""
        ...
    
    def SetShouldNotify(self, signo, value):
        r"""SetShouldNotify(SBUnixSignals self, int32_t signo, bool value) -> bool"""
        ...
    
    def GetNumSignals(self):
        r"""GetNumSignals(SBUnixSignals self) -> int32_t"""
        ...
    
    def GetSignalAtIndex(self, index):
        r"""GetSignalAtIndex(SBUnixSignals self, int32_t index) -> int32_t"""
        ...
    
    def get_unix_signals_list(self): # -> list[Any]:
        ...
    
    threads = ...


# noinspection PyPep8Naming
class SBValue:
    r"""
    Represents the value of a variable, a register, or an expression.

    SBValue supports iteration through its child, which in turn is represented
    as an SBValue.  For example, we can get the general purpose registers of a
    frame as an SBValue, and iterate through all the registers,::

        registerSet = frame.registers # Returns an SBValueList.
        for regs in registerSet:
            if 'general purpose registers' in regs.name.lower():
                GPRs = regs
                break

        print('%s (number of children = %d):' % (GPRs.name, GPRs.num_children))
        for reg in GPRs:
            print('Name: ', reg.name, ' Value: ', reg.value)

    produces the output: ::

        General Purpose Registers (number of children = 21):
        Name:  rax  Value:  0x0000000100000c5c
        Name:  rbx  Value:  0x0000000000000000
        Name:  rcx  Value:  0x00007fff5fbffec0
        Name:  rdx  Value:  0x00007fff5fbffeb8
        Name:  rdi  Value:  0x0000000000000001
        Name:  rsi  Value:  0x00007fff5fbffea8
        Name:  rbp  Value:  0x00007fff5fbffe80
        Name:  rsp  Value:  0x00007fff5fbffe60
        Name:  r8  Value:  0x0000000008668682
        Name:  r9  Value:  0x0000000000000000
        Name:  r10  Value:  0x0000000000001200
        Name:  r11  Value:  0x0000000000000206
        Name:  r12  Value:  0x0000000000000000
        Name:  r13  Value:  0x0000000000000000
        Name:  r14  Value:  0x0000000000000000
        Name:  r15  Value:  0x0000000000000000
        Name:  rip  Value:  0x0000000100000dae
        Name:  rflags  Value:  0x0000000000000206
        Name:  cs  Value:  0x0000000000000027
        Name:  fs  Value:  0x0000000000000010
        Name:  gs  Value:  0x0000000000000048

    See also linked_list_iter() for another perspective on how to iterate through an
    SBValue instance which interprets the value object as representing the head of a
    linked list.
    """
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBValue self) -> SBValue
        __init__(SBValue self, SBValue rhs) -> SBValue
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self) -> bool:
        r"""IsValid(SBValue self) -> bool"""
        ...
    
    def Clear(self):
        r"""Clear(SBValue self)"""
        ...
    
    def GetError(self) -> SBError:
        r"""GetError(SBValue self) -> SBError"""
        ...
    
    def GetID(self):
        r"""GetID(SBValue self) -> lldb::user_id_t"""
        ...
    
    def GetName(self) -> str:
        r"""GetName(SBValue self) -> char const *"""
        ...
    
    def GetTypeName(self) -> str:
        r"""GetTypeName(SBValue self) -> char const *"""
        ...
    
    def GetDisplayTypeName(self) -> str:
        r"""GetDisplayTypeName(SBValue self) -> char const *"""
        ...
    
    def GetByteSize(self) -> int:
        r"""GetByteSize(SBValue self) -> size_t"""
        ...
    
    def IsInScope(self) -> bool:
        r"""IsInScope(SBValue self) -> bool"""
        ...
    
    def GetFormat(self):
        r"""GetFormat(SBValue self) -> lldb::Format"""
        ...
    
    def SetFormat(self, format):
        r"""SetFormat(SBValue self, lldb::Format format)"""
        ...
    
    def GetValue(self) -> str:
        r"""GetValue(SBValue self) -> char const *"""
        ...
    
    def GetValueAsSigned(self, *args) -> int:
        r"""
        GetValueAsSigned(SBValue self, SBError error, int64_t fail_value=0) -> int64_t
        GetValueAsSigned(SBValue self, int64_t fail_value=0) -> int64_t
        """
        ...
    
    def GetValueAsUnsigned(self, *args) -> int:
        r"""
        GetValueAsUnsigned(SBValue self, SBError error, uint64_t fail_value=0) -> uint64_t
        GetValueAsUnsigned(SBValue self, uint64_t fail_value=0) -> uint64_t
        """
        ...
    
    def GetValueAsAddress(self) -> int:
        r"""
        GetValueAsAddress(SBValue self) -> lldb::addr_t
             // Return the value as an address.  On failure,
             // LLDB_INVALID_ADDRESS will be returned.
             // On architectures like the ARMv8.3 ISA, where the
             // top (unaddressable) bits can be used for authentication,
             // this method will return the value with the auth bits
             // stripped.  GetValueAsUnsigned will return the value
             // as-is, with any the authentication bits.  Calling this on 
             // a random value which is not a pointer is an error.  
             // Call GetType().IsPointerType() if in doubt.  An example of
             // a tricky situation is a register SBValue without any type -
             // the value may be an address with auth bits, or it may be a
             // data field.  In these cases, looking up the GetValueAsAddress
             // address to see if it points to a symbol in the process and
             // that may indicate the presence of authentication bits.
             // Users may want to see both the value with auth bits (GetValueAsUnsigned)
             // and value with auth bits cleared (GetValueAsAddress) - it is 
             // up to script writers to decide what is best in your own case.
        """
        ...
    
    def GetValueType(self):
        r"""GetValueType(SBValue self) -> lldb::ValueType"""
        ...
    
    def GetValueDidChange(self) -> bool:
        r"""GetValueDidChange(SBValue self) -> bool"""
        ...
    
    def GetSummary(self, *args):
        r"""
        GetSummary(SBValue self) -> char const
        GetSummary(SBValue self, SBStream stream, SBTypeSummaryOptions options) -> char const *
        """
        ...
    
    def GetObjectDescription(self) -> str:
        r"""GetObjectDescription(SBValue self) -> char const *"""
        ...
    
    def GetDynamicValue(self, use_dynamic) -> SBValue:
        r"""GetDynamicValue(SBValue self, lldb::DynamicValueType use_dynamic) -> SBValue"""
        ...
    
    def GetStaticValue(self) -> SBValue:
        r"""GetStaticValue(SBValue self) -> SBValue"""
        ...
    
    def GetNonSyntheticValue(self) -> SBValue:
        r"""GetNonSyntheticValue(SBValue self) -> SBValue"""
        ...
    
    def GetPreferDynamicValue(self):
        r"""GetPreferDynamicValue(SBValue self) -> lldb::DynamicValueType"""
        ...
    
    def SetPreferDynamicValue(self, use_dynamic):
        r"""SetPreferDynamicValue(SBValue self, lldb::DynamicValueType use_dynamic)"""
        ...
    
    def GetPreferSyntheticValue(self) -> bool:
        r"""GetPreferSyntheticValue(SBValue self) -> bool"""
        ...
    
    def SetPreferSyntheticValue(self, use_synthetic: bool):
        r"""SetPreferSyntheticValue(SBValue self, bool use_synthetic)"""
        ...
    
    def IsDynamic(self) -> bool:
        r"""IsDynamic(SBValue self) -> bool"""
        ...
    
    def IsSynthetic(self) -> bool:
        r"""IsSynthetic(SBValue self) -> bool"""
        ...
    
    def IsSyntheticChildrenGenerated(self) -> bool:
        r"""IsSyntheticChildrenGenerated(SBValue self) -> bool"""
        ...
    
    def SetSyntheticChildrenGenerated(self, arg2: bool):
        r"""SetSyntheticChildrenGenerated(SBValue self, bool arg2)"""
        ...
    
    def GetLocation(self):
        r"""GetLocation(SBValue self) -> char const *"""
        ...
    
    def SetValueFromCString(self, *args) -> bool:
        r"""
        SetValueFromCString(SBValue self, char const * value_str) -> bool
        SetValueFromCString(SBValue self, char const * value_str, SBError error) -> bool
        """
        ...
    
    def GetTypeFormat(self) -> SBTypeFormat:
        r"""GetTypeFormat(SBValue self) -> SBTypeFormat"""
        ...
    
    def GetTypeSummary(self) -> SBTypeSummary:
        r"""GetTypeSummary(SBValue self) -> SBTypeSummary"""
        ...
    
    def GetTypeFilter(self) -> SBTypeFilter:
        r"""GetTypeFilter(SBValue self) -> SBTypeFilter"""
        ...
    
    def GetTypeSynthetic(self) -> SBTypeSynthetic:
        r"""GetTypeSynthetic(SBValue self) -> SBTypeSynthetic"""
        ...
    
    def CreateChildAtOffset(self, name: str, offset: int, type: SBType) -> SBValue:
        r"""CreateChildAtOffset(SBValue self, char const * name, uint32_t offset, SBType type) -> SBValue"""
        ...
    
    def Cast(self, type: SBType) -> SBValue:
        r"""Cast(SBValue self, SBType type) -> SBValue"""
        ...
    
    def CreateValueFromExpression(self, *args) -> SBValue:
        r"""
        CreateValueFromExpression(SBValue self, char const * name, char const * expression) -> SBValue
        CreateValueFromExpression(SBValue self, char const * name, char const * expression, SBExpressionOptions options) -> SBValue
        """
        ...
    
    def CreateValueFromAddress(self, name: str, address: int, type: SBType) -> SBValue:
        r"""CreateValueFromAddress(SBValue self, char const * name, lldb::addr_t address, SBType type) -> SBValue"""
        ...
    
    def CreateValueFromData(self, name: str, data: SBData, type: SBType) -> SBValue:
        r"""CreateValueFromData(SBValue self, char const * name, SBData data, SBType type) -> SBValue"""
        ...
    
    def GetChildAtIndex(self, *args) -> SBValue:
        r"""
        GetChildAtIndex(SBValue self, uint32_t idx) -> SBValue
        GetChildAtIndex(SBValue self, uint32_t idx, lldb::DynamicValueType use_dynamic, bool can_create_synthetic) -> SBValue

            Get a child value by index from a value.

            Structs, unions, classes, arrays and pointers have child
            values that can be access by index.

            Structs and unions access child members using a zero based index
            for each child member. For

            Classes reserve the first indexes for base classes that have
            members (empty base classes are omitted), and all members of the
            current class will then follow the base classes.

            Pointers differ depending on what they point to. If the pointer
            points to a simple type, the child at index zero
            is the only child value available, unless synthetic_allowed
            is true, in which case the pointer will be used as an array
            and can create 'synthetic' child values using positive or
            negative indexes. If the pointer points to an aggregate type
            (an array, class, union, struct), then the pointee is
            transparently skipped and any children are going to be the indexes
            of the child values within the aggregate type. For example if
            we have a 'Point' type and we have a SBValue that contains a
            pointer to a 'Point' type, then the child at index zero will be
            the 'x' member, and the child at index 1 will be the 'y' member
            (the child at index zero won't be a 'Point' instance).

            If you actually need an SBValue that represents the type pointed
            to by a SBValue for which GetType().IsPointeeType() returns true,
            regardless of the pointee type, you can do that with the SBValue.Dereference
            method (or the equivalent deref property).

            Arrays have a preset number of children that can be accessed by
            index and will returns invalid child values for indexes that are
            out of bounds unless the synthetic_allowed is true. In this
            case the array can create 'synthetic' child values for indexes
            that aren't in the array bounds using positive or negative
            indexes.

            @param[in] idx
                The index of the child value to get

            @param[in] use_dynamic
                An enumeration that specifies whether to get dynamic values,
                and also if the target can be run to figure out the dynamic
                type of the child value.

            @param[in] synthetic_allowed
                If true, then allow child values to be created by index
                for pointers and arrays for indexes that normally wouldn't
                be allowed.

            @return
                A new SBValue object that represents the child member value.
        """
        ...
    
    def GetIndexOfChildWithName(self, name):
        r"""
        GetIndexOfChildWithName(SBValue self, char const * name) -> uint32_t

            Returns the child member index.

            Matches children of this object only and will match base classes and
            member names if this is a clang typed object.

            @param[in] name
                The name of the child value to get

            @return
                An index to the child member value.
        """
        ...
    
    def GetChildMemberWithName(self, *args) -> SBValue:
        r"""
        GetChildMemberWithName(SBValue self, char const * name) -> SBValue
        GetChildMemberWithName(SBValue self, char const * name, lldb::DynamicValueType use_dynamic) -> SBValue

            Returns the child member value.

            Matches child members of this object and child members of any base
            classes.

            @param[in] name
                The name of the child value to get

            @param[in] use_dynamic
                An enumeration that specifies whether to get dynamic values,
                and also if the target can be run to figure out the dynamic
                type of the child value.

            @return
                A new SBValue object that represents the child member value.
        """
        ...
    
    def GetValueForExpressionPath(self, expr_path) -> SBValue:
        r"""
        GetValueForExpressionPath(SBValue self, char const * expr_path) -> SBValue
        Expands nested expressions like .a->b[0].c[1]->d.
        """
        ...
    
    def AddressOf(self) -> SBValue:
        r"""AddressOf(SBValue self) -> SBValue"""
        ...
    
    def GetLoadAddress(self) -> int:
        r"""GetLoadAddress(SBValue self) -> lldb::addr_t"""
        ...
    
    def GetAddress(self) -> SBAddress:
        r"""GetAddress(SBValue self) -> SBAddress"""
        ...
    
    def GetPointeeData(self, item_idx: int=..., item_count: int=...) -> SBData:
        r"""
        GetPointeeData(SBValue self, uint32_t item_idx=0, uint32_t item_count=1) -> SBData

            Get an SBData wrapping what this SBValue points to.

            This method will dereference the current SBValue, if its
            data type is a ``T\*`` or ``T[]``, and extract ``item_count`` elements
            of type ``T`` from it, copying their contents in an :py:class:`SBData`.

            :param item_idx: The index of the first item to retrieve. For an array
                this is equivalent to array[item_idx], for a pointer
                to ``\*(pointer + item_idx)``. In either case, the measurement
                unit for item_idx is the ``sizeof(T)`` rather than the byte
            :param item_count: How many items should be copied into the output. By default
                only one item is copied, but more can be asked for.
            :return: The contents of the copied items on success. An empty :py:class:`SBData` otherwise.
            :rtype: SBData

        """
        ...
    
    def GetData(self) -> SBData:
        r"""
        GetData(SBValue self) -> SBData

            Get an SBData wrapping the contents of this SBValue.

            This method will read the contents of this object in memory
            and copy them into an SBData for future use.

            @return
                An SBData with the contents of this SBValue, on success.
                An empty SBData otherwise.
        """
        ...
    
    def SetData(self, data: SBData, error: SBError) -> bool:
        r"""SetData(SBValue self, SBData data, SBError error) -> bool"""
        ...
    
    def Clone(self, new_name: str) -> SBValue:
        r"""Clone(SBValue self, char const * new_name) -> SBValue"""
        ...
    
    def GetDeclaration(self) -> SBDeclaration:
        r"""GetDeclaration(SBValue self) -> SBDeclaration"""
        ...
    
    def MightHaveChildren(self) -> bool:
        r"""MightHaveChildren(SBValue self) -> bool"""
        ...
    
    def IsRuntimeSupportValue(self) -> bool:
        r"""IsRuntimeSupportValue(SBValue self) -> bool"""
        ...
    
    def GetNumChildren(self, *args) -> int:
        r"""
        GetNumChildren(SBValue self) -> uint32_t
        GetNumChildren(SBValue self, uint32_t max) -> uint32_t
        """
        ...
    
    def GetOpaqueType(self):
        r"""GetOpaqueType(SBValue self) -> void *"""
        ...
    
    def GetTarget(self) -> SBTarget:
        r"""GetTarget(SBValue self) -> SBTarget"""
        ...
    
    def GetProcess(self) -> SBProcess:
        r"""GetProcess(SBValue self) -> SBProcess"""
        ...
    
    def GetThread(self) -> SBThread:
        r"""GetThread(SBValue self) -> SBThread"""
        ...
    
    def GetFrame(self) -> SBFrame:
        r"""GetFrame(SBValue self) -> SBFrame"""
        ...
    
    def Dereference(self) -> SBValue:
        r"""Dereference(SBValue self) -> SBValue"""
        ...
    
    def TypeIsPointerType(self) -> bool:
        r"""TypeIsPointerType(SBValue self) -> bool"""
        ...
    
    def GetType(self) -> SBType:
        r"""GetType(SBValue self) -> SBType"""
        ...
    
    def Persist(self) -> SBValue:
        r"""Persist(SBValue self) -> SBValue"""
        ...
    
    def GetDescription(self, description):
        r"""GetDescription(SBValue self, SBStream description) -> bool"""
        ...
    
    def GetExpressionPath(self, *args):
        r"""
        GetExpressionPath(SBValue self, SBStream description) -> bool
        GetExpressionPath(SBValue self, SBStream description, bool qualify_cxx_base_classes) -> bool
        Returns an expression path for this value.
        """
        ...
    
    def EvaluateExpression(self, *args):
        r"""
        EvaluateExpression(SBValue self, char const * expr) -> SBValue
        EvaluateExpression(SBValue self, char const * expr, SBExpressionOptions options) -> SBValue
        EvaluateExpression(SBValue self, char const * expr, SBExpressionOptions options, char const * name) -> SBValue
        """
        ...
    
    def Watch(self, *args):
        r"""
        Watch(SBValue self, bool resolve_location, bool read, bool write, SBError error) -> SBWatchpoint
        Watch(SBValue self, bool resolve_location, bool read, bool write) -> SBWatchpoint

            Find and watch a variable.
            It returns an SBWatchpoint, which may be invalid.
        """
        ...
    
    def WatchPointee(self, resolve_location, read, write, error):
        r"""
        WatchPointee(SBValue self, bool resolve_location, bool read, bool write, SBError error) -> SBWatchpoint

            Find and watch the location pointed to by a variable.
            It returns an SBWatchpoint, which may be invalid.
        """
        ...
    
    def __repr__(self):
        r"""__repr__(SBValue self) -> std::string"""
        ...
    
    def __get_dynamic__(self):
        '''Helper function for the "SBValue.dynamic" property.'''
        ...
    
    class children_access:
        '''A helper object that will lazily hand out thread for a process when supplied an index.'''
        def __init__(self, sbvalue) -> None:
            ...
        
        def __len__(self): # -> int:
            ...
        
        def __getitem__(self, key): # -> None:
            ...
        
    
    
    def get_child_access_object(self): # -> children_access:
        '''An accessor function that returns a children_access() object which allows lazy member variable access from a lldb.SBValue object.'''
        ...
    
    def get_value_child_list(self): # -> list[Any]:
        '''An accessor function that returns a list() that contains all children in a lldb.SBValue object.'''
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        '''Iterate over all child values of a lldb.SBValue object.'''
        ...
    
    def __len__(self):
        '''Return the number of child values of a lldb.SBValue object.'''
        ...
    
    children = ...
    child = ...
    name: str = ...
    type: SBType = ...
    size: int = ...
    is_in_scope: bool = ...
    format: str = ...
    value: str = ...
    value_type = ...
    changed: bool = ...
    data: SBData = ...
    load_addr: int = ...
    addr: SBAddress = ...
    deref: SBValue = ...
    address_of: SBValue = ...
    error: SBError = ...
    summary: str = ...
    description: str = ...
    dynamic = ...
    location: str = ...
    target: SBTarget = ...
    process: SBProcess = ...
    thread: SBThread = ...
    frame: SBFrame = ...
    num_children: int = ...
    unsigned: int = ...
    signed: int = ...
    def get_expr_path(self):
        ...
    
    path = ...
    def synthetic_child_from_expression(self, name, expr, options=...):
        ...
    
    def synthetic_child_from_data(self, name, data, type):
        ...
    
    def synthetic_child_from_address(self, name, addr, type):
        ...
    
    def linked_list_iter(self, next_item_name, end_of_list_test=...): # -> Generator[Self | Any, Any, None]:
        """Generator adaptor to support iteration for SBValue as a linked list.

        linked_list_iter() is a special purpose iterator to treat the SBValue as
        the head of a list data structure, where you specify the child member
        name which points to the next item on the list and you specify the
        end-of-list test function which takes an SBValue for an item and returns
        True if EOL is reached and False if not.

        linked_list_iter() also detects infinite loop and bails out early.

        The end_of_list_test arg, if omitted, defaults to the __eol_test
        function above.

        For example,

    # Get Frame #0.
        ...

    # Get variable 'task_head'.
        task_head = frame0.FindVariable('task_head')
        ...

        for t in task_head.linked_list_iter('next'):
            print t
        """
        ...
    


class SBValueList:
    r"""
    Represents a collection of SBValues.  Both :py:class:`SBFrame.GetVariables()` and
    :py:class:`SBFrame.GetRegisters()` return a SBValueList.

    SBValueList supports :py:class:`SBValue` iteration. For example (from test/lldbutil.py),::

        def get_registers(frame, kind):
            '''Returns the registers given the frame and the kind of registers desired.

            Returns None if there's no such kind.
            '''
            registerSet = frame.GetRegisters() # Return type of SBValueList.
            for value in registerSet:
                if kind.lower() in value.GetName().lower():
                    return value

            return None

        def get_GPRs(frame):
            '''Returns the general purpose registers of the frame as an SBValue.

            The returned SBValue object is iterable.  An example:
                ...
                from lldbutil import get_GPRs
                regs = get_GPRs(frame)
                for reg in regs:
                    print('%s => %s' % (reg.GetName(), reg.GetValue()))
                ...
            '''
            return get_registers(frame, 'general purpose')

        def get_FPRs(frame):
            '''Returns the floating point registers of the frame as an SBValue.

            The returned SBValue object is iterable.  An example:
                ...
                from lldbutil import get_FPRs
                regs = get_FPRs(frame)
                for reg in regs:
                    print('%s => %s' % (reg.GetName(), reg.GetValue()))
                ...
            '''
            return get_registers(frame, 'floating point')

        def get_ESRs(frame):
            '''Returns the exception state registers of the frame as an SBValue.

            The returned SBValue object is iterable.  An example:
                ...
                from lldbutil import get_ESRs
                regs = get_ESRs(frame)
                for reg in regs:
                    print('%s => %s' % (reg.GetName(), reg.GetValue()))
                ...
            '''
            return get_registers(frame, 'exception state')

    """
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBValueList self) -> SBValueList
        __init__(SBValueList self, SBValueList rhs) -> SBValueList
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBValueList self) -> bool"""
        ...
    
    def Clear(self):
        r"""Clear(SBValueList self)"""
        ...
    
    def Append(self, *args):
        r"""
        Append(SBValueList self, SBValue val_obj)
        Append(SBValueList self, SBValueList value_list)
        """
        ...
    
    def GetSize(self):
        r"""GetSize(SBValueList self) -> uint32_t"""
        ...
    
    def GetValueAtIndex(self, idx):
        r"""GetValueAtIndex(SBValueList self, uint32_t idx) -> SBValue"""
        ...
    
    def GetFirstValueByName(self, name):
        r"""GetFirstValueByName(SBValueList self, char const * name) -> SBValue"""
        ...
    
    def FindValueObjectByUID(self, uid):
        r"""FindValueObjectByUID(SBValueList self, lldb::user_id_t uid) -> SBValue"""
        ...
    
    def GetError(self):
        r"""GetError(SBValueList self) -> SBError"""
        ...
    
    def __str__(self) -> str:
        r"""__str__(SBValueList self) -> std::string"""
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        '''Iterate over all values in a lldb.SBValueList object.'''
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __getitem__(self, key): # -> list[Any] | None:
        ...
    


class SBVariablesOptions:
    r"""Describes which variables should be returned from :py:class:`SBFrame.GetVariables`."""
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBVariablesOptions self) -> SBVariablesOptions
        __init__(SBVariablesOptions self, SBVariablesOptions options) -> SBVariablesOptions
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def IsValid(self):
        r"""IsValid(SBVariablesOptions self) -> bool"""
        ...
    
    def GetIncludeArguments(self):
        r"""GetIncludeArguments(SBVariablesOptions self) -> bool"""
        ...
    
    def SetIncludeArguments(self, arg2):
        r"""SetIncludeArguments(SBVariablesOptions self, bool arg2)"""
        ...
    
    def GetIncludeRecognizedArguments(self, arg2):
        r"""GetIncludeRecognizedArguments(SBVariablesOptions self, SBTarget arg2) -> bool"""
        ...
    
    def SetIncludeRecognizedArguments(self, arg2):
        r"""SetIncludeRecognizedArguments(SBVariablesOptions self, bool arg2)"""
        ...
    
    def GetIncludeLocals(self):
        r"""GetIncludeLocals(SBVariablesOptions self) -> bool"""
        ...
    
    def SetIncludeLocals(self, arg2):
        r"""SetIncludeLocals(SBVariablesOptions self, bool arg2)"""
        ...
    
    def GetIncludeStatics(self):
        r"""GetIncludeStatics(SBVariablesOptions self) -> bool"""
        ...
    
    def SetIncludeStatics(self, arg2):
        r"""SetIncludeStatics(SBVariablesOptions self, bool arg2)"""
        ...
    
    def GetInScopeOnly(self):
        r"""GetInScopeOnly(SBVariablesOptions self) -> bool"""
        ...
    
    def SetInScopeOnly(self, arg2):
        r"""SetInScopeOnly(SBVariablesOptions self, bool arg2)"""
        ...
    
    def GetIncludeRuntimeSupportValues(self):
        r"""GetIncludeRuntimeSupportValues(SBVariablesOptions self) -> bool"""
        ...
    
    def SetIncludeRuntimeSupportValues(self, arg2):
        r"""SetIncludeRuntimeSupportValues(SBVariablesOptions self, bool arg2)"""
        ...
    
    def GetUseDynamic(self):
        r"""GetUseDynamic(SBVariablesOptions self) -> lldb::DynamicValueType"""
        ...
    
    def SetUseDynamic(self, arg2):
        r"""SetUseDynamic(SBVariablesOptions self, lldb::DynamicValueType arg2)"""
        ...
    


class SBWatchpoint:
    r"""
    Represents an instance of watchpoint for a specific target program.

    A watchpoint is determined by the address and the byte size that resulted in
    this particular instantiation.  Each watchpoint has its settable options.

    See also :py:class:`SBTarget.watchpoint_iter()` for example usage of iterating through the
    watchpoints of the target.
    """
    thisown = ...
    def __init__(self, *args) -> None:
        r"""
        __init__(SBWatchpoint self) -> SBWatchpoint
        __init__(SBWatchpoint self, SBWatchpoint rhs) -> SBWatchpoint
        """
        ...
    
    __swig_destroy__ = ...
    def __nonzero__(self):
        ...
    
    __bool__ = ...
    def __eq__(self, rhs) -> bool:
        r"""__eq__(SBWatchpoint self, SBWatchpoint rhs) -> bool"""
        ...
    
    def __ne__(self, rhs) -> bool:
        r"""__ne__(SBWatchpoint self, SBWatchpoint rhs) -> bool"""
        ...
    
    def IsValid(self):
        r"""IsValid(SBWatchpoint self) -> bool"""
        ...
    
    def GetError(self):
        r"""GetError(SBWatchpoint self) -> SBError"""
        ...
    
    def GetID(self):
        r"""GetID(SBWatchpoint self) -> lldb::watch_id_t"""
        ...
    
    def GetHardwareIndex(self):
        r"""
        GetHardwareIndex(SBWatchpoint self) -> int32_t

            With -1 representing an invalid hardware index.
        """
        ...
    
    def GetWatchAddress(self):
        r"""GetWatchAddress(SBWatchpoint self) -> lldb::addr_t"""
        ...
    
    def GetWatchSize(self):
        r"""GetWatchSize(SBWatchpoint self) -> size_t"""
        ...
    
    def SetEnabled(self, enabled):
        r"""SetEnabled(SBWatchpoint self, bool enabled)"""
        ...
    
    def IsEnabled(self):
        r"""IsEnabled(SBWatchpoint self) -> bool"""
        ...
    
    def GetHitCount(self):
        r"""GetHitCount(SBWatchpoint self) -> uint32_t"""
        ...
    
    def GetIgnoreCount(self):
        r"""GetIgnoreCount(SBWatchpoint self) -> uint32_t"""
        ...
    
    def SetIgnoreCount(self, n):
        r"""SetIgnoreCount(SBWatchpoint self, uint32_t n)"""
        ...
    
    def GetCondition(self):
        r"""
        GetCondition(SBWatchpoint self) -> char const *

            Get the condition expression for the watchpoint.
        """
        ...
    
    def SetCondition(self, condition):
        r"""
        SetCondition(SBWatchpoint self, char const * condition)

            The watchpoint stops only if the condition expression evaluates to true.
        """
        ...
    
    def GetDescription(self, description, level):
        r"""GetDescription(SBWatchpoint self, SBStream description, lldb::DescriptionLevel level) -> bool"""
        ...
    
    def Clear(self):
        r"""Clear(SBWatchpoint self)"""
        ...
    
    @staticmethod
    def EventIsWatchpointEvent(event):
        r"""EventIsWatchpointEvent(SBEvent event) -> bool"""
        ...
    
    @staticmethod
    def GetWatchpointEventTypeFromEvent(event):
        r"""GetWatchpointEventTypeFromEvent(SBEvent event) -> lldb::WatchpointEventType"""
        ...
    
    @staticmethod
    def GetWatchpointFromEvent(event):
        r"""GetWatchpointFromEvent(SBEvent event) -> SBWatchpoint"""
        ...
    
    def GetType(self):
        r"""
        GetType(SBWatchpoint self) -> SBType

            Returns the type recorded when the watchpoint was created. For variable
            watchpoints it is the type of the watched variable. For expression
            watchpoints it is the type of the provided expression.
        """
        ...
    
    def GetWatchValueKind(self):
        r"""
        GetWatchValueKind(SBWatchpoint self) -> lldb::WatchpointValueKind

            Returns the kind of value that was watched when the watchpoint was created.
            Returns one of the following eWatchPointValueKindVariable,
            eWatchPointValueKindExpression, eWatchPointValueKindInvalid.

        """
        ...
    
    def GetWatchSpec(self):
        r"""
        GetWatchSpec(SBWatchpoint self) -> char const *

            Get the spec for the watchpoint. For variable watchpoints this is the name
            of the variable. For expression watchpoints it is empty
            (may change in the future).
        """
        ...
    
    def IsWatchingReads(self):
        r"""
        IsWatchingReads(SBWatchpoint self) -> bool

            Returns true if the watchpoint is watching reads. Returns false otherwise.
        """
        ...
    
    def IsWatchingWrites(self):
        r"""
        IsWatchingWrites(SBWatchpoint self) -> bool

            Returns true if the watchpoint is watching writes. Returns false otherwise.
        """
        ...
    
    def __repr__(self):
        r"""__repr__(SBWatchpoint self) -> std::string"""
        ...
    


def in_range(symbol, section): # -> bool:
    """Test whether a symbol is within the range of a section."""
    ...

def command(command_name=..., doc=...): # -> Callable[..., Any]:
    ...

class declaration:
    '''A class that represents a source declaration location with file, line and column.'''
    def __init__(self, file, line, col) -> None:
        ...
    


class value_iter:
    '''Allows iterating over the children of an :py:class:`SBValue`.'''
    def __iter__(self): # -> Self:
        ...
    
    def __next__(self): # -> value:
        ...
    
    def next(self): # -> value:
        ...
    
    def __init__(self, value) -> None:
        ...
    


class value:
    '''Wraps :py:class:`SBValue` objects so the resulting object can be used as a variable would be in code.

    So if you have a Point structure variable in your code in the current frame named "pt",
    you can initialize an instance of this class with it: ::

        pt = lldb.value(lldb.frame.FindVariable("pt"))
        print pt
        print pt.x
        print pt.y

        pt = lldb.value(lldb.frame.FindVariable("rectangle_array"))
        print rectangle_array[12]
        print rectangle_array[5].origin.x'''
    def __init__(self, sbvalue) -> None:
        ...
    
    def __nonzero__(self):
        ...
    
    def __bool__(self):
        ...
    
    def __str__(self) -> str:
        ...
    
    def __getitem__(self, key): # -> value:
        ...
    
    def __iter__(self): # -> value_iter:
        ...
    
    def __getattr__(self, name): # -> value:
        ...
    
    def __add__(self, other): # -> int:
        ...
    
    def __sub__(self, other): # -> int:
        ...
    
    def __mul__(self, other): # -> int:
        ...
    
    def __floordiv__(self, other): # -> int:
        ...
    
    def __mod__(self, other): # -> int:
        ...
    
    def __divmod__(self, other): # -> int:
        ...
    
    def __pow__(self, other): # -> Any:
        ...
    
    def __lshift__(self, other): # -> int:
        ...
    
    def __rshift__(self, other): # -> int:
        ...
    
    def __and__(self, other): # -> int:
        ...
    
    def __xor__(self, other): # -> int:
        ...
    
    def __or__(self, other): # -> int:
        ...
    
    def __div__(self, other): # -> float:
        ...
    
    def __truediv__(self, other): # -> float:
        ...
    
    def __iadd__(self, other): # -> int:
        ...
    
    def __isub__(self, other): # -> int:
        ...
    
    def __imul__(self, other): # -> int:
        ...
    
    def __idiv__(self, other): # -> float:
        ...
    
    def __itruediv__(self, other): # -> float:
        ...
    
    def __ifloordiv__(self, other):
        ...
    
    def __imod__(self, other):
        ...
    
    def __ipow__(self, other):
        ...
    
    def __ipow__(self, other, modulo):
        ...
    
    def __ilshift__(self, other): # -> int:
        ...
    
    def __irshift__(self, other): # -> int:
        ...
    
    def __iand__(self, other):
        ...
    
    def __ixor__(self, other):
        ...
    
    def __ior__(self, other):
        ...
    
    def __neg__(self): # -> int:
        ...
    
    def __pos__(self): # -> int:
        ...
    
    def __abs__(self): # -> int:
        ...
    
    def __invert__(self): # -> int:
        ...
    
    def __complex__(self): # -> complex:
        ...
    
    def __int__(self) -> int:
        ...
    
    def __long__(self):
        ...
    
    def __float__(self): # -> float:
        ...
    
    def __oct__(self):
        ...
    
    def __hex__(self):
        ...
    
    def __len__(self):
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    


class SBSyntheticValueProvider:
    def __init__(self, valobj) -> None:
        ...
    
    def num_children(self): # -> Literal[0]:
        ...
    
    def get_child_index(self, name): # -> None:
        ...
    
    def get_child_at_index(self, idx): # -> None:
        ...
    
    def update(self): # -> None:
        ...
    
    def has_children(self): # -> Literal[False]:
        ...
    


def is_numeric_type(basic_type): # -> tuple[Literal[False], Literal[False]] | tuple[Literal[True], Literal[False]] | tuple[Literal[True], Literal[True]]:
    ...

debugger_unique_id = ...
debugger: SBDebugger = ...
target: SBTarget = ...
process: SBProcess = ...
thread: SBThread = ...
frame: SBFrame = ...
sbaddress_workaround = ...
